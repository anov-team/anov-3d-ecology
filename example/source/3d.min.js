! function (e, t) {
    if ("object" == typeof exports && "object" == typeof module) module.exports = t();
    else if ("function" == typeof define && define.amd) define([], t);
    else {
        var n = t();
        for (var r in n)("object" == typeof exports ? exports : e)[r] = n[r]
    }
}(self, (function () {
    return function () {
        var e = {
                847: function (e) {
                    e.exports = function (e, t) {
                        (null == t || t > e.length) && (t = e.length);
                        for (var n = 0, r = new Array(t); n < t; n++) r[n] = e[n];
                        return r
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                580: function (e) {
                    e.exports = function (e) {
                        if (Array.isArray(e)) return e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                917: function (e, t, n) {
                    var r = n(847);
                    e.exports = function (e) {
                        if (Array.isArray(e)) return r(e)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                808: function (e) {
                    e.exports = function (e) {
                        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                955: function (e) {
                    function t(e, t, n, r, i, a, o) {
                        try {
                            var s = e[a](o),
                                l = s.value
                        } catch (e) {
                            return void n(e)
                        }
                        s.done ? t(l) : Promise.resolve(l).then(r, i)
                    }
                    e.exports = function (e) {
                        return function () {
                            var n = this,
                                r = arguments;
                            return new Promise((function (i, a) {
                                var o = e.apply(n, r);

                                function s(e) {
                                    t(o, i, a, s, l, "next", e)
                                }

                                function l(e) {
                                    t(o, i, a, s, l, "throw", e)
                                }
                                s(void 0)
                            }))
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                571: function (e) {
                    e.exports = function (e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                629: function (e, t, n) {
                    var r = n(175),
                        i = n(663);

                    function a(t, n, o) {
                        return i() ? (e.exports = a = Reflect.construct.bind(), e.exports.__esModule = !0, e.exports.default = e.exports) : (e.exports = a = function (e, t, n) {
                            var i = [null];
                            i.push.apply(i, t);
                            var a = new(Function.bind.apply(e, i));
                            return n && r(a, n.prototype), a
                        }, e.exports.__esModule = !0, e.exports.default = e.exports), a.apply(null, arguments)
                    }
                    e.exports = a, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                159: function (e, t, n) {
                    var r = n(718);

                    function i(e, t) {
                        for (var n = 0; n < t.length; n++) {
                            var i = t[n];
                            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, r(i.key), i)
                        }
                    }
                    e.exports = function (e, t, n) {
                        return t && i(e.prototype, t), n && i(e, n), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                66: function (e, t, n) {
                    var r = n(455);
                    e.exports = function (e, t) {
                        var n = "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (!n) {
                            if (Array.isArray(e) || (n = r(e)) || t && e && "number" == typeof e.length) {
                                n && (e = n);
                                var i = 0,
                                    a = function () {};
                                return {
                                    s: a,
                                    n: function () {
                                        return i >= e.length ? {
                                            done: !0
                                        } : {
                                            done: !1,
                                            value: e[i++]
                                        }
                                    },
                                    e: function (e) {
                                        throw e
                                    },
                                    f: a
                                }
                            }
                            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                        }
                        var o, s = !0,
                            l = !1;
                        return {
                            s: function () {
                                n = n.call(e)
                            },
                            n: function () {
                                var e = n.next();
                                return s = e.done, e
                            },
                            e: function (e) {
                                l = !0, o = e
                            },
                            f: function () {
                                try {
                                    s || null == n.return || n.return()
                                } finally {
                                    if (l) throw o
                                }
                            }
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                230: function (e, t, n) {
                    var r = n(641),
                        i = n(663),
                        a = n(675);
                    e.exports = function (e) {
                        var t = i();
                        return function () {
                            var n, i = r(e);
                            if (t) {
                                var o = r(this).constructor;
                                n = Reflect.construct(i, arguments, o)
                            } else n = i.apply(this, arguments);
                            return a(this, n)
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                739: function (e, t, n) {
                    var r = n(718);
                    e.exports = function (e, t, n) {
                        return (t = r(t)) in e ? Object.defineProperty(e, t, {
                            value: n,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : e[t] = n, e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                266: function (e, t, n) {
                    var r = n(683);

                    function i() {
                        return "undefined" != typeof Reflect && Reflect.get ? (e.exports = i = Reflect.get.bind(), e.exports.__esModule = !0, e.exports.default = e.exports) : (e.exports = i = function (e, t, n) {
                            var i = r(e, t);
                            if (i) {
                                var a = Object.getOwnPropertyDescriptor(i, t);
                                return a.get ? a.get.call(arguments.length < 3 ? e : n) : a.value
                            }
                        }, e.exports.__esModule = !0, e.exports.default = e.exports), i.apply(this, arguments)
                    }
                    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                641: function (e) {
                    function t(n) {
                        return e.exports = t = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (e) {
                            return e.__proto__ || Object.getPrototypeOf(e)
                        }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n)
                    }
                    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                977: function (e, t, n) {
                    var r = n(175);
                    e.exports = function (e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                writable: !0,
                                configurable: !0
                            }
                        }), Object.defineProperty(e, "prototype", {
                            writable: !1
                        }), t && r(e, t)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                417: function (e) {
                    e.exports = function (e) {
                        return -1 !== Function.toString.call(e).indexOf("[native code]")
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                663: function (e) {
                    e.exports = function () {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function () {}))), !0
                        } catch (e) {
                            return !1
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                44: function (e) {
                    e.exports = function (e) {
                        if ("undefined" != typeof Symbol && null != e[Symbol.iterator] || null != e["@@iterator"]) return Array.from(e)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                343: function (e) {
                    e.exports = function (e, t) {
                        var n = null == e ? null : "undefined" != typeof Symbol && e[Symbol.iterator] || e["@@iterator"];
                        if (null != n) {
                            var r, i, a, o, s = [],
                                l = !0,
                                u = !1;
                            try {
                                if (a = (n = n.call(e)).next, 0 === t) {
                                    if (Object(n) !== n) return;
                                    l = !1
                                } else
                                    for (; !(l = (r = a.call(n)).done) && (s.push(r.value), s.length !== t); l = !0);
                            } catch (e) {
                                u = !0, i = e
                            } finally {
                                try {
                                    if (!l && null != n.return && (o = n.return(), Object(o) !== o)) return
                                } finally {
                                    if (u) throw i
                                }
                            }
                            return s
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                300: function (e) {
                    e.exports = function () {
                        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                155: function (e) {
                    e.exports = function () {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                675: function (e, t, n) {
                    var r = n(444).default,
                        i = n(808);
                    e.exports = function (e, t) {
                        if (t && ("object" === r(t) || "function" == typeof t)) return t;
                        if (void 0 !== t) throw new TypeError("Derived constructors may only return object or undefined");
                        return i(e)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                391: function (e, t, n) {
                    var r = n(444).default;

                    function i() {
                        "use strict";
                        e.exports = i = function () {
                            return t
                        }, e.exports.__esModule = !0, e.exports.default = e.exports;
                        var t = {},
                            n = Object.prototype,
                            a = n.hasOwnProperty,
                            o = Object.defineProperty || function (e, t, n) {
                                e[t] = n.value
                            },
                            s = "function" == typeof Symbol ? Symbol : {},
                            l = s.iterator || "@@iterator",
                            u = s.asyncIterator || "@@asyncIterator",
                            c = s.toStringTag || "@@toStringTag";

                        function h(e, t, n) {
                            return Object.defineProperty(e, t, {
                                value: n,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }), e[t]
                        }
                        try {
                            h({}, "")
                        } catch (e) {
                            h = function (e, t, n) {
                                return e[t] = n
                            }
                        }

                        function d(e, t, n, r) {
                            var i = t && t.prototype instanceof m ? t : m,
                                a = Object.create(i.prototype),
                                s = new R(r || []);
                            return o(a, "_invoke", {
                                value: T(e, n, s)
                            }), a
                        }

                        function f(e, t, n) {
                            try {
                                return {
                                    type: "normal",
                                    arg: e.call(t, n)
                                }
                            } catch (e) {
                                return {
                                    type: "throw",
                                    arg: e
                                }
                            }
                        }
                        t.wrap = d;
                        var p = {};

                        function m() {}

                        function v() {}

                        function g() {}
                        var _ = {};
                        h(_, l, (function () {
                            return this
                        }));
                        var y = Object.getPrototypeOf,
                            x = y && y(y(C([])));
                        x && x !== n && a.call(x, l) && (_ = x);
                        var M = g.prototype = m.prototype = Object.create(_);

                        function S(e) {
                            ["next", "throw", "return"].forEach((function (t) {
                                h(e, t, (function (e) {
                                    return this._invoke(t, e)
                                }))
                            }))
                        }

                        function E(e, t) {
                            function n(i, o, s, l) {
                                var u = f(e[i], e, o);
                                if ("throw" !== u.type) {
                                    var c = u.arg,
                                        h = c.value;
                                    return h && "object" == r(h) && a.call(h, "__await") ? t.resolve(h.__await).then((function (e) {
                                        n("next", e, s, l)
                                    }), (function (e) {
                                        n("throw", e, s, l)
                                    })) : t.resolve(h).then((function (e) {
                                        c.value = e, s(c)
                                    }), (function (e) {
                                        return n("throw", e, s, l)
                                    }))
                                }
                                l(u.arg)
                            }
                            var i;
                            o(this, "_invoke", {
                                value: function (e, r) {
                                    function a() {
                                        return new t((function (t, i) {
                                            n(e, r, t, i)
                                        }))
                                    }
                                    return i = i ? i.then(a, a) : a()
                                }
                            })
                        }

                        function T(e, t, n) {
                            var r = "suspendedStart";
                            return function (i, a) {
                                if ("executing" === r) throw new Error("Generator is already running");
                                if ("completed" === r) {
                                    if ("throw" === i) throw a;
                                    return L()
                                }
                                for (n.method = i, n.arg = a;;) {
                                    var o = n.delegate;
                                    if (o) {
                                        var s = b(o, n);
                                        if (s) {
                                            if (s === p) continue;
                                            return s
                                        }
                                    }
                                    if ("next" === n.method) n.sent = n._sent = n.arg;
                                    else if ("throw" === n.method) {
                                        if ("suspendedStart" === r) throw r = "completed", n.arg;
                                        n.dispatchException(n.arg)
                                    } else "return" === n.method && n.abrupt("return", n.arg);
                                    r = "executing";
                                    var l = f(e, t, n);
                                    if ("normal" === l.type) {
                                        if (r = n.done ? "completed" : "suspendedYield", l.arg === p) continue;
                                        return {
                                            value: l.arg,
                                            done: n.done
                                        }
                                    }
                                    "throw" === l.type && (r = "completed", n.method = "throw", n.arg = l.arg)
                                }
                            }
                        }

                        function b(e, t) {
                            var n = t.method,
                                r = e.iterator[n];
                            if (void 0 === r) return t.delegate = null, "throw" === n && e.iterator.return && (t.method = "return", t.arg = void 0, b(e, t), "throw" === t.method) || "return" !== n && (t.method = "throw", t.arg = new TypeError("The iterator does not provide a '" + n + "' method")), p;
                            var i = f(r, e.iterator, t.arg);
                            if ("throw" === i.type) return t.method = "throw", t.arg = i.arg, t.delegate = null, p;
                            var a = i.arg;
                            return a ? a.done ? (t[e.resultName] = a.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = void 0), t.delegate = null, p) : a : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, p)
                        }

                        function A(e) {
                            var t = {
                                tryLoc: e[0]
                            };
                            1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t)
                        }

                        function w(e) {
                            var t = e.completion || {};
                            t.type = "normal", delete t.arg, e.completion = t
                        }

                        function R(e) {
                            this.tryEntries = [{
                                tryLoc: "root"
                            }], e.forEach(A, this), this.reset(!0)
                        }

                        function C(e) {
                            if (e) {
                                var t = e[l];
                                if (t) return t.call(e);
                                if ("function" == typeof e.next) return e;
                                if (!isNaN(e.length)) {
                                    var n = -1,
                                        r = function t() {
                                            for (; ++n < e.length;)
                                                if (a.call(e, n)) return t.value = e[n], t.done = !1, t;
                                            return t.value = void 0, t.done = !0, t
                                        };
                                    return r.next = r
                                }
                            }
                            return {
                                next: L
                            }
                        }

                        function L() {
                            return {
                                value: void 0,
                                done: !0
                            }
                        }
                        return v.prototype = g, o(M, "constructor", {
                            value: g,
                            configurable: !0
                        }), o(g, "constructor", {
                            value: v,
                            configurable: !0
                        }), v.displayName = h(g, c, "GeneratorFunction"), t.isGeneratorFunction = function (e) {
                            var t = "function" == typeof e && e.constructor;
                            return !!t && (t === v || "GeneratorFunction" === (t.displayName || t.name))
                        }, t.mark = function (e) {
                            return Object.setPrototypeOf ? Object.setPrototypeOf(e, g) : (e.__proto__ = g, h(e, c, "GeneratorFunction")), e.prototype = Object.create(M), e
                        }, t.awrap = function (e) {
                            return {
                                __await: e
                            }
                        }, S(E.prototype), h(E.prototype, u, (function () {
                            return this
                        })), t.AsyncIterator = E, t.async = function (e, n, r, i, a) {
                            void 0 === a && (a = Promise);
                            var o = new E(d(e, n, r, i), a);
                            return t.isGeneratorFunction(n) ? o : o.next().then((function (e) {
                                return e.done ? e.value : o.next()
                            }))
                        }, S(M), h(M, c, "Generator"), h(M, l, (function () {
                            return this
                        })), h(M, "toString", (function () {
                            return "[object Generator]"
                        })), t.keys = function (e) {
                            var t = Object(e),
                                n = [];
                            for (var r in t) n.push(r);
                            return n.reverse(),
                                function e() {
                                    for (; n.length;) {
                                        var r = n.pop();
                                        if (r in t) return e.value = r, e.done = !1, e
                                    }
                                    return e.done = !0, e
                                }
                        }, t.values = C, R.prototype = {
                            constructor: R,
                            reset: function (e) {
                                if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(w), !e)
                                    for (var t in this) "t" === t.charAt(0) && a.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = void 0)
                            },
                            stop: function () {
                                this.done = !0;
                                var e = this.tryEntries[0].completion;
                                if ("throw" === e.type) throw e.arg;
                                return this.rval
                            },
                            dispatchException: function (e) {
                                if (this.done) throw e;
                                var t = this;

                                function n(n, r) {
                                    return o.type = "throw", o.arg = e, t.next = n, r && (t.method = "next", t.arg = void 0), !!r
                                }
                                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                    var i = this.tryEntries[r],
                                        o = i.completion;
                                    if ("root" === i.tryLoc) return n("end");
                                    if (i.tryLoc <= this.prev) {
                                        var s = a.call(i, "catchLoc"),
                                            l = a.call(i, "finallyLoc");
                                        if (s && l) {
                                            if (this.prev < i.catchLoc) return n(i.catchLoc, !0);
                                            if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                        } else if (s) {
                                            if (this.prev < i.catchLoc) return n(i.catchLoc, !0)
                                        } else {
                                            if (!l) throw new Error("try statement without catch or finally");
                                            if (this.prev < i.finallyLoc) return n(i.finallyLoc)
                                        }
                                    }
                                }
                            },
                            abrupt: function (e, t) {
                                for (var n = this.tryEntries.length - 1; n >= 0; --n) {
                                    var r = this.tryEntries[n];
                                    if (r.tryLoc <= this.prev && a.call(r, "finallyLoc") && this.prev < r.finallyLoc) {
                                        var i = r;
                                        break
                                    }
                                }
                                i && ("break" === e || "continue" === e) && i.tryLoc <= t && t <= i.finallyLoc && (i = null);
                                var o = i ? i.completion : {};
                                return o.type = e, o.arg = t, i ? (this.method = "next", this.next = i.finallyLoc, p) : this.complete(o)
                            },
                            complete: function (e, t) {
                                if ("throw" === e.type) throw e.arg;
                                return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), p
                            },
                            finish: function (e) {
                                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                    var n = this.tryEntries[t];
                                    if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), w(n), p
                                }
                            },
                            catch: function (e) {
                                for (var t = this.tryEntries.length - 1; t >= 0; --t) {
                                    var n = this.tryEntries[t];
                                    if (n.tryLoc === e) {
                                        var r = n.completion;
                                        if ("throw" === r.type) {
                                            var i = r.arg;
                                            w(n)
                                        }
                                        return i
                                    }
                                }
                                throw new Error("illegal catch attempt")
                            },
                            delegateYield: function (e, t, n) {
                                return this.delegate = {
                                    iterator: C(e),
                                    resultName: t,
                                    nextLoc: n
                                }, "next" === this.method && (this.arg = void 0), p
                            }
                        }, t
                    }
                    e.exports = i, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                175: function (e) {
                    function t(n, r) {
                        return e.exports = t = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (e, t) {
                            return e.__proto__ = t, e
                        }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n, r)
                    }
                    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                143: function (e, t, n) {
                    var r = n(580),
                        i = n(343),
                        a = n(455),
                        o = n(300);
                    e.exports = function (e, t) {
                        return r(e) || i(e, t) || a(e, t) || o()
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                683: function (e, t, n) {
                    var r = n(641);
                    e.exports = function (e, t) {
                        for (; !Object.prototype.hasOwnProperty.call(e, t) && null !== (e = r(e)););
                        return e
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                587: function (e, t, n) {
                    var r = n(917),
                        i = n(44),
                        a = n(455),
                        o = n(155);
                    e.exports = function (e) {
                        return r(e) || i(e) || a(e) || o()
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                386: function (e, t, n) {
                    var r = n(444).default;
                    e.exports = function (e, t) {
                        if ("object" !== r(e) || null === e) return e;
                        var n = e[Symbol.toPrimitive];
                        if (void 0 !== n) {
                            var i = n.call(e, t || "default");
                            if ("object" !== r(i)) return i;
                            throw new TypeError("@@toPrimitive must return a primitive value.")
                        }
                        return ("string" === t ? String : Number)(e)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                718: function (e, t, n) {
                    var r = n(444).default,
                        i = n(386);
                    e.exports = function (e) {
                        var t = i(e, "string");
                        return "symbol" === r(t) ? t : String(t)
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                444: function (e) {
                    function t(n) {
                        return e.exports = t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
                            return typeof e
                        } : function (e) {
                            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                        }, e.exports.__esModule = !0, e.exports.default = e.exports, t(n)
                    }
                    e.exports = t, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                455: function (e, t, n) {
                    var r = n(847);
                    e.exports = function (e, t) {
                        if (e) {
                            if ("string" == typeof e) return r(e, t);
                            var n = Object.prototype.toString.call(e).slice(8, -1);
                            return "Object" === n && e.constructor && (n = e.constructor.name), "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? r(e, t) : void 0
                        }
                    }, e.exports.__esModule = !0, e.exports.default = e.exports
                },
                836: function (e, t, n) {
                    var r = n(641),
                        i = n(175),
                        a = n(417),
                        o = n(629);

                    function s(t) {
                        var n = "function" == typeof Map ? new Map : void 0;
                        return e.exports = s = function (e) {
                            if (null === e || !a(e)) return e;
                            if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
                            if (void 0 !== n) {
                                if (n.has(e)) return n.get(e);
                                n.set(e, t)
                            }

                            function t() {
                                return o(e, arguments, r(this).constructor)
                            }
                            return t.prototype = Object.create(e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), i(t, e)
                        }, e.exports.__esModule = !0, e.exports.default = e.exports, s(t)
                    }
                    e.exports = s, e.exports.__esModule = !0, e.exports.default = e.exports
                }
            },
            t = {};

        function n(r) {
            var i = t[r];
            if (void 0 !== i) return i.exports;
            var a = t[r] = {
                exports: {}
            };
            return e[r](a, a.exports, n), a.exports
        }
        n.n = function (e) {
            var t = e && e.__esModule ? function () {
                return e.default
            } : function () {
                return e
            };
            return n.d(t, {
                a: t
            }), t
        }, n.d = function (e, t) {
            for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, {
                enumerable: !0,
                get: t[r]
            })
        }, n.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
        }, n.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(e, "__esModule", {
                value: !0
            })
        };
        var r = {};
        return function () {
            "use strict";
            n.r(r), n.d(r, {
                Anov3DMesh: function () {
                    return Ru
                },
                Anov3DModelLoader: function () {
                    return Cc
                },
                Anov3DPerspectiveCamera: function () {
                    return bu
                },
                Anove3DScene: function () {
                    return Au
                },
                Direction: function () {
                    return ru
                },
                ModelType: function () {
                    return Rc
                },
                utils: function () {
                    return Lc
                }
            });
            var e, t, i = n(571),
                a = n.n(i),
                o = n(159),
                s = n.n(o),
                l = n(739),
                u = n.n(l),
                c = n(836),
                h = n(587),
                d = n.n(h),
                f = n(955),
                p = n(66),
                m = n(143),
                v = n.n(m),
                g = n(266),
                _ = n.n(g),
                y = n(641),
                x = n.n(y),
                M = n(808),
                S = n.n(M),
                E = n(977),
                T = n.n(E),
                b = n(230),
                A = n.n(b),
                w = n(391),
                R = "155",
                C = 0,
                L = 1,
                P = 2,
                k = 0,
                I = 1,
                U = 2,
                D = 3,
                N = 100,
                O = 301,
                F = 302,
                B = 303,
                z = 304,
                H = 306,
                G = 1e3,
                V = 1001,
                W = 1002,
                j = 1003,
                X = 1004,
                q = 1005,
                Y = 1006,
                K = 1007,
                Z = 1008,
                J = 1009,
                Q = 1012,
                $ = 1013,
                ee = 1014,
                te = 1015,
                ne = 1016,
                re = 1017,
                ie = 1018,
                ae = 1020,
                oe = 1023,
                se = 1026,
                le = 1027,
                ue = 1029,
                ce = 1031,
                he = 1033,
                de = 33776,
                fe = 33777,
                pe = 33778,
                me = 33779,
                ve = 35840,
                ge = 35841,
                _e = 35842,
                ye = 35843,
                xe = 37492,
                Me = 37496,
                Se = 37808,
                Ee = 37809,
                Te = 37810,
                be = 37811,
                Ae = 37812,
                we = 37813,
                Re = 37814,
                Ce = 37815,
                Le = 37816,
                Pe = 37817,
                ke = 37818,
                Ie = 37819,
                Ue = 37820,
                De = 37821,
                Ne = 36492,
                Oe = 36284,
                Fe = 36285,
                Be = 36286,
                ze = 2300,
                He = 2301,
                Ge = 2302,
                Ve = 2400,
                We = 2401,
                je = 2402,
                Xe = 2500,
                qe = 3001,
                Ye = "",
                Ke = "srgb",
                Ze = "srgb-linear",
                Je = "display-p3",
                Qe = 7680,
                $e = 35044,
                et = "300 es",
                tt = 1035,
                nt = 2e3,
                rt = 2001,
                it = function () {
                    function e() {
                        i(this, e)
                    }
                    return o(e, [{
                        key: "addEventListener",
                        value: function (e, t) {
                            void 0 === this._listeners && (this._listeners = {});
                            var n = this._listeners;
                            void 0 === n[e] && (n[e] = []), -1 === n[e].indexOf(t) && n[e].push(t)
                        }
                    }, {
                        key: "hasEventListener",
                        value: function (e, t) {
                            if (void 0 === this._listeners) return !1;
                            var n = this._listeners;
                            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
                        }
                    }, {
                        key: "removeEventListener",
                        value: function (e, t) {
                            if (void 0 !== this._listeners) {
                                var n = this._listeners[e];
                                if (void 0 !== n) {
                                    var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
                                }
                            }
                        }
                    }, {
                        key: "dispatchEvent",
                        value: function (e) {
                            if (void 0 !== this._listeners) {
                                var t = this._listeners[e.type];
                                if (void 0 !== t) {
                                    e.target = this;
                                    for (var n = t.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, e);
                                    e.target = null
                                }
                            }
                        }
                    }]), e
                }(),
                at = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"],
                ot = 1234567,
                st = Math.PI / 180,
                lt = 180 / Math.PI;

            function ut() {
                var e = 4294967295 * Math.random() | 0,
                    t = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0,
                    r = 4294967295 * Math.random() | 0;
                return (at[255 & e] + at[e >> 8 & 255] + at[e >> 16 & 255] + at[e >> 24 & 255] + "-" + at[255 & t] + at[t >> 8 & 255] + "-" + at[t >> 16 & 15 | 64] + at[t >> 24 & 255] + "-" + at[63 & n | 128] + at[n >> 8 & 255] + "-" + at[n >> 16 & 255] + at[n >> 24 & 255] + at[255 & r] + at[r >> 8 & 255] + at[r >> 16 & 255] + at[r >> 24 & 255]).toLowerCase()
            }

            function ct(e, t, n) {
                return Math.max(t, Math.min(n, e))
            }

            function ht(e, t) {
                return (e % t + t) % t
            }

            function dt(e, t, n) {
                return (1 - n) * e + n * t
            }

            function ft(e) {
                return 0 == (e & e - 1) && 0 !== e
            }

            function pt(e) {
                return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
            }

            function mt(e) {
                return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
            }

            function vt(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return e / 4294967295;
                    case Uint16Array:
                        return e / 65535;
                    case Uint8Array:
                        return e / 255;
                    case Int32Array:
                        return Math.max(e / 2147483647, -1);
                    case Int16Array:
                        return Math.max(e / 32767, -1);
                    case Int8Array:
                        return Math.max(e / 127, -1);
                    default:
                        throw new Error("Invalid component type.")
                }
            }

            function gt(e, t) {
                switch (t.constructor) {
                    case Float32Array:
                        return e;
                    case Uint32Array:
                        return Math.round(4294967295 * e);
                    case Uint16Array:
                        return Math.round(65535 * e);
                    case Uint8Array:
                        return Math.round(255 * e);
                    case Int32Array:
                        return Math.round(2147483647 * e);
                    case Int16Array:
                        return Math.round(32767 * e);
                    case Int8Array:
                        return Math.round(127 * e);
                    default:
                        throw new Error("Invalid component type.")
                }
            }
            var _t = {
                    DEG2RAD: st,
                    RAD2DEG: lt,
                    generateUUID: ut,
                    clamp: ct,
                    euclideanModulo: ht,
                    mapLinear: function (e, t, n, r, i) {
                        return r + (e - t) * (i - r) / (n - t)
                    },
                    inverseLerp: function (e, t, n) {
                        return e !== t ? (n - e) / (t - e) : 0
                    },
                    lerp: dt,
                    damp: function (e, t, n, r) {
                        return dt(e, t, 1 - Math.exp(-n * r))
                    },
                    pingpong: function (e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return t - Math.abs(ht(e, 2 * t) - t)
                    },
                    smoothstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
                    },
                    smootherstep: function (e, t, n) {
                        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
                    },
                    randInt: function (e, t) {
                        return e + Math.floor(Math.random() * (t - e + 1))
                    },
                    randFloat: function (e, t) {
                        return e + Math.random() * (t - e)
                    },
                    randFloatSpread: function (e) {
                        return e * (.5 - Math.random())
                    },
                    seededRandom: function (e) {
                        void 0 !== e && (ot = e);
                        var t = ot += 1831565813;
                        return t = Math.imul(t ^ t >>> 15, 1 | t), (((t ^= t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t >>> 14) >>> 0) / 4294967296
                    },
                    degToRad: function (e) {
                        return e * st
                    },
                    radToDeg: function (e) {
                        return e * lt
                    },
                    isPowerOfTwo: ft,
                    ceilPowerOfTwo: pt,
                    floorPowerOfTwo: mt,
                    setQuaternionFromProperEuler: function (e, t, n, r, i) {
                        var a = Math.cos,
                            o = Math.sin,
                            s = a(n / 2),
                            l = o(n / 2),
                            u = a((t + r) / 2),
                            c = o((t + r) / 2),
                            h = a((t - r) / 2),
                            d = o((t - r) / 2),
                            f = a((r - t) / 2),
                            p = o((r - t) / 2);
                        switch (i) {
                            case "XYX":
                                e.set(s * c, l * h, l * d, s * u);
                                break;
                            case "YZY":
                                e.set(l * d, s * c, l * h, s * u);
                                break;
                            case "ZXZ":
                                e.set(l * h, l * d, s * c, s * u);
                                break;
                            case "XZX":
                                e.set(s * c, l * p, l * f, s * u);
                                break;
                            case "YXY":
                                e.set(l * f, s * c, l * p, s * u);
                                break;
                            case "ZYZ":
                                e.set(l * p, l * f, s * c, s * u);
                                break;
                            default:
                                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
                        }
                    },
                    normalize: gt,
                    denormalize: vt
                },
                yt = function (e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        i(this, t), t.prototype.isVector2 = !0, this.x = e, this.y = n
                    }
                    return o(t, [{
                        key: "width",
                        get: function () {
                            return this.x
                        },
                        set: function (e) {
                            this.x = e
                        }
                    }, {
                        key: "height",
                        get: function () {
                            return this.y
                        },
                        set: function (e) {
                            this.y = e
                        }
                    }, {
                        key: "set",
                        value: function (e, t) {
                            return this.x = e, this.y = t, this
                        }
                    }, {
                        key: "setScalar",
                        value: function (e) {
                            return this.x = e, this.y = e, this
                        }
                    }, {
                        key: "setX",
                        value: function (e) {
                            return this.x = e, this
                        }
                    }, {
                        key: "setY",
                        value: function (e) {
                            return this.y = e, this
                        }
                    }, {
                        key: "setComponent",
                        value: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                    }, {
                        key: "getComponent",
                        value: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this.x, this.y)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.x = e.x, this.y = e.y, this
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            return this.x += e.x, this.y += e.y, this
                        }
                    }, {
                        key: "addScalar",
                        value: function (e) {
                            return this.x += e, this.y += e, this
                        }
                    }, {
                        key: "addVectors",
                        value: function (e, t) {
                            return this.x = e.x + t.x, this.y = e.y + t.y, this
                        }
                    }, {
                        key: "addScaledVector",
                        value: function (e, t) {
                            return this.x += e.x * t, this.y += e.y * t, this
                        }
                    }, {
                        key: "sub",
                        value: function (e) {
                            return this.x -= e.x, this.y -= e.y, this
                        }
                    }, {
                        key: "subScalar",
                        value: function (e) {
                            return this.x -= e, this.y -= e, this
                        }
                    }, {
                        key: "subVectors",
                        value: function (e, t) {
                            return this.x = e.x - t.x, this.y = e.y - t.y, this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.x *= e.x, this.y *= e.y, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            return this.x *= e, this.y *= e, this
                        }
                    }, {
                        key: "divide",
                        value: function (e) {
                            return this.x /= e.x, this.y /= e.y, this
                        }
                    }, {
                        key: "divideScalar",
                        value: function (e) {
                            return this.multiplyScalar(1 / e)
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = e.elements;
                            return this.x = r[0] * t + r[3] * n + r[6], this.y = r[1] * t + r[4] * n + r[7], this
                        }
                    }, {
                        key: "min",
                        value: function (e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                        }
                    }, {
                        key: "max",
                        value: function (e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                        }
                    }, {
                        key: "clamp",
                        value: function (e, t) {
                            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                        }
                    }, {
                        key: "clampScalar",
                        value: function (e, t) {
                            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
                        }
                    }, {
                        key: "clampLength",
                        value: function (e, t) {
                            var n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                        }
                    }, {
                        key: "floor",
                        value: function () {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                        }
                    }, {
                        key: "ceil",
                        value: function () {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                        }
                    }, {
                        key: "round",
                        value: function () {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                        }
                    }, {
                        key: "roundToZero",
                        value: function () {
                            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                        }
                    }, {
                        key: "negate",
                        value: function () {
                            return this.x = -this.x, this.y = -this.y, this
                        }
                    }, {
                        key: "dot",
                        value: function (e) {
                            return this.x * e.x + this.y * e.y
                        }
                    }, {
                        key: "cross",
                        value: function (e) {
                            return this.x * e.y - this.y * e.x
                        }
                    }, {
                        key: "lengthSq",
                        value: function () {
                            return this.x * this.x + this.y * this.y
                        }
                    }, {
                        key: "length",
                        value: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        }
                    }, {
                        key: "manhattanLength",
                        value: function () {
                            return Math.abs(this.x) + Math.abs(this.y)
                        }
                    }, {
                        key: "normalize",
                        value: function () {
                            return this.divideScalar(this.length() || 1)
                        }
                    }, {
                        key: "angle",
                        value: function () {
                            var e = Math.atan2(-this.y, -this.x) + Math.PI;
                            return e
                        }
                    }, {
                        key: "angleTo",
                        value: function (e) {
                            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (0 === t) return Math.PI / 2;
                            var n = this.dot(e) / t;
                            return Math.acos(ct(n, -1, 1))
                        }
                    }, {
                        key: "distanceTo",
                        value: function (e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }
                    }, {
                        key: "distanceToSquared",
                        value: function (e) {
                            var t = this.x - e.x,
                                n = this.y - e.y;
                            return t * t + n * n
                        }
                    }, {
                        key: "manhattanDistanceTo",
                        value: function (e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
                        }
                    }, {
                        key: "setLength",
                        value: function (e) {
                            return this.normalize().multiplyScalar(e)
                        }
                    }, {
                        key: "lerp",
                        value: function (e, t) {
                            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                        }
                    }, {
                        key: "lerpVectors",
                        value: function (e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.x === this.x && e.y === this.y
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.x = e[t], this.y = e[t + 1], this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this.x, e[t + 1] = this.y, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function (e, t) {
                            return this.x = e.getX(t), this.y = e.getY(t), this
                        }
                    }, {
                        key: "rotateAround",
                        value: function (e, t) {
                            var n = Math.cos(t),
                                r = Math.sin(t),
                                i = this.x - e.x,
                                a = this.y - e.y;
                            return this.x = i * n - a * r + e.x, this.y = i * r + a * n + e.y, this
                        }
                    }, {
                        key: "random",
                        value: function () {
                            return this.x = Math.random(), this.y = Math.random(), this
                        }
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this.x;
                                    case 2:
                                        return e.next = 4, this.y;
                                    case 4:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }]), t
                }(Symbol.iterator),
                xt = function () {
                    function e(t, n, r, a, o, s, l, u, c) {
                        i(this, e), e.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], void 0 !== t && this.set(t, n, r, a, o, s, l, u, c)
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t, n, r, i, a, o, s, l) {
                            var u = this.elements;
                            return u[0] = e, u[1] = r, u[2] = o, u[3] = t, u[4] = i, u[5] = s, u[6] = n, u[7] = a, u[8] = l, this
                        }
                    }, {
                        key: "identity",
                        value: function () {
                            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            var t = this.elements,
                                n = e.elements;
                            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
                        }
                    }, {
                        key: "extractBasis",
                        value: function (e, t, n) {
                            return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
                        }
                    }, {
                        key: "setFromMatrix4",
                        value: function (e) {
                            var t = e.elements;
                            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.multiplyMatrices(this, e)
                        }
                    }, {
                        key: "premultiply",
                        value: function (e) {
                            return this.multiplyMatrices(e, this)
                        }
                    }, {
                        key: "multiplyMatrices",
                        value: function (e, t) {
                            var n = e.elements,
                                r = t.elements,
                                i = this.elements,
                                a = n[0],
                                o = n[3],
                                s = n[6],
                                l = n[1],
                                u = n[4],
                                c = n[7],
                                h = n[2],
                                d = n[5],
                                f = n[8],
                                p = r[0],
                                m = r[3],
                                v = r[6],
                                g = r[1],
                                _ = r[4],
                                y = r[7],
                                x = r[2],
                                M = r[5],
                                S = r[8];
                            return i[0] = a * p + o * g + s * x, i[3] = a * m + o * _ + s * M, i[6] = a * v + o * y + s * S, i[1] = l * p + u * g + c * x, i[4] = l * m + u * _ + c * M, i[7] = l * v + u * y + c * S, i[2] = h * p + d * g + f * x, i[5] = h * m + d * _ + f * M, i[8] = h * v + d * y + f * S, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            var t = this.elements;
                            return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                        }
                    }, {
                        key: "determinant",
                        value: function () {
                            var e = this.elements,
                                t = e[0],
                                n = e[1],
                                r = e[2],
                                i = e[3],
                                a = e[4],
                                o = e[5],
                                s = e[6],
                                l = e[7],
                                u = e[8];
                            return t * a * u - t * o * l - n * i * u + n * o * s + r * i * l - r * a * s
                        }
                    }, {
                        key: "invert",
                        value: function () {
                            var e = this.elements,
                                t = e[0],
                                n = e[1],
                                r = e[2],
                                i = e[3],
                                a = e[4],
                                o = e[5],
                                s = e[6],
                                l = e[7],
                                u = e[8],
                                c = u * a - o * l,
                                h = o * s - u * i,
                                d = l * i - a * s,
                                f = t * c + n * h + r * d;
                            if (0 === f) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                            var p = 1 / f;
                            return e[0] = c * p, e[1] = (r * l - u * n) * p, e[2] = (o * n - r * a) * p, e[3] = h * p, e[4] = (u * t - r * s) * p, e[5] = (r * i - o * t) * p, e[6] = d * p, e[7] = (n * s - l * t) * p, e[8] = (a * t - n * i) * p, this
                        }
                    }, {
                        key: "transpose",
                        value: function () {
                            var e, t = this.elements;
                            return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                        }
                    }, {
                        key: "getNormalMatrix",
                        value: function (e) {
                            return this.setFromMatrix4(e).invert().transpose()
                        }
                    }, {
                        key: "transposeIntoArray",
                        value: function (e) {
                            var t = this.elements;
                            return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                        }
                    }, {
                        key: "setUvTransform",
                        value: function (e, t, n, r, i, a, o) {
                            var s = Math.cos(i),
                                l = Math.sin(i);
                            return this.set(n * s, n * l, -n * (s * a + l * o) + a + e, -r * l, r * s, -r * (-l * a + s * o) + o + t, 0, 0, 1), this
                        }
                    }, {
                        key: "scale",
                        value: function (e, t) {
                            return this.premultiply(Mt.makeScale(e, t)), this
                        }
                    }, {
                        key: "rotate",
                        value: function (e) {
                            return this.premultiply(Mt.makeRotation(-e)), this
                        }
                    }, {
                        key: "translate",
                        value: function (e, t) {
                            return this.premultiply(Mt.makeTranslation(e, t)), this
                        }
                    }, {
                        key: "makeTranslation",
                        value: function (e, t) {
                            return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotation",
                        value: function (e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeScale",
                        value: function (e, t) {
                            return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            for (var t = this.elements, n = e.elements, r = 0; r < 9; r++)
                                if (t[r] !== n[r]) return !1;
                            return !0
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 9; n++) this.elements[n] = e[n + t];
                            return this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = this.elements;
                            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).fromArray(this.elements)
                        }
                    }]), e
                }(),
                Mt = new xt;

            function St(e) {
                for (var t = e.length - 1; t >= 0; --t)
                    if (e[t] >= 65535) return !0;
                return !1
            }
            Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

            function Et(e) {
                return document.createElementNS("http://www.w3.org/1999/xhtml", e)
            }
            var Tt = {};

            function bt(e) {
                e in Tt || (Tt[e] = !0, console.warn(e))
            }

            function At(e) {
                return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
            }

            function wt(e) {
                return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
            }
            var Rt = (new xt).fromArray([.8224621, .0331941, .0170827, .177538, .9668058, .0723974, -1e-7, 1e-7, .9105199]),
                Ct = (new xt).fromArray([1.2249401, -.0420569, -.0196376, -.2249404, 1.0420571, -.0786361, 1e-7, 0, 1.0982735]);
            var Lt, Pt = (l(e = {}, Ze, (function (e) {
                    return e
                })), l(e, Ke, (function (e) {
                    return e.convertSRGBToLinear()
                })), l(e, Je, (function (e) {
                    return e.convertSRGBToLinear().applyMatrix3(Ct)
                })), e),
                kt = (l(t = {}, Ze, (function (e) {
                    return e
                })), l(t, Ke, (function (e) {
                    return e.convertLinearToSRGB()
                })), l(t, Je, (function (e) {
                    return e.applyMatrix3(Rt).convertLinearToSRGB()
                })), t),
                It = {
                    enabled: !0,
                    get legacyMode() {
                        return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), !this.enabled
                    },
                    set legacyMode(e) {
                        console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."), this.enabled = !e
                    },
                    get workingColorSpace() {
                        return Ze
                    },
                    set workingColorSpace(e) {
                        console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")
                    },
                    convert: function (e, t, n) {
                        if (!1 === this.enabled || t === n || !t || !n) return e;
                        var r = Pt[t],
                            i = kt[n];
                        if (void 0 === r || void 0 === i) throw new Error('Unsupported color space conversion, "'.concat(t, '" to "').concat(n, '".'));
                        return i(r(e))
                    },
                    fromWorkingColorSpace: function (e, t) {
                        return this.convert(e, this.workingColorSpace, t)
                    },
                    toWorkingColorSpace: function (e, t) {
                        return this.convert(e, t, this.workingColorSpace)
                    }
                },
                Ut = function () {
                    function e() {
                        i(this, e)
                    }
                    return o(e, null, [{
                        key: "getDataURL",
                        value: function (e) {
                            if (/^data:/i.test(e.src)) return e.src;
                            if ("undefined" == typeof HTMLCanvasElement) return e.src;
                            var t;
                            if (e instanceof HTMLCanvasElement) t = e;
                            else {
                                void 0 === Lt && (Lt = Et("canvas")), Lt.width = e.width, Lt.height = e.height;
                                var n = Lt.getContext("2d");
                                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Lt
                            }
                            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
                        }
                    }, {
                        key: "sRGBToLinear",
                        value: function (e) {
                            if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                                var t = Et("canvas");
                                t.width = e.width, t.height = e.height;
                                var n = t.getContext("2d");
                                n.drawImage(e, 0, 0, e.width, e.height);
                                for (var r = n.getImageData(0, 0, e.width, e.height), i = r.data, a = 0; a < i.length; a++) i[a] = 255 * At(i[a] / 255);
                                return n.putImageData(r, 0, 0), t
                            }
                            if (e.data) {
                                for (var o = e.data.slice(0), s = 0; s < o.length; s++) o instanceof Uint8Array || o instanceof Uint8ClampedArray ? o[s] = Math.floor(255 * At(o[s] / 255)) : o[s] = At(o[s]);
                                return {
                                    data: o,
                                    width: e.width,
                                    height: e.height
                                }
                            }
                            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
                        }
                    }]), e
                }(),
                Dt = 0,
                Nt = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                        i(this, e), this.isSource = !0, Object.defineProperty(this, "id", {
                            value: Dt++
                        }), this.uuid = ut(), this.data = t, this.version = 0
                    }
                    return o(e, [{
                        key: "needsUpdate",
                        set: function (e) {
                            !0 === e && this.version++
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = void 0 === e || "string" == typeof e;
                            if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
                            var n = {
                                    uuid: this.uuid,
                                    url: ""
                                },
                                r = this.data;
                            if (null !== r) {
                                var i;
                                if (Array.isArray(r)) {
                                    i = [];
                                    for (var a = 0, o = r.length; a < o; a++) r[a].isDataTexture ? i.push(Ot(r[a].image)) : i.push(Ot(r[a]))
                                } else i = Ot(r);
                                n.url = i
                            }
                            return t || (e.images[this.uuid] = n), n
                        }
                    }]), e
                }();

            function Ot(e) {
                return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? Ut.getDataURL(e) : e.data ? {
                    data: Array.from(e.data),
                    width: e.width,
                    height: e.height,
                    type: e.data.constructor.name
                } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
            }
            var Ft = 0,
                Bt = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : n.DEFAULT_IMAGE,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : n.DEFAULT_MAPPING,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : V,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : V,
                            l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Y,
                            u = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : Z,
                            c = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : oe,
                            h = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : J,
                            d = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : n.DEFAULT_ANISOTROPY,
                            f = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : Ye;
                        return i(this, n), (e = t.call(this)).isTexture = !0, Object.defineProperty(M(e), "id", {
                            value: Ft++
                        }), e.uuid = ut(), e.name = "", e.source = new Nt(r), e.mipmaps = [], e.mapping = a, e.channel = 0, e.wrapS = o, e.wrapT = s, e.magFilter = l, e.minFilter = u, e.anisotropy = d, e.format = c, e.internalFormat = null, e.type = h, e.offset = new yt(0, 0), e.repeat = new yt(1, 1), e.center = new yt(0, 0), e.rotation = 0, e.matrixAutoUpdate = !0, e.matrix = new xt, e.generateMipmaps = !0, e.premultiplyAlpha = !1, e.flipY = !0, e.unpackAlignment = 4, "string" == typeof f ? e.colorSpace = f : (bt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), e.colorSpace = f === qe ? Ke : Ye), e.userData = {}, e.version = 0, e.onUpdate = null, e.isRenderTargetTexture = !1, e.needsPMREMUpdate = !1, e
                    }
                    return o(n, [{
                        key: "image",
                        get: function () {
                            return this.source.data
                        },
                        set: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                            this.source.data = e
                        }
                    }, {
                        key: "updateMatrix",
                        value: function () {
                            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = void 0 === e || "string" == typeof e;
                            if (!t && void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                            var n = {
                                metadata: {
                                    version: 4.6,
                                    type: "Texture",
                                    generator: "Texture.toJSON"
                                },
                                uuid: this.uuid,
                                name: this.name,
                                image: this.source.toJSON(e).uuid,
                                mapping: this.mapping,
                                channel: this.channel,
                                repeat: [this.repeat.x, this.repeat.y],
                                offset: [this.offset.x, this.offset.y],
                                center: [this.center.x, this.center.y],
                                rotation: this.rotation,
                                wrap: [this.wrapS, this.wrapT],
                                format: this.format,
                                internalFormat: this.internalFormat,
                                type: this.type,
                                colorSpace: this.colorSpace,
                                minFilter: this.minFilter,
                                magFilter: this.magFilter,
                                anisotropy: this.anisotropy,
                                flipY: this.flipY,
                                generateMipmaps: this.generateMipmaps,
                                premultiplyAlpha: this.premultiplyAlpha,
                                unpackAlignment: this.unpackAlignment
                            };
                            return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }, {
                        key: "transformUv",
                        value: function (e) {
                            if (300 !== this.mapping) return e;
                            if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
                                case G:
                                    e.x = e.x - Math.floor(e.x);
                                    break;
                                case V:
                                    e.x = e.x < 0 ? 0 : 1;
                                    break;
                                case W:
                                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                            }
                            if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                                case G:
                                    e.y = e.y - Math.floor(e.y);
                                    break;
                                case V:
                                    e.y = e.y < 0 ? 0 : 1;
                                    break;
                                case W:
                                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                            }
                            return this.flipY && (e.y = 1 - e.y), e
                        }
                    }, {
                        key: "needsUpdate",
                        set: function (e) {
                            !0 === e && (this.version++, this.source.needsUpdate = !0)
                        }
                    }, {
                        key: "encoding",
                        get: function () {
                            return bt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Ke ? qe : 3e3
                        },
                        set: function (e) {
                            bt("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === qe ? Ke : Ye
                        }
                    }]), n
                }(it);
            Bt.DEFAULT_IMAGE = null, Bt.DEFAULT_MAPPING = 300, Bt.DEFAULT_ANISOTROPY = 1;
            var zt = function (e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        i(this, t), t.prototype.isVector4 = !0, this.x = e, this.y = n, this.z = r, this.w = a
                    }
                    return o(t, [{
                        key: "width",
                        get: function () {
                            return this.z
                        },
                        set: function (e) {
                            this.z = e
                        }
                    }, {
                        key: "height",
                        get: function () {
                            return this.w
                        },
                        set: function (e) {
                            this.w = e
                        }
                    }, {
                        key: "set",
                        value: function (e, t, n, r) {
                            return this.x = e, this.y = t, this.z = n, this.w = r, this
                        }
                    }, {
                        key: "setScalar",
                        value: function (e) {
                            return this.x = e, this.y = e, this.z = e, this.w = e, this
                        }
                    }, {
                        key: "setX",
                        value: function (e) {
                            return this.x = e, this
                        }
                    }, {
                        key: "setY",
                        value: function (e) {
                            return this.y = e, this
                        }
                    }, {
                        key: "setZ",
                        value: function (e) {
                            return this.z = e, this
                        }
                    }, {
                        key: "setW",
                        value: function (e) {
                            return this.w = e, this
                        }
                    }, {
                        key: "setComponent",
                        value: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                case 3:
                                    this.w = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                    }, {
                        key: "getComponent",
                        value: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                case 3:
                                    return this.w;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this.x, this.y, this.z, this.w)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
                        }
                    }, {
                        key: "addScalar",
                        value: function (e) {
                            return this.x += e, this.y += e, this.z += e, this.w += e, this
                        }
                    }, {
                        key: "addVectors",
                        value: function (e, t) {
                            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                        }
                    }, {
                        key: "addScaledVector",
                        value: function (e, t) {
                            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                        }
                    }, {
                        key: "sub",
                        value: function (e) {
                            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
                        }
                    }, {
                        key: "subScalar",
                        value: function (e) {
                            return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                        }
                    }, {
                        key: "subVectors",
                        value: function (e, t) {
                            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = this.w,
                                a = e.elements;
                            return this.x = a[0] * t + a[4] * n + a[8] * r + a[12] * i, this.y = a[1] * t + a[5] * n + a[9] * r + a[13] * i, this.z = a[2] * t + a[6] * n + a[10] * r + a[14] * i, this.w = a[3] * t + a[7] * n + a[11] * r + a[15] * i, this
                        }
                    }, {
                        key: "divideScalar",
                        value: function (e) {
                            return this.multiplyScalar(1 / e)
                        }
                    }, {
                        key: "setAxisAngleFromQuaternion",
                        value: function (e) {
                            this.w = 2 * Math.acos(e.w);
                            var t = Math.sqrt(1 - e.w * e.w);
                            return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                        }
                    }, {
                        key: "setAxisAngleFromRotationMatrix",
                        value: function (e) {
                            var t, n, r, i, a = .01,
                                o = .1,
                                s = e.elements,
                                l = s[0],
                                u = s[4],
                                c = s[8],
                                h = s[1],
                                d = s[5],
                                f = s[9],
                                p = s[2],
                                m = s[6],
                                v = s[10];
                            if (Math.abs(u - h) < a && Math.abs(c - p) < a && Math.abs(f - m) < a) {
                                if (Math.abs(u + h) < o && Math.abs(c + p) < o && Math.abs(f + m) < o && Math.abs(l + d + v - 3) < o) return this.set(1, 0, 0, 0), this;
                                t = Math.PI;
                                var g = (l + 1) / 2,
                                    _ = (d + 1) / 2,
                                    y = (v + 1) / 2,
                                    x = (u + h) / 4,
                                    M = (c + p) / 4,
                                    S = (f + m) / 4;
                                return g > _ && g > y ? g < a ? (n = 0, r = .707106781, i = .707106781) : (r = x / (n = Math.sqrt(g)), i = M / n) : _ > y ? _ < a ? (n = .707106781, r = 0, i = .707106781) : (n = x / (r = Math.sqrt(_)), i = S / r) : y < a ? (n = .707106781, r = .707106781, i = 0) : (n = M / (i = Math.sqrt(y)), r = S / i), this.set(n, r, i, t), this
                            }
                            var E = Math.sqrt((m - f) * (m - f) + (c - p) * (c - p) + (h - u) * (h - u));
                            return Math.abs(E) < .001 && (E = 1), this.x = (m - f) / E, this.y = (c - p) / E, this.z = (h - u) / E, this.w = Math.acos((l + d + v - 1) / 2), this
                        }
                    }, {
                        key: "min",
                        value: function (e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                        }
                    }, {
                        key: "max",
                        value: function (e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                        }
                    }, {
                        key: "clamp",
                        value: function (e, t) {
                            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                        }
                    }, {
                        key: "clampScalar",
                        value: function (e, t) {
                            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
                        }
                    }, {
                        key: "clampLength",
                        value: function (e, t) {
                            var n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                        }
                    }, {
                        key: "floor",
                        value: function () {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                        }
                    }, {
                        key: "ceil",
                        value: function () {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                        }
                    }, {
                        key: "round",
                        value: function () {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                        }
                    }, {
                        key: "roundToZero",
                        value: function () {
                            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                        }
                    }, {
                        key: "negate",
                        value: function () {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                        }
                    }, {
                        key: "dot",
                        value: function (e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                        }
                    }, {
                        key: "lengthSq",
                        value: function () {
                            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                        }
                    }, {
                        key: "length",
                        value: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                        }
                    }, {
                        key: "manhattanLength",
                        value: function () {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                        }
                    }, {
                        key: "normalize",
                        value: function () {
                            return this.divideScalar(this.length() || 1)
                        }
                    }, {
                        key: "setLength",
                        value: function (e) {
                            return this.normalize().multiplyScalar(e)
                        }
                    }, {
                        key: "lerp",
                        value: function (e, t) {
                            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                        }
                    }, {
                        key: "lerpVectors",
                        value: function (e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function (e, t) {
                            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
                        }
                    }, {
                        key: "random",
                        value: function () {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
                        }
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this.x;
                                    case 2:
                                        return e.next = 4, this.y;
                                    case 4:
                                        return e.next = 6, this.z;
                                    case 6:
                                        return e.next = 8, this.w;
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }]), t
                }(Symbol.iterator),
                Ht = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                        i(this, n), (e = t.call(this)).isRenderTarget = !0, e.width = r, e.height = a, e.depth = 1, e.scissor = new zt(0, 0, r, a), e.scissorTest = !1, e.viewport = new zt(0, 0, r, a);
                        var s = {
                            width: r,
                            height: a,
                            depth: 1
                        };
                        return void 0 !== o.encoding && (bt("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), o.colorSpace = o.encoding === qe ? Ke : Ye), e.texture = new Bt(s, o.mapping, o.wrapS, o.wrapT, o.magFilter, o.minFilter, o.format, o.type, o.anisotropy, o.colorSpace), e.texture.isRenderTargetTexture = !0, e.texture.flipY = !1, e.texture.generateMipmaps = void 0 !== o.generateMipmaps && o.generateMipmaps, e.texture.internalFormat = void 0 !== o.internalFormat ? o.internalFormat : null, e.texture.minFilter = void 0 !== o.minFilter ? o.minFilter : Y, e.depthBuffer = void 0 === o.depthBuffer || o.depthBuffer, e.stencilBuffer = void 0 !== o.stencilBuffer && o.stencilBuffer, e.depthTexture = void 0 !== o.depthTexture ? o.depthTexture : null, e.samples = void 0 !== o.samples ? o.samples : 0, e
                    }
                    return o(n, [{
                        key: "setSize",
                        value: function (e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                            this.width === e && this.height === t && this.depth === n || (this.width = e, this.height = t, this.depth = n, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = !0;
                            var t = Object.assign({}, e.texture.image);
                            return this.texture.source = new Nt(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }]), n
                }(it),
                Gt = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                        return i(this, n), (e = t.call(this, r, a, o)).isWebGLRenderTarget = !0, e
                    }
                    return o(n)
                }(Ht),
                Vt = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        return i(this, n), (e = t.call(this, null)).isDataArrayTexture = !0, e.image = {
                            data: r,
                            width: a,
                            height: o,
                            depth: s
                        }, e.magFilter = j, e.minFilter = j, e.wrapR = V, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                    }
                    return o(n)
                }(Bt),
                Wt = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        return i(this, n), (e = t.call(this, null)).isData3DTexture = !0, e.image = {
                            data: r,
                            width: a,
                            height: o,
                            depth: s
                        }, e.magFilter = j, e.minFilter = j, e.wrapR = V, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                    }
                    return o(n)
                }(Bt),
                jt = function (e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        i(this, t), this.isQuaternion = !0, this._x = e, this._y = n, this._z = r, this._w = a
                    }
                    return o(t, [{
                        key: "x",
                        get: function () {
                            return this._x
                        },
                        set: function (e) {
                            this._x = e, this._onChangeCallback()
                        }
                    }, {
                        key: "y",
                        get: function () {
                            return this._y
                        },
                        set: function (e) {
                            this._y = e, this._onChangeCallback()
                        }
                    }, {
                        key: "z",
                        get: function () {
                            return this._z
                        },
                        set: function (e) {
                            this._z = e, this._onChangeCallback()
                        }
                    }, {
                        key: "w",
                        get: function () {
                            return this._w
                        },
                        set: function (e) {
                            this._w = e, this._onChangeCallback()
                        }
                    }, {
                        key: "set",
                        value: function (e, t, n, r) {
                            return this._x = e, this._y = t, this._z = n, this._w = r, this._onChangeCallback(), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this._x, this._y, this._z, this._w)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromEuler",
                        value: function (e, t) {
                            var n = e._x,
                                r = e._y,
                                i = e._z,
                                a = e._order,
                                o = Math.cos,
                                s = Math.sin,
                                l = o(n / 2),
                                u = o(r / 2),
                                c = o(i / 2),
                                h = s(n / 2),
                                d = s(r / 2),
                                f = s(i / 2);
                            switch (a) {
                                case "XYZ":
                                    this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                                    break;
                                case "YXZ":
                                    this._x = h * u * c + l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                                    break;
                                case "ZXY":
                                    this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c - h * d * f;
                                    break;
                                case "ZYX":
                                    this._x = h * u * c - l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c + h * d * f;
                                    break;
                                case "YZX":
                                    this._x = h * u * c + l * d * f, this._y = l * d * c + h * u * f, this._z = l * u * f - h * d * c, this._w = l * u * c - h * d * f;
                                    break;
                                case "XZY":
                                    this._x = h * u * c - l * d * f, this._y = l * d * c - h * u * f, this._z = l * u * f + h * d * c, this._w = l * u * c + h * d * f;
                                    break;
                                default:
                                    console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
                            }
                            return !1 !== t && this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromAxisAngle",
                        value: function (e, t) {
                            var n = t / 2,
                                r = Math.sin(n);
                            return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromRotationMatrix",
                        value: function (e) {
                            var t = e.elements,
                                n = t[0],
                                r = t[4],
                                i = t[8],
                                a = t[1],
                                o = t[5],
                                s = t[9],
                                l = t[2],
                                u = t[6],
                                c = t[10],
                                h = n + o + c;
                            if (h > 0) {
                                var d = .5 / Math.sqrt(h + 1);
                                this._w = .25 / d, this._x = (u - s) * d, this._y = (i - l) * d, this._z = (a - r) * d
                            } else if (n > o && n > c) {
                                var f = 2 * Math.sqrt(1 + n - o - c);
                                this._w = (u - s) / f, this._x = .25 * f, this._y = (r + a) / f, this._z = (i + l) / f
                            } else if (o > c) {
                                var p = 2 * Math.sqrt(1 + o - n - c);
                                this._w = (i - l) / p, this._x = (r + a) / p, this._y = .25 * p, this._z = (s + u) / p
                            } else {
                                var m = 2 * Math.sqrt(1 + c - n - o);
                                this._w = (a - r) / m, this._x = (i + l) / m, this._y = (s + u) / m, this._z = .25 * m
                            }
                            return this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromUnitVectors",
                        value: function (e, t) {
                            var n = e.dot(t) + 1;
                            return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
                        }
                    }, {
                        key: "angleTo",
                        value: function (e) {
                            return 2 * Math.acos(Math.abs(ct(this.dot(e), -1, 1)))
                        }
                    }, {
                        key: "rotateTowards",
                        value: function (e, t) {
                            var n = this.angleTo(e);
                            if (0 === n) return this;
                            var r = Math.min(1, t / n);
                            return this.slerp(e, r), this
                        }
                    }, {
                        key: "identity",
                        value: function () {
                            return this.set(0, 0, 0, 1)
                        }
                    }, {
                        key: "invert",
                        value: function () {
                            return this.conjugate()
                        }
                    }, {
                        key: "conjugate",
                        value: function () {
                            return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                        }
                    }, {
                        key: "dot",
                        value: function (e) {
                            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                        }
                    }, {
                        key: "lengthSq",
                        value: function () {
                            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                        }
                    }, {
                        key: "length",
                        value: function () {
                            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                        }
                    }, {
                        key: "normalize",
                        value: function () {
                            var e = this.length();
                            return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.multiplyQuaternions(this, e)
                        }
                    }, {
                        key: "premultiply",
                        value: function (e) {
                            return this.multiplyQuaternions(e, this)
                        }
                    }, {
                        key: "multiplyQuaternions",
                        value: function (e, t) {
                            var n = e._x,
                                r = e._y,
                                i = e._z,
                                a = e._w,
                                o = t._x,
                                s = t._y,
                                l = t._z,
                                u = t._w;
                            return this._x = n * u + a * o + r * l - i * s, this._y = r * u + a * s + i * o - n * l, this._z = i * u + a * l + n * s - r * o, this._w = a * u - n * o - r * s - i * l, this._onChangeCallback(), this
                        }
                    }, {
                        key: "slerp",
                        value: function (e, t) {
                            if (0 === t) return this;
                            if (1 === t) return this.copy(e);
                            var n = this._x,
                                r = this._y,
                                i = this._z,
                                a = this._w,
                                o = a * e._w + n * e._x + r * e._y + i * e._z;
                            if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = n, this._y = r, this._z = i, this;
                            var s = 1 - o * o;
                            if (s <= Number.EPSILON) {
                                var l = 1 - t;
                                return this._w = l * a + t * this._w, this._x = l * n + t * this._x, this._y = l * r + t * this._y, this._z = l * i + t * this._z, this.normalize(), this._onChangeCallback(), this
                            }
                            var u = Math.sqrt(s),
                                c = Math.atan2(u, o),
                                h = Math.sin((1 - t) * c) / u,
                                d = Math.sin(t * c) / u;
                            return this._w = a * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = i * h + this._z * d, this._onChangeCallback(), this
                        }
                    }, {
                        key: "slerpQuaternions",
                        value: function (e, t, n) {
                            return this.copy(e).slerp(t, n)
                        }
                    }, {
                        key: "random",
                        value: function () {
                            var e = Math.random(),
                                t = Math.sqrt(1 - e),
                                n = Math.sqrt(e),
                                r = 2 * Math.PI * Math.random(),
                                i = 2 * Math.PI * Math.random();
                            return this.set(t * Math.cos(r), n * Math.sin(i), n * Math.cos(i), t * Math.sin(r))
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function (e, t) {
                            return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            return this.toArray()
                        }
                    }, {
                        key: "_onChange",
                        value: function (e) {
                            return this._onChangeCallback = e, this
                        }
                    }, {
                        key: "_onChangeCallback",
                        value: function () {}
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this._x;
                                    case 2:
                                        return e.next = 4, this._y;
                                    case 4:
                                        return e.next = 6, this._z;
                                    case 6:
                                        return e.next = 8, this._w;
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }], [{
                        key: "slerpFlat",
                        value: function (e, t, n, r, i, a, o) {
                            var s = n[r + 0],
                                l = n[r + 1],
                                u = n[r + 2],
                                c = n[r + 3],
                                h = i[a + 0],
                                d = i[a + 1],
                                f = i[a + 2],
                                p = i[a + 3];
                            if (0 === o) return e[t + 0] = s, e[t + 1] = l, e[t + 2] = u, void(e[t + 3] = c);
                            if (1 === o) return e[t + 0] = h, e[t + 1] = d, e[t + 2] = f, void(e[t + 3] = p);
                            if (c !== p || s !== h || l !== d || u !== f) {
                                var m = 1 - o,
                                    v = s * h + l * d + u * f + c * p,
                                    g = v >= 0 ? 1 : -1,
                                    _ = 1 - v * v;
                                if (_ > Number.EPSILON) {
                                    var y = Math.sqrt(_),
                                        x = Math.atan2(y, v * g);
                                    m = Math.sin(m * x) / y, o = Math.sin(o * x) / y
                                }
                                var M = o * g;
                                if (s = s * m + h * M, l = l * m + d * M, u = u * m + f * M, c = c * m + p * M, m === 1 - o) {
                                    var S = 1 / Math.sqrt(s * s + l * l + u * u + c * c);
                                    s *= S, l *= S, u *= S, c *= S
                                }
                            }
                            e[t] = s, e[t + 1] = l, e[t + 2] = u, e[t + 3] = c
                        }
                    }, {
                        key: "multiplyQuaternionsFlat",
                        value: function (e, t, n, r, i, a) {
                            var o = n[r],
                                s = n[r + 1],
                                l = n[r + 2],
                                u = n[r + 3],
                                c = i[a],
                                h = i[a + 1],
                                d = i[a + 2],
                                f = i[a + 3];
                            return e[t] = o * f + u * c + s * d - l * h, e[t + 1] = s * f + u * h + l * c - o * d, e[t + 2] = l * f + u * d + o * h - s * c, e[t + 3] = u * f - o * c - s * h - l * d, e
                        }
                    }]), t
                }(Symbol.iterator),
                Xt = function (e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                        i(this, t), t.prototype.isVector3 = !0, this.x = e, this.y = n, this.z = r
                    }
                    return o(t, [{
                        key: "set",
                        value: function (e, t, n) {
                            return void 0 === n && (n = this.z), this.x = e, this.y = t, this.z = n, this
                        }
                    }, {
                        key: "setScalar",
                        value: function (e) {
                            return this.x = e, this.y = e, this.z = e, this
                        }
                    }, {
                        key: "setX",
                        value: function (e) {
                            return this.x = e, this
                        }
                    }, {
                        key: "setY",
                        value: function (e) {
                            return this.y = e, this
                        }
                    }, {
                        key: "setZ",
                        value: function (e) {
                            return this.z = e, this
                        }
                    }, {
                        key: "setComponent",
                        value: function (e, t) {
                            switch (e) {
                                case 0:
                                    this.x = t;
                                    break;
                                case 1:
                                    this.y = t;
                                    break;
                                case 2:
                                    this.z = t;
                                    break;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                            return this
                        }
                    }, {
                        key: "getComponent",
                        value: function (e) {
                            switch (e) {
                                case 0:
                                    return this.x;
                                case 1:
                                    return this.y;
                                case 2:
                                    return this.z;
                                default:
                                    throw new Error("index is out of range: " + e)
                            }
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this.x, this.y, this.z)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.x = e.x, this.y = e.y, this.z = e.z, this
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            return this.x += e.x, this.y += e.y, this.z += e.z, this
                        }
                    }, {
                        key: "addScalar",
                        value: function (e) {
                            return this.x += e, this.y += e, this.z += e, this
                        }
                    }, {
                        key: "addVectors",
                        value: function (e, t) {
                            return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                        }
                    }, {
                        key: "addScaledVector",
                        value: function (e, t) {
                            return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                        }
                    }, {
                        key: "sub",
                        value: function (e) {
                            return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
                        }
                    }, {
                        key: "subScalar",
                        value: function (e) {
                            return this.x -= e, this.y -= e, this.z -= e, this
                        }
                    }, {
                        key: "subVectors",
                        value: function (e, t) {
                            return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            return this.x *= e, this.y *= e, this.z *= e, this
                        }
                    }, {
                        key: "multiplyVectors",
                        value: function (e, t) {
                            return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                        }
                    }, {
                        key: "applyEuler",
                        value: function (e) {
                            return this.applyQuaternion(Yt.setFromEuler(e))
                        }
                    }, {
                        key: "applyAxisAngle",
                        value: function (e, t) {
                            return this.applyQuaternion(Yt.setFromAxisAngle(e, t))
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements;
                            return this.x = i[0] * t + i[3] * n + i[6] * r, this.y = i[1] * t + i[4] * n + i[7] * r, this.z = i[2] * t + i[5] * n + i[8] * r, this
                        }
                    }, {
                        key: "applyNormalMatrix",
                        value: function (e) {
                            return this.applyMatrix3(e).normalize()
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements,
                                a = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
                            return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * a, this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * a, this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * a, this
                        }
                    }, {
                        key: "applyQuaternion",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.x,
                                a = e.y,
                                o = e.z,
                                s = e.w,
                                l = s * t + a * r - o * n,
                                u = s * n + o * t - i * r,
                                c = s * r + i * n - a * t,
                                h = -i * t - a * n - o * r;
                            return this.x = l * s + h * -i + u * -o - c * -a, this.y = u * s + h * -a + c * -i - l * -o, this.z = c * s + h * -o + l * -a - u * -i, this
                        }
                    }, {
                        key: "project",
                        value: function (e) {
                            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
                        }
                    }, {
                        key: "unproject",
                        value: function (e) {
                            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
                        }
                    }, {
                        key: "transformDirection",
                        value: function (e) {
                            var t = this.x,
                                n = this.y,
                                r = this.z,
                                i = e.elements;
                            return this.x = i[0] * t + i[4] * n + i[8] * r, this.y = i[1] * t + i[5] * n + i[9] * r, this.z = i[2] * t + i[6] * n + i[10] * r, this.normalize()
                        }
                    }, {
                        key: "divide",
                        value: function (e) {
                            return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                        }
                    }, {
                        key: "divideScalar",
                        value: function (e) {
                            return this.multiplyScalar(1 / e)
                        }
                    }, {
                        key: "min",
                        value: function (e) {
                            return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                        }
                    }, {
                        key: "max",
                        value: function (e) {
                            return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                        }
                    }, {
                        key: "clamp",
                        value: function (e, t) {
                            return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                        }
                    }, {
                        key: "clampScalar",
                        value: function (e, t) {
                            return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
                        }
                    }, {
                        key: "clampLength",
                        value: function (e, t) {
                            var n = this.length();
                            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
                        }
                    }, {
                        key: "floor",
                        value: function () {
                            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                        }
                    }, {
                        key: "ceil",
                        value: function () {
                            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                        }
                    }, {
                        key: "round",
                        value: function () {
                            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                        }
                    }, {
                        key: "roundToZero",
                        value: function () {
                            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                        }
                    }, {
                        key: "negate",
                        value: function () {
                            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                        }
                    }, {
                        key: "dot",
                        value: function (e) {
                            return this.x * e.x + this.y * e.y + this.z * e.z
                        }
                    }, {
                        key: "lengthSq",
                        value: function () {
                            return this.x * this.x + this.y * this.y + this.z * this.z
                        }
                    }, {
                        key: "length",
                        value: function () {
                            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                        }
                    }, {
                        key: "manhattanLength",
                        value: function () {
                            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                        }
                    }, {
                        key: "normalize",
                        value: function () {
                            return this.divideScalar(this.length() || 1)
                        }
                    }, {
                        key: "setLength",
                        value: function (e) {
                            return this.normalize().multiplyScalar(e)
                        }
                    }, {
                        key: "lerp",
                        value: function (e, t) {
                            return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                        }
                    }, {
                        key: "lerpVectors",
                        value: function (e, t, n) {
                            return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
                        }
                    }, {
                        key: "cross",
                        value: function (e) {
                            return this.crossVectors(this, e)
                        }
                    }, {
                        key: "crossVectors",
                        value: function (e, t) {
                            var n = e.x,
                                r = e.y,
                                i = e.z,
                                a = t.x,
                                o = t.y,
                                s = t.z;
                            return this.x = r * s - i * o, this.y = i * a - n * s, this.z = n * o - r * a, this
                        }
                    }, {
                        key: "projectOnVector",
                        value: function (e) {
                            var t = e.lengthSq();
                            if (0 === t) return this.set(0, 0, 0);
                            var n = e.dot(this) / t;
                            return this.copy(e).multiplyScalar(n)
                        }
                    }, {
                        key: "projectOnPlane",
                        value: function (e) {
                            return qt.copy(this).projectOnVector(e), this.sub(qt)
                        }
                    }, {
                        key: "reflect",
                        value: function (e) {
                            return this.sub(qt.copy(e).multiplyScalar(2 * this.dot(e)))
                        }
                    }, {
                        key: "angleTo",
                        value: function (e) {
                            var t = Math.sqrt(this.lengthSq() * e.lengthSq());
                            if (0 === t) return Math.PI / 2;
                            var n = this.dot(e) / t;
                            return Math.acos(ct(n, -1, 1))
                        }
                    }, {
                        key: "distanceTo",
                        value: function (e) {
                            return Math.sqrt(this.distanceToSquared(e))
                        }
                    }, {
                        key: "distanceToSquared",
                        value: function (e) {
                            var t = this.x - e.x,
                                n = this.y - e.y,
                                r = this.z - e.z;
                            return t * t + n * n + r * r
                        }
                    }, {
                        key: "manhattanDistanceTo",
                        value: function (e) {
                            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
                        }
                    }, {
                        key: "setFromSpherical",
                        value: function (e) {
                            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
                        }
                    }, {
                        key: "setFromSphericalCoords",
                        value: function (e, t, n) {
                            var r = Math.sin(t) * e;
                            return this.x = r * Math.sin(n), this.y = Math.cos(t) * e, this.z = r * Math.cos(n), this
                        }
                    }, {
                        key: "setFromCylindrical",
                        value: function (e) {
                            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
                        }
                    }, {
                        key: "setFromCylindricalCoords",
                        value: function (e, t, n) {
                            return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
                        }
                    }, {
                        key: "setFromMatrixPosition",
                        value: function (e) {
                            var t = e.elements;
                            return this.x = t[12], this.y = t[13], this.z = t[14], this
                        }
                    }, {
                        key: "setFromMatrixScale",
                        value: function (e) {
                            var t = this.setFromMatrixColumn(e, 0).length(),
                                n = this.setFromMatrixColumn(e, 1).length(),
                                r = this.setFromMatrixColumn(e, 2).length();
                            return this.x = t, this.y = n, this.z = r, this
                        }
                    }, {
                        key: "setFromMatrixColumn",
                        value: function (e, t) {
                            return this.fromArray(e.elements, 4 * t)
                        }
                    }, {
                        key: "setFromMatrix3Column",
                        value: function (e, t) {
                            return this.fromArray(e.elements, 3 * t)
                        }
                    }, {
                        key: "setFromEuler",
                        value: function (e) {
                            return this.x = e._x, this.y = e._y, this.z = e._z, this
                        }
                    }, {
                        key: "setFromColor",
                        value: function (e) {
                            return this.x = e.r, this.y = e.g, this.z = e.b, this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.x === this.x && e.y === this.y && e.z === this.z
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function (e, t) {
                            return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
                        }
                    }, {
                        key: "random",
                        value: function () {
                            return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
                        }
                    }, {
                        key: "randomDirection",
                        value: function () {
                            var e = 2 * (Math.random() - .5),
                                t = Math.random() * Math.PI * 2,
                                n = Math.sqrt(1 - Math.pow(e, 2));
                            return this.x = n * Math.cos(t), this.y = n * Math.sin(t), this.z = e, this
                        }
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this.x;
                                    case 2:
                                        return e.next = 4, this.y;
                                    case 4:
                                        return e.next = 6, this.z;
                                    case 6:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }]), t
                }(Symbol.iterator),
                qt = new Xt,
                Yt = new jt,
                Kt = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xt(1 / 0, 1 / 0, 1 / 0),
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Xt(-1 / 0, -1 / 0, -1 / 0);
                        i(this, e), this.isBox3 = !0, this.min = t, this.max = n
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t) {
                            return this.min.copy(e), this.max.copy(t), this
                        }
                    }, {
                        key: "setFromArray",
                        value: function (e) {
                            this.makeEmpty();
                            for (var t = 0, n = e.length; t < n; t += 3) this.expandByPoint(Jt.fromArray(e, t));
                            return this
                        }
                    }, {
                        key: "setFromBufferAttribute",
                        value: function (e) {
                            this.makeEmpty();
                            for (var t = 0, n = e.count; t < n; t++) this.expandByPoint(Jt.fromBufferAttribute(e, t));
                            return this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function (e) {
                            this.makeEmpty();
                            for (var t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
                            return this
                        }
                    }, {
                        key: "setFromCenterAndSize",
                        value: function (e, t) {
                            var n = Jt.copy(t).multiplyScalar(.5);
                            return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
                        }
                    }, {
                        key: "setFromObject",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            return this.makeEmpty(), this.expandByObject(e, t)
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.min.copy(e.min), this.max.copy(e.max), this
                        }
                    }, {
                        key: "makeEmpty",
                        value: function () {
                            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                        }
                    }, {
                        key: "isEmpty",
                        value: function () {
                            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                        }
                    }, {
                        key: "getCenter",
                        value: function (e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
                        }
                    }, {
                        key: "getSize",
                        value: function (e) {
                            return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
                        }
                    }, {
                        key: "expandByPoint",
                        value: function (e) {
                            return this.min.min(e), this.max.max(e), this
                        }
                    }, {
                        key: "expandByVector",
                        value: function (e) {
                            return this.min.sub(e), this.max.add(e), this
                        }
                    }, {
                        key: "expandByScalar",
                        value: function (e) {
                            return this.min.addScalar(-e), this.max.addScalar(e), this
                        }
                    }, {
                        key: "expandByObject",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                            if (e.updateWorldMatrix(!1, !1), void 0 !== e.boundingBox) null === e.boundingBox && e.computeBoundingBox(), Qt.copy(e.boundingBox), Qt.applyMatrix4(e.matrixWorld), this.union(Qt);
                            else {
                                var n = e.geometry;
                                if (void 0 !== n)
                                    if (t && void 0 !== n.attributes && void 0 !== n.attributes.position)
                                        for (var r = n.attributes.position, i = 0, a = r.count; i < a; i++) Jt.fromBufferAttribute(r, i).applyMatrix4(e.matrixWorld), this.expandByPoint(Jt);
                                    else null === n.boundingBox && n.computeBoundingBox(), Qt.copy(n.boundingBox), Qt.applyMatrix4(e.matrixWorld), this.union(Qt)
                            }
                            for (var o = e.children, s = 0, l = o.length; s < l; s++) this.expandByObject(o[s], t);
                            return this
                        }
                    }, {
                        key: "containsPoint",
                        value: function (e) {
                            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                        }
                    }, {
                        key: "containsBox",
                        value: function (e) {
                            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                        }
                    }, {
                        key: "getParameter",
                        value: function (e, t) {
                            return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function (e) {
                            return this.clampPoint(e.center, Jt), Jt.distanceToSquared(e.center) <= e.radius * e.radius
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function (e) {
                            var t, n;
                            return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
                        }
                    }, {
                        key: "intersectsTriangle",
                        value: function (e) {
                            if (this.isEmpty()) return !1;
                            this.getCenter(on), sn.subVectors(this.max, on), $t.subVectors(e.a, on), en.subVectors(e.b, on), tn.subVectors(e.c, on), nn.subVectors(en, $t), rn.subVectors(tn, en), an.subVectors($t, tn);
                            var t = [0, -nn.z, nn.y, 0, -rn.z, rn.y, 0, -an.z, an.y, nn.z, 0, -nn.x, rn.z, 0, -rn.x, an.z, 0, -an.x, -nn.y, nn.x, 0, -rn.y, rn.x, 0, -an.y, an.x, 0];
                            return !!cn(t, $t, en, tn, sn) && (!!cn(t = [1, 0, 0, 0, 1, 0, 0, 0, 1], $t, en, tn, sn) && (ln.crossVectors(nn, rn), cn(t = [ln.x, ln.y, ln.z], $t, en, tn, sn)))
                        }
                    }, {
                        key: "clampPoint",
                        value: function (e, t) {
                            return t.copy(e).clamp(this.min, this.max)
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function (e) {
                            return this.clampPoint(e, Jt).distanceTo(e)
                        }
                    }, {
                        key: "getBoundingSphere",
                        value: function (e) {
                            return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = .5 * this.getSize(Jt).length()), e
                        }
                    }, {
                        key: "intersect",
                        value: function (e) {
                            return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
                        }
                    }, {
                        key: "union",
                        value: function (e) {
                            return this.min.min(e.min), this.max.max(e.max), this
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            return this.isEmpty() || (Zt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Zt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Zt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Zt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Zt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Zt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Zt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Zt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Zt)), this
                        }
                    }, {
                        key: "translate",
                        value: function (e) {
                            return this.min.add(e), this.max.add(e), this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.min.equals(this.min) && e.max.equals(this.max)
                        }
                    }]), e
                }(),
                Zt = [new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt, new Xt],
                Jt = new Xt,
                Qt = new Kt,
                $t = new Xt,
                en = new Xt,
                tn = new Xt,
                nn = new Xt,
                rn = new Xt,
                an = new Xt,
                on = new Xt,
                sn = new Xt,
                ln = new Xt,
                un = new Xt;

            function cn(e, t, n, r, i) {
                for (var a = 0, o = e.length - 3; a <= o; a += 3) {
                    un.fromArray(e, a);
                    var s = i.x * Math.abs(un.x) + i.y * Math.abs(un.y) + i.z * Math.abs(un.z),
                        l = t.dot(un),
                        u = n.dot(un),
                        c = r.dot(un);
                    if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > s) return !1
                }
                return !0
            }
            var hn = new Kt,
                dn = new Xt,
                fn = new Xt,
                pn = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xt,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1;
                        i(this, e), this.center = t, this.radius = n
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t) {
                            return this.center.copy(e), this.radius = t, this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function (e, t) {
                            var n = this.center;
                            void 0 !== t ? n.copy(t) : hn.setFromPoints(e).getCenter(n);
                            for (var r = 0, i = 0, a = e.length; i < a; i++) r = Math.max(r, n.distanceToSquared(e[i]));
                            return this.radius = Math.sqrt(r), this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.center.copy(e.center), this.radius = e.radius, this
                        }
                    }, {
                        key: "isEmpty",
                        value: function () {
                            return this.radius < 0
                        }
                    }, {
                        key: "makeEmpty",
                        value: function () {
                            return this.center.set(0, 0, 0), this.radius = -1, this
                        }
                    }, {
                        key: "containsPoint",
                        value: function (e) {
                            return e.distanceToSquared(this.center) <= this.radius * this.radius
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function (e) {
                            return e.distanceTo(this.center) - this.radius
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function (e) {
                            var t = this.radius + e.radius;
                            return e.center.distanceToSquared(this.center) <= t * t
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            return e.intersectsSphere(this)
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function (e) {
                            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
                        }
                    }, {
                        key: "clampPoint",
                        value: function (e, t) {
                            var n = this.center.distanceToSquared(e);
                            return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
                        }
                    }, {
                        key: "getBoundingBox",
                        value: function (e) {
                            return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                        }
                    }, {
                        key: "translate",
                        value: function (e) {
                            return this.center.add(e), this
                        }
                    }, {
                        key: "expandByPoint",
                        value: function (e) {
                            if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
                            dn.subVectors(e, this.center);
                            var t = dn.lengthSq();
                            if (t > this.radius * this.radius) {
                                var n = Math.sqrt(t),
                                    r = .5 * (n - this.radius);
                                this.center.addScaledVector(dn, r / n), this.radius += r
                            }
                            return this
                        }
                    }, {
                        key: "union",
                        value: function (e) {
                            return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (!0 === this.center.equals(e.center) ? this.radius = Math.max(this.radius, e.radius) : (fn.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(dn.copy(e.center).add(fn)), this.expandByPoint(dn.copy(e.center).sub(fn))), this)
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.center.equals(this.center) && e.radius === this.radius
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                mn = new Xt,
                vn = new Xt,
                gn = new Xt,
                _n = new Xt,
                yn = new Xt,
                xn = new Xt,
                Mn = new Xt,
                Sn = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xt,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Xt(0, 0, -1);
                        i(this, e), this.origin = t, this.direction = n
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t) {
                            return this.origin.copy(e), this.direction.copy(t), this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                        }
                    }, {
                        key: "at",
                        value: function (e, t) {
                            return t.copy(this.origin).addScaledVector(this.direction, e)
                        }
                    }, {
                        key: "lookAt",
                        value: function (e) {
                            return this.direction.copy(e).sub(this.origin).normalize(), this
                        }
                    }, {
                        key: "recast",
                        value: function (e) {
                            return this.origin.copy(this.at(e, mn)), this
                        }
                    }, {
                        key: "closestPointToPoint",
                        value: function (e, t) {
                            t.subVectors(e, this.origin);
                            var n = t.dot(this.direction);
                            return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function (e) {
                            return Math.sqrt(this.distanceSqToPoint(e))
                        }
                    }, {
                        key: "distanceSqToPoint",
                        value: function (e) {
                            var t = mn.subVectors(e, this.origin).dot(this.direction);
                            return t < 0 ? this.origin.distanceToSquared(e) : (mn.copy(this.origin).addScaledVector(this.direction, t), mn.distanceToSquared(e))
                        }
                    }, {
                        key: "distanceSqToSegment",
                        value: function (e, t, n, r) {
                            vn.copy(e).add(t).multiplyScalar(.5), gn.copy(t).sub(e).normalize(), _n.copy(this.origin).sub(vn);
                            var i, a, o, s, l = .5 * e.distanceTo(t),
                                u = -this.direction.dot(gn),
                                c = _n.dot(this.direction),
                                h = -_n.dot(gn),
                                d = _n.lengthSq(),
                                f = Math.abs(1 - u * u);
                            if (f > 0)
                                if (a = u * c - h, s = l * f, (i = u * h - c) >= 0)
                                    if (a >= -s)
                                        if (a <= s) {
                                            var p = 1 / f;
                                            o = (i *= p) * (i + u * (a *= p) + 2 * c) + a * (u * i + a + 2 * h) + d
                                        } else a = l, o = -(i = Math.max(0, -(u * a + c))) * i + a * (a + 2 * h) + d;
                            else a = -l, o = -(i = Math.max(0, -(u * a + c))) * i + a * (a + 2 * h) + d;
                            else a <= -s ? o = -(i = Math.max(0, -(-u * l + c))) * i + (a = i > 0 ? -l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d : a <= s ? (i = 0, o = (a = Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d) : o = -(i = Math.max(0, -(u * l + c))) * i + (a = i > 0 ? l : Math.min(Math.max(-l, -h), l)) * (a + 2 * h) + d;
                            else a = u > 0 ? -l : l, o = -(i = Math.max(0, -(u * a + c))) * i + a * (a + 2 * h) + d;
                            return n && n.copy(this.origin).addScaledVector(this.direction, i), r && r.copy(vn).addScaledVector(gn, a), o
                        }
                    }, {
                        key: "intersectSphere",
                        value: function (e, t) {
                            mn.subVectors(e.center, this.origin);
                            var n = mn.dot(this.direction),
                                r = mn.dot(mn) - n * n,
                                i = e.radius * e.radius;
                            if (r > i) return null;
                            var a = Math.sqrt(i - r),
                                o = n - a,
                                s = n + a;
                            return s < 0 ? null : o < 0 ? this.at(s, t) : this.at(o, t)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function (e) {
                            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
                        }
                    }, {
                        key: "distanceToPlane",
                        value: function (e) {
                            var t = e.normal.dot(this.direction);
                            if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                            var n = -(this.origin.dot(e.normal) + e.constant) / t;
                            return n >= 0 ? n : null
                        }
                    }, {
                        key: "intersectPlane",
                        value: function (e, t) {
                            var n = this.distanceToPlane(e);
                            return null === n ? null : this.at(n, t)
                        }
                    }, {
                        key: "intersectsPlane",
                        value: function (e) {
                            var t = e.distanceToPoint(this.origin);
                            return 0 === t || e.normal.dot(this.direction) * t < 0
                        }
                    }, {
                        key: "intersectBox",
                        value: function (e, t) {
                            var n, r, i, a, o, s, l = 1 / this.direction.x,
                                u = 1 / this.direction.y,
                                c = 1 / this.direction.z,
                                h = this.origin;
                            return l >= 0 ? (n = (e.min.x - h.x) * l, r = (e.max.x - h.x) * l) : (n = (e.max.x - h.x) * l, r = (e.min.x - h.x) * l), u >= 0 ? (i = (e.min.y - h.y) * u, a = (e.max.y - h.y) * u) : (i = (e.max.y - h.y) * u, a = (e.min.y - h.y) * u), n > a || i > r ? null : ((i > n || isNaN(n)) && (n = i), (a < r || isNaN(r)) && (r = a), c >= 0 ? (o = (e.min.z - h.z) * c, s = (e.max.z - h.z) * c) : (o = (e.max.z - h.z) * c, s = (e.min.z - h.z) * c), n > s || o > r ? null : ((o > n || n != n) && (n = o), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, t)))
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            return null !== this.intersectBox(e, mn)
                        }
                    }, {
                        key: "intersectTriangle",
                        value: function (e, t, n, r, i) {
                            yn.subVectors(t, e), xn.subVectors(n, e), Mn.crossVectors(yn, xn);
                            var a, o = this.direction.dot(Mn);
                            if (o > 0) {
                                if (r) return null;
                                a = 1
                            } else {
                                if (!(o < 0)) return null;
                                a = -1, o = -o
                            }
                            _n.subVectors(this.origin, e);
                            var s = a * this.direction.dot(xn.crossVectors(_n, xn));
                            if (s < 0) return null;
                            var l = a * this.direction.dot(yn.cross(_n));
                            if (l < 0) return null;
                            if (s + l > o) return null;
                            var u = -a * _n.dot(Mn);
                            return u < 0 ? null : this.at(u / o, i)
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                En = function () {
                    function e(t, n, r, a, o, s, l, u, c, h, d, f, p, m, v, g) {
                        i(this, e), e.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], void 0 !== t && this.set(t, n, r, a, o, s, l, u, c, h, d, f, p, m, v, g)
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t, n, r, i, a, o, s, l, u, c, h, d, f, p, m) {
                            var v = this.elements;
                            return v[0] = e, v[4] = t, v[8] = n, v[12] = r, v[1] = i, v[5] = a, v[9] = o, v[13] = s, v[2] = l, v[6] = u, v[10] = c, v[14] = h, v[3] = d, v[7] = f, v[11] = p, v[15] = m, this
                        }
                    }, {
                        key: "identity",
                        value: function () {
                            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new e).fromArray(this.elements)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            var t = this.elements,
                                n = e.elements;
                            return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
                        }
                    }, {
                        key: "copyPosition",
                        value: function (e) {
                            var t = this.elements,
                                n = e.elements;
                            return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
                        }
                    }, {
                        key: "setFromMatrix3",
                        value: function (e) {
                            var t = e.elements;
                            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "extractBasis",
                        value: function (e, t, n) {
                            return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                        }
                    }, {
                        key: "makeBasis",
                        value: function (e, t, n) {
                            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "extractRotation",
                        value: function (e) {
                            var t = this.elements,
                                n = e.elements,
                                r = 1 / Tn.setFromMatrixColumn(e, 0).length(),
                                i = 1 / Tn.setFromMatrixColumn(e, 1).length(),
                                a = 1 / Tn.setFromMatrixColumn(e, 2).length();
                            return t[0] = n[0] * r, t[1] = n[1] * r, t[2] = n[2] * r, t[3] = 0, t[4] = n[4] * i, t[5] = n[5] * i, t[6] = n[6] * i, t[7] = 0, t[8] = n[8] * a, t[9] = n[9] * a, t[10] = n[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                        }
                    }, {
                        key: "makeRotationFromEuler",
                        value: function (e) {
                            var t = this.elements,
                                n = e.x,
                                r = e.y,
                                i = e.z,
                                a = Math.cos(n),
                                o = Math.sin(n),
                                s = Math.cos(r),
                                l = Math.sin(r),
                                u = Math.cos(i),
                                c = Math.sin(i);
                            if ("XYZ" === e.order) {
                                var h = a * u,
                                    d = a * c,
                                    f = o * u,
                                    p = o * c;
                                t[0] = s * u, t[4] = -s * c, t[8] = l, t[1] = d + f * l, t[5] = h - p * l, t[9] = -o * s, t[2] = p - h * l, t[6] = f + d * l, t[10] = a * s
                            } else if ("YXZ" === e.order) {
                                var m = s * u,
                                    v = s * c,
                                    g = l * u,
                                    _ = l * c;
                                t[0] = m + _ * o, t[4] = g * o - v, t[8] = a * l, t[1] = a * c, t[5] = a * u, t[9] = -o, t[2] = v * o - g, t[6] = _ + m * o, t[10] = a * s
                            } else if ("ZXY" === e.order) {
                                var y = s * u,
                                    x = s * c,
                                    M = l * u,
                                    S = l * c;
                                t[0] = y - S * o, t[4] = -a * c, t[8] = M + x * o, t[1] = x + M * o, t[5] = a * u, t[9] = S - y * o, t[2] = -a * l, t[6] = o, t[10] = a * s
                            } else if ("ZYX" === e.order) {
                                var E = a * u,
                                    T = a * c,
                                    b = o * u,
                                    A = o * c;
                                t[0] = s * u, t[4] = b * l - T, t[8] = E * l + A, t[1] = s * c, t[5] = A * l + E, t[9] = T * l - b, t[2] = -l, t[6] = o * s, t[10] = a * s
                            } else if ("YZX" === e.order) {
                                var w = a * s,
                                    R = a * l,
                                    C = o * s,
                                    L = o * l;
                                t[0] = s * u, t[4] = L - w * c, t[8] = C * c + R, t[1] = c, t[5] = a * u, t[9] = -o * u, t[2] = -l * u, t[6] = R * c + C, t[10] = w - L * c
                            } else if ("XZY" === e.order) {
                                var P = a * s,
                                    k = a * l,
                                    I = o * s,
                                    U = o * l;
                                t[0] = s * u, t[4] = -c, t[8] = l * u, t[1] = P * c + U, t[5] = a * u, t[9] = k * c - I, t[2] = I * c - k, t[6] = o * u, t[10] = U * c + P
                            }
                            return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                        }
                    }, {
                        key: "makeRotationFromQuaternion",
                        value: function (e) {
                            return this.compose(An, e, wn)
                        }
                    }, {
                        key: "lookAt",
                        value: function (e, t, n) {
                            var r = this.elements;
                            return Ln.subVectors(e, t), 0 === Ln.lengthSq() && (Ln.z = 1), Ln.normalize(), Rn.crossVectors(n, Ln), 0 === Rn.lengthSq() && (1 === Math.abs(n.z) ? Ln.x += 1e-4 : Ln.z += 1e-4, Ln.normalize(), Rn.crossVectors(n, Ln)), Rn.normalize(), Cn.crossVectors(Ln, Rn), r[0] = Rn.x, r[4] = Cn.x, r[8] = Ln.x, r[1] = Rn.y, r[5] = Cn.y, r[9] = Ln.y, r[2] = Rn.z, r[6] = Cn.z, r[10] = Ln.z, this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.multiplyMatrices(this, e)
                        }
                    }, {
                        key: "premultiply",
                        value: function (e) {
                            return this.multiplyMatrices(e, this)
                        }
                    }, {
                        key: "multiplyMatrices",
                        value: function (e, t) {
                            var n = e.elements,
                                r = t.elements,
                                i = this.elements,
                                a = n[0],
                                o = n[4],
                                s = n[8],
                                l = n[12],
                                u = n[1],
                                c = n[5],
                                h = n[9],
                                d = n[13],
                                f = n[2],
                                p = n[6],
                                m = n[10],
                                v = n[14],
                                g = n[3],
                                _ = n[7],
                                y = n[11],
                                x = n[15],
                                M = r[0],
                                S = r[4],
                                E = r[8],
                                T = r[12],
                                b = r[1],
                                A = r[5],
                                w = r[9],
                                R = r[13],
                                C = r[2],
                                L = r[6],
                                P = r[10],
                                k = r[14],
                                I = r[3],
                                U = r[7],
                                D = r[11],
                                N = r[15];
                            return i[0] = a * M + o * b + s * C + l * I, i[4] = a * S + o * A + s * L + l * U, i[8] = a * E + o * w + s * P + l * D, i[12] = a * T + o * R + s * k + l * N, i[1] = u * M + c * b + h * C + d * I, i[5] = u * S + c * A + h * L + d * U, i[9] = u * E + c * w + h * P + d * D, i[13] = u * T + c * R + h * k + d * N, i[2] = f * M + p * b + m * C + v * I, i[6] = f * S + p * A + m * L + v * U, i[10] = f * E + p * w + m * P + v * D, i[14] = f * T + p * R + m * k + v * N, i[3] = g * M + _ * b + y * C + x * I, i[7] = g * S + _ * A + y * L + x * U, i[11] = g * E + _ * w + y * P + x * D, i[15] = g * T + _ * R + y * k + x * N, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            var t = this.elements;
                            return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                        }
                    }, {
                        key: "determinant",
                        value: function () {
                            var e = this.elements,
                                t = e[0],
                                n = e[4],
                                r = e[8],
                                i = e[12],
                                a = e[1],
                                o = e[5],
                                s = e[9],
                                l = e[13],
                                u = e[2],
                                c = e[6],
                                h = e[10],
                                d = e[14];
                            return e[3] * (+i * s * c - r * l * c - i * o * h + n * l * h + r * o * d - n * s * d) + e[7] * (+t * s * d - t * l * h + i * a * h - r * a * d + r * l * u - i * s * u) + e[11] * (+t * l * c - t * o * d - i * a * c + n * a * d + i * o * u - n * l * u) + e[15] * (-r * o * u - t * s * c + t * o * h + r * a * c - n * a * h + n * s * u)
                        }
                    }, {
                        key: "transpose",
                        value: function () {
                            var e, t = this.elements;
                            return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                        }
                    }, {
                        key: "setPosition",
                        value: function (e, t, n) {
                            var r = this.elements;
                            return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = n), this
                        }
                    }, {
                        key: "invert",
                        value: function () {
                            var e = this.elements,
                                t = e[0],
                                n = e[1],
                                r = e[2],
                                i = e[3],
                                a = e[4],
                                o = e[5],
                                s = e[6],
                                l = e[7],
                                u = e[8],
                                c = e[9],
                                h = e[10],
                                d = e[11],
                                f = e[12],
                                p = e[13],
                                m = e[14],
                                v = e[15],
                                g = c * m * l - p * h * l + p * s * d - o * m * d - c * s * v + o * h * v,
                                _ = f * h * l - u * m * l - f * s * d + a * m * d + u * s * v - a * h * v,
                                y = u * p * l - f * c * l + f * o * d - a * p * d - u * o * v + a * c * v,
                                x = f * c * s - u * p * s - f * o * h + a * p * h + u * o * m - a * c * m,
                                M = t * g + n * _ + r * y + i * x;
                            if (0 === M) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                            var S = 1 / M;
                            return e[0] = g * S, e[1] = (p * h * i - c * m * i - p * r * d + n * m * d + c * r * v - n * h * v) * S, e[2] = (o * m * i - p * s * i + p * r * l - n * m * l - o * r * v + n * s * v) * S, e[3] = (c * s * i - o * h * i - c * r * l + n * h * l + o * r * d - n * s * d) * S, e[4] = _ * S, e[5] = (u * m * i - f * h * i + f * r * d - t * m * d - u * r * v + t * h * v) * S, e[6] = (f * s * i - a * m * i - f * r * l + t * m * l + a * r * v - t * s * v) * S, e[7] = (a * h * i - u * s * i + u * r * l - t * h * l - a * r * d + t * s * d) * S, e[8] = y * S, e[9] = (f * c * i - u * p * i - f * n * d + t * p * d + u * n * v - t * c * v) * S, e[10] = (a * p * i - f * o * i + f * n * l - t * p * l - a * n * v + t * o * v) * S, e[11] = (u * o * i - a * c * i - u * n * l + t * c * l + a * n * d - t * o * d) * S, e[12] = x * S, e[13] = (u * p * r - f * c * r + f * n * h - t * p * h - u * n * m + t * c * m) * S, e[14] = (f * o * r - a * p * r - f * n * s + t * p * s + a * n * m - t * o * m) * S, e[15] = (a * c * r - u * o * r + u * n * s - t * c * s - a * n * h + t * o * h) * S, this
                        }
                    }, {
                        key: "scale",
                        value: function (e) {
                            var t = this.elements,
                                n = e.x,
                                r = e.y,
                                i = e.z;
                            return t[0] *= n, t[4] *= r, t[8] *= i, t[1] *= n, t[5] *= r, t[9] *= i, t[2] *= n, t[6] *= r, t[10] *= i, t[3] *= n, t[7] *= r, t[11] *= i, this
                        }
                    }, {
                        key: "getMaxScaleOnAxis",
                        value: function () {
                            var e = this.elements,
                                t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                                n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                                r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                            return Math.sqrt(Math.max(t, n, r))
                        }
                    }, {
                        key: "makeTranslation",
                        value: function (e, t, n) {
                            return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationX",
                        value: function (e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationY",
                        value: function (e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationZ",
                        value: function (e) {
                            var t = Math.cos(e),
                                n = Math.sin(e);
                            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeRotationAxis",
                        value: function (e, t) {
                            var n = Math.cos(t),
                                r = Math.sin(t),
                                i = 1 - n,
                                a = e.x,
                                o = e.y,
                                s = e.z,
                                l = i * a,
                                u = i * o;
                            return this.set(l * a + n, l * o - r * s, l * s + r * o, 0, l * o + r * s, u * o + n, u * s - r * a, 0, l * s - r * o, u * s + r * a, i * s * s + n, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeScale",
                        value: function (e, t, n) {
                            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "makeShear",
                        value: function (e, t, n, r, i, a) {
                            return this.set(1, n, i, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this
                        }
                    }, {
                        key: "compose",
                        value: function (e, t, n) {
                            var r = this.elements,
                                i = t._x,
                                a = t._y,
                                o = t._z,
                                s = t._w,
                                l = i + i,
                                u = a + a,
                                c = o + o,
                                h = i * l,
                                d = i * u,
                                f = i * c,
                                p = a * u,
                                m = a * c,
                                v = o * c,
                                g = s * l,
                                _ = s * u,
                                y = s * c,
                                x = n.x,
                                M = n.y,
                                S = n.z;
                            return r[0] = (1 - (p + v)) * x, r[1] = (d + y) * x, r[2] = (f - _) * x, r[3] = 0, r[4] = (d - y) * M, r[5] = (1 - (h + v)) * M, r[6] = (m + g) * M, r[7] = 0, r[8] = (f + _) * S, r[9] = (m - g) * S, r[10] = (1 - (h + p)) * S, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this
                        }
                    }, {
                        key: "decompose",
                        value: function (e, t, n) {
                            var r = this.elements,
                                i = Tn.set(r[0], r[1], r[2]).length(),
                                a = Tn.set(r[4], r[5], r[6]).length(),
                                o = Tn.set(r[8], r[9], r[10]).length();
                            this.determinant() < 0 && (i = -i), e.x = r[12], e.y = r[13], e.z = r[14], bn.copy(this);
                            var s = 1 / i,
                                l = 1 / a,
                                u = 1 / o;
                            return bn.elements[0] *= s, bn.elements[1] *= s, bn.elements[2] *= s, bn.elements[4] *= l, bn.elements[5] *= l, bn.elements[6] *= l, bn.elements[8] *= u, bn.elements[9] *= u, bn.elements[10] *= u, t.setFromRotationMatrix(bn), n.x = i, n.y = a, n.z = o, this
                        }
                    }, {
                        key: "makePerspective",
                        value: function (e, t, n, r, i, a) {
                            var o, s, l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : nt,
                                u = this.elements,
                                c = 2 * i / (t - e),
                                h = 2 * i / (n - r),
                                d = (t + e) / (t - e),
                                f = (n + r) / (n - r);
                            if (l === nt) o = -(a + i) / (a - i), s = -2 * a * i / (a - i);
                            else {
                                if (l !== rt) throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
                                o = -a / (a - i), s = -a * i / (a - i)
                            }
                            return u[0] = c, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = f, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = o, u[14] = s, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this
                        }
                    }, {
                        key: "makeOrthographic",
                        value: function (e, t, n, r, i, a) {
                            var o, s, l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : nt,
                                u = this.elements,
                                c = 1 / (t - e),
                                h = 1 / (n - r),
                                d = 1 / (a - i),
                                f = (t + e) * c,
                                p = (n + r) * h;
                            if (l === nt) o = (a + i) * d, s = -2 * d;
                            else {
                                if (l !== rt) throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
                                o = i * d, s = -1 * d
                            }
                            return u[0] = 2 * c, u[4] = 0, u[8] = 0, u[12] = -f, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -p, u[2] = 0, u[6] = 0, u[10] = s, u[14] = -o, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            for (var t = this.elements, n = e.elements, r = 0; r < 16; r++)
                                if (t[r] !== n[r]) return !1;
                            return !0
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = 0; n < 16; n++) this.elements[n] = e[n + t];
                            return this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = this.elements;
                            return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
                        }
                    }]), e
                }(),
                Tn = new Xt,
                bn = new En,
                An = new Xt(0, 0, 0),
                wn = new Xt(1, 1, 1),
                Rn = new Xt,
                Cn = new Xt,
                Ln = new Xt,
                Pn = new En,
                kn = new jt,
                In = function (e) {
                    function t() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t.DEFAULT_ORDER;
                        i(this, t), this.isEuler = !0, this._x = e, this._y = n, this._z = r, this._order = a
                    }
                    return o(t, [{
                        key: "x",
                        get: function () {
                            return this._x
                        },
                        set: function (e) {
                            this._x = e, this._onChangeCallback()
                        }
                    }, {
                        key: "y",
                        get: function () {
                            return this._y
                        },
                        set: function (e) {
                            this._y = e, this._onChangeCallback()
                        }
                    }, {
                        key: "z",
                        get: function () {
                            return this._z
                        },
                        set: function (e) {
                            this._z = e, this._onChangeCallback()
                        }
                    }, {
                        key: "order",
                        get: function () {
                            return this._order
                        },
                        set: function (e) {
                            this._order = e, this._onChangeCallback()
                        }
                    }, {
                        key: "set",
                        value: function (e, t, n) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : this._order;
                            return this._x = e, this._y = t, this._z = n, this._order = r, this._onChangeCallback(), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this._x, this._y, this._z, this._order)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromRotationMatrix",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order,
                                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                r = e.elements,
                                i = r[0],
                                a = r[4],
                                o = r[8],
                                s = r[1],
                                l = r[5],
                                u = r[9],
                                c = r[2],
                                h = r[6],
                                d = r[10];
                            switch (t) {
                                case "XYZ":
                                    this._y = Math.asin(ct(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-a, i)) : (this._x = Math.atan2(h, l), this._z = 0);
                                    break;
                                case "YXZ":
                                    this._x = Math.asin(-ct(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(o, d), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-c, i), this._z = 0);
                                    break;
                                case "ZXY":
                                    this._x = Math.asin(ct(h, -1, 1)), Math.abs(h) < .9999999 ? (this._y = Math.atan2(-c, d), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, i));
                                    break;
                                case "ZYX":
                                    this._y = Math.asin(-ct(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(h, d), this._z = Math.atan2(s, i)) : (this._x = 0, this._z = Math.atan2(-a, l));
                                    break;
                                case "YZX":
                                    this._z = Math.asin(ct(s, -1, 1)), Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, l), this._y = Math.atan2(-c, i)) : (this._x = 0, this._y = Math.atan2(o, d));
                                    break;
                                case "XZY":
                                    this._z = Math.asin(-ct(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(h, l), this._y = Math.atan2(o, i)) : (this._x = Math.atan2(-u, d), this._y = 0);
                                    break;
                                default:
                                    console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
                            }
                            return this._order = t, !0 === n && this._onChangeCallback(), this
                        }
                    }, {
                        key: "setFromQuaternion",
                        value: function (e, t, n) {
                            return Pn.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Pn, t, n)
                        }
                    }, {
                        key: "setFromVector3",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._order;
                            return this.set(e.x, e.y, e.z, t)
                        }
                    }, {
                        key: "reorder",
                        value: function (e) {
                            return kn.setFromEuler(this), this.setFromQuaternion(kn, e)
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this._onChangeCallback(), this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                        }
                    }, {
                        key: "_onChange",
                        value: function (e) {
                            return this._onChangeCallback = e, this
                        }
                    }, {
                        key: "_onChangeCallback",
                        value: function () {}
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this._x;
                                    case 2:
                                        return e.next = 4, this._y;
                                    case 4:
                                        return e.next = 6, this._z;
                                    case 6:
                                        return e.next = 8, this._order;
                                    case 8:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }]), t
                }(Symbol.iterator);
            In.DEFAULT_ORDER = "XYZ";
            var Un = function () {
                    function e() {
                        i(this, e), this.mask = 1
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e) {
                            this.mask = (1 << e | 0) >>> 0
                        }
                    }, {
                        key: "enable",
                        value: function (e) {
                            this.mask |= 1 << e | 0
                        }
                    }, {
                        key: "enableAll",
                        value: function () {
                            this.mask = -1
                        }
                    }, {
                        key: "toggle",
                        value: function (e) {
                            this.mask ^= 1 << e | 0
                        }
                    }, {
                        key: "disable",
                        value: function (e) {
                            this.mask &= ~(1 << e | 0)
                        }
                    }, {
                        key: "disableAll",
                        value: function () {
                            this.mask = 0
                        }
                    }, {
                        key: "test",
                        value: function (e) {
                            return 0 != (this.mask & e.mask)
                        }
                    }, {
                        key: "isEnabled",
                        value: function (e) {
                            return 0 != (this.mask & (1 << e | 0))
                        }
                    }]), e
                }(),
                Dn = 0,
                Nn = new Xt,
                On = new jt,
                Fn = new En,
                Bn = new Xt,
                zn = new Xt,
                Hn = new Xt,
                Gn = new jt,
                Vn = new Xt(1, 0, 0),
                Wn = new Xt(0, 1, 0),
                jn = new Xt(0, 0, 1),
                Xn = {
                    type: "added"
                },
                qn = {
                    type: "removed"
                },
                Yn = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        i(this, n), (e = t.call(this)).isObject3D = !0, Object.defineProperty(M(e), "id", {
                            value: Dn++
                        }), e.uuid = ut(), e.name = "", e.type = "Object3D", e.parent = null, e.children = [], e.up = n.DEFAULT_UP.clone();
                        var r = new Xt,
                            a = new In,
                            o = new jt,
                            s = new Xt(1, 1, 1);
                        return a._onChange((function () {
                            o.setFromEuler(a, !1)
                        })), o._onChange((function () {
                            a.setFromQuaternion(o, void 0, !1)
                        })), Object.defineProperties(M(e), {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: r
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: a
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: o
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: s
                            },
                            modelViewMatrix: {
                                value: new En
                            },
                            normalMatrix: {
                                value: new xt
                            }
                        }), e.matrix = new En, e.matrixWorld = new En, e.matrixAutoUpdate = n.DEFAULT_MATRIX_AUTO_UPDATE, e.matrixWorldNeedsUpdate = !1, e.matrixWorldAutoUpdate = n.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, e.layers = new Un, e.visible = !0, e.castShadow = !1, e.receiveShadow = !1, e.frustumCulled = !0, e.renderOrder = 0, e.animations = [], e.userData = {}, e
                    }
                    return o(n, [{
                        key: "onBeforeRender",
                        value: function () {}
                    }, {
                        key: "onAfterRender",
                        value: function () {}
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
                        }
                    }, {
                        key: "applyQuaternion",
                        value: function (e) {
                            return this.quaternion.premultiply(e), this
                        }
                    }, {
                        key: "setRotationFromAxisAngle",
                        value: function (e, t) {
                            this.quaternion.setFromAxisAngle(e, t)
                        }
                    }, {
                        key: "setRotationFromEuler",
                        value: function (e) {
                            this.quaternion.setFromEuler(e, !0)
                        }
                    }, {
                        key: "setRotationFromMatrix",
                        value: function (e) {
                            this.quaternion.setFromRotationMatrix(e)
                        }
                    }, {
                        key: "setRotationFromQuaternion",
                        value: function (e) {
                            this.quaternion.copy(e)
                        }
                    }, {
                        key: "rotateOnAxis",
                        value: function (e, t) {
                            return On.setFromAxisAngle(e, t), this.quaternion.multiply(On), this
                        }
                    }, {
                        key: "rotateOnWorldAxis",
                        value: function (e, t) {
                            return On.setFromAxisAngle(e, t), this.quaternion.premultiply(On), this
                        }
                    }, {
                        key: "rotateX",
                        value: function (e) {
                            return this.rotateOnAxis(Vn, e)
                        }
                    }, {
                        key: "rotateY",
                        value: function (e) {
                            return this.rotateOnAxis(Wn, e)
                        }
                    }, {
                        key: "rotateZ",
                        value: function (e) {
                            return this.rotateOnAxis(jn, e)
                        }
                    }, {
                        key: "translateOnAxis",
                        value: function (e, t) {
                            return Nn.copy(e).applyQuaternion(this.quaternion), this.position.add(Nn.multiplyScalar(t)), this
                        }
                    }, {
                        key: "translateX",
                        value: function (e) {
                            return this.translateOnAxis(Vn, e)
                        }
                    }, {
                        key: "translateY",
                        value: function (e) {
                            return this.translateOnAxis(Wn, e)
                        }
                    }, {
                        key: "translateZ",
                        value: function (e) {
                            return this.translateOnAxis(jn, e)
                        }
                    }, {
                        key: "localToWorld",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
                        }
                    }, {
                        key: "worldToLocal",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Fn.copy(this.matrixWorld).invert())
                        }
                    }, {
                        key: "lookAt",
                        value: function (e, t, n) {
                            e.isVector3 ? Bn.copy(e) : Bn.set(e, t, n);
                            var r = this.parent;
                            this.updateWorldMatrix(!0, !1), zn.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Fn.lookAt(zn, Bn, this.up) : Fn.lookAt(Bn, zn, this.up), this.quaternion.setFromRotationMatrix(Fn), r && (Fn.extractRotation(r.matrixWorld), On.setFromRotationMatrix(Fn), this.quaternion.premultiply(On.invert()))
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            if (arguments.length > 1) {
                                for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                                return this
                            }
                            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(Xn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                        }
                    }, {
                        key: "remove",
                        value: function (e) {
                            if (arguments.length > 1) {
                                for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                                return this
                            }
                            var n = this.children.indexOf(e);
                            return -1 !== n && (e.parent = null, this.children.splice(n, 1), e.dispatchEvent(qn)), this
                        }
                    }, {
                        key: "removeFromParent",
                        value: function () {
                            var e = this.parent;
                            return null !== e && e.remove(this), this
                        }
                    }, {
                        key: "clear",
                        value: function () {
                            for (var e = 0; e < this.children.length; e++) {
                                var t = this.children[e];
                                t.parent = null, t.dispatchEvent(qn)
                            }
                            return this.children.length = 0, this
                        }
                    }, {
                        key: "attach",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), Fn.copy(this.matrixWorld).invert(), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), Fn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Fn), this.add(e), e.updateWorldMatrix(!1, !0), this
                        }
                    }, {
                        key: "getObjectById",
                        value: function (e) {
                            return this.getObjectByProperty("id", e)
                        }
                    }, {
                        key: "getObjectByName",
                        value: function (e) {
                            return this.getObjectByProperty("name", e)
                        }
                    }, {
                        key: "getObjectByProperty",
                        value: function (e, t) {
                            if (this[e] === t) return this;
                            for (var n = 0, r = this.children.length; n < r; n++) {
                                var i = this.children[n].getObjectByProperty(e, t);
                                if (void 0 !== i) return i
                            }
                        }
                    }, {
                        key: "getObjectsByProperty",
                        value: function (e, t) {
                            var n = [];
                            this[e] === t && n.push(this);
                            for (var r = 0, i = this.children.length; r < i; r++) {
                                var a = this.children[r].getObjectsByProperty(e, t);
                                a.length > 0 && (n = n.concat(a))
                            }
                            return n
                        }
                    }, {
                        key: "getWorldPosition",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
                        }
                    }, {
                        key: "getWorldQuaternion",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zn, e, Hn), e
                        }
                    }, {
                        key: "getWorldScale",
                        value: function (e) {
                            return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(zn, Gn, e), e
                        }
                    }, {
                        key: "getWorldDirection",
                        value: function (e) {
                            this.updateWorldMatrix(!0, !1);
                            var t = this.matrixWorld.elements;
                            return e.set(t[8], t[9], t[10]).normalize()
                        }
                    }, {
                        key: "raycast",
                        value: function () {}
                    }, {
                        key: "traverse",
                        value: function (e) {
                            e(this);
                            for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverse(e)
                        }
                    }, {
                        key: "traverseVisible",
                        value: function (e) {
                            if (!1 !== this.visible) {
                                e(this);
                                for (var t = this.children, n = 0, r = t.length; n < r; n++) t[n].traverseVisible(e)
                            }
                        }
                    }, {
                        key: "traverseAncestors",
                        value: function (e) {
                            var t = this.parent;
                            null !== t && (e(t), t.traverseAncestors(e))
                        }
                    }, {
                        key: "updateMatrix",
                        value: function () {
                            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "updateMatrixWorld",
                        value: function (e) {
                            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                            for (var t = this.children, n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                !0 !== i.matrixWorldAutoUpdate && !0 !== e || i.updateMatrixWorld(e)
                            }
                        }
                    }, {
                        key: "updateWorldMatrix",
                        value: function (e, t) {
                            var n = this.parent;
                            if (!0 === e && null !== n && !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === t)
                                for (var r = this.children, i = 0, a = r.length; i < a; i++) {
                                    var o = r[i];
                                    !0 === o.matrixWorldAutoUpdate && o.updateWorldMatrix(!1, !0)
                                }
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = void 0 === e || "string" == typeof e,
                                n = {};
                            t && (e = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            }, n.metadata = {
                                version: 4.6,
                                type: "Object",
                                generator: "Object3D.toJSON"
                            });
                            var r = {};

                            function i(t, n) {
                                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid
                            }
                            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && !0 !== this.environment.isRenderTargetTexture && (r.environment = this.environment.toJSON(e).uuid);
                            else if (this.isMesh || this.isLine || this.isPoints) {
                                r.geometry = i(e.geometries, this.geometry);
                                var a = this.geometry.parameters;
                                if (void 0 !== a && void 0 !== a.shapes) {
                                    var o = a.shapes;
                                    if (Array.isArray(o))
                                        for (var s = 0, l = o.length; s < l; s++) {
                                            var u = o[s];
                                            i(e.shapes, u)
                                        } else i(e.shapes, o)
                                }
                            }
                            if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (i(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), void 0 !== this.material)
                                if (Array.isArray(this.material)) {
                                    for (var c = [], h = 0, d = this.material.length; h < d; h++) c.push(i(e.materials, this.material[h]));
                                    r.material = c
                                } else r.material = i(e.materials, this.material);
                            if (this.children.length > 0) {
                                r.children = [];
                                for (var f = 0; f < this.children.length; f++) r.children.push(this.children[f].toJSON(e).object)
                            }
                            if (this.animations.length > 0) {
                                r.animations = [];
                                for (var p = 0; p < this.animations.length; p++) {
                                    var m = this.animations[p];
                                    r.animations.push(i(e.animations, m))
                                }
                            }
                            if (t) {
                                var v = T(e.geometries),
                                    g = T(e.materials),
                                    _ = T(e.textures),
                                    y = T(e.images),
                                    x = T(e.shapes),
                                    M = T(e.skeletons),
                                    S = T(e.animations),
                                    E = T(e.nodes);
                                v.length > 0 && (n.geometries = v), g.length > 0 && (n.materials = g), _.length > 0 && (n.textures = _), y.length > 0 && (n.images = y), x.length > 0 && (n.shapes = x), M.length > 0 && (n.skeletons = M), S.length > 0 && (n.animations = S), E.length > 0 && (n.nodes = E)
                            }
                            return n.object = r, n;

                            function T(e) {
                                var t = [];
                                for (var n in e) {
                                    var r = e[n];
                                    delete r.metadata, t.push(r)
                                }
                                return t
                            }
                        }
                    }, {
                        key: "clone",
                        value: function (e) {
                            return (new this.constructor).copy(this, e)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                            if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), !0 === t)
                                for (var n = 0; n < e.children.length; n++) {
                                    var r = e.children[n];
                                    this.add(r.clone())
                                }
                            return this
                        }
                    }]), n
                }(it);
            Yn.DEFAULT_UP = new Xt(0, 1, 0), Yn.DEFAULT_MATRIX_AUTO_UPDATE = !0, Yn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
            var Kn = new Xt,
                Zn = new Xt,
                Jn = new Xt,
                Qn = new Xt,
                $n = new Xt,
                er = new Xt,
                tr = new Xt,
                nr = new Xt,
                rr = new Xt,
                ir = new Xt,
                ar = !1,
                or = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xt,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Xt,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new Xt;
                        i(this, e), this.a = t, this.b = n, this.c = r
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t, n) {
                            return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
                        }
                    }, {
                        key: "setFromPointsAndIndices",
                        value: function (e, t, n, r) {
                            return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[r]), this
                        }
                    }, {
                        key: "setFromAttributeAndIndices",
                        value: function (e, t, n, r) {
                            return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, r), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                        }
                    }, {
                        key: "getArea",
                        value: function () {
                            return Kn.subVectors(this.c, this.b), Zn.subVectors(this.a, this.b), .5 * Kn.cross(Zn).length()
                        }
                    }, {
                        key: "getMidpoint",
                        value: function (e) {
                            return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                        }
                    }, {
                        key: "getNormal",
                        value: function (t) {
                            return e.getNormal(this.a, this.b, this.c, t)
                        }
                    }, {
                        key: "getPlane",
                        value: function (e) {
                            return e.setFromCoplanarPoints(this.a, this.b, this.c)
                        }
                    }, {
                        key: "getBarycoord",
                        value: function (t, n) {
                            return e.getBarycoord(t, this.a, this.b, this.c, n)
                        }
                    }, {
                        key: "getUV",
                        value: function (t, n, r, i, a) {
                            return !1 === ar && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ar = !0), e.getInterpolation(t, this.a, this.b, this.c, n, r, i, a)
                        }
                    }, {
                        key: "getInterpolation",
                        value: function (t, n, r, i, a) {
                            return e.getInterpolation(t, this.a, this.b, this.c, n, r, i, a)
                        }
                    }, {
                        key: "containsPoint",
                        value: function (t) {
                            return e.containsPoint(t, this.a, this.b, this.c)
                        }
                    }, {
                        key: "isFrontFacing",
                        value: function (t) {
                            return e.isFrontFacing(this.a, this.b, this.c, t)
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            return e.intersectsTriangle(this)
                        }
                    }, {
                        key: "closestPointToPoint",
                        value: function (e, t) {
                            var n, r, i = this.a,
                                a = this.b,
                                o = this.c;
                            $n.subVectors(a, i), er.subVectors(o, i), nr.subVectors(e, i);
                            var s = $n.dot(nr),
                                l = er.dot(nr);
                            if (s <= 0 && l <= 0) return t.copy(i);
                            rr.subVectors(e, a);
                            var u = $n.dot(rr),
                                c = er.dot(rr);
                            if (u >= 0 && c <= u) return t.copy(a);
                            var h = s * c - u * l;
                            if (h <= 0 && s >= 0 && u <= 0) return n = s / (s - u), t.copy(i).addScaledVector($n, n);
                            ir.subVectors(e, o);
                            var d = $n.dot(ir),
                                f = er.dot(ir);
                            if (f >= 0 && d <= f) return t.copy(o);
                            var p = d * l - s * f;
                            if (p <= 0 && l >= 0 && f <= 0) return r = l / (l - f), t.copy(i).addScaledVector(er, r);
                            var m = u * f - d * c;
                            if (m <= 0 && c - u >= 0 && d - f >= 0) return tr.subVectors(o, a), r = (c - u) / (c - u + (d - f)), t.copy(a).addScaledVector(tr, r);
                            var v = 1 / (m + p + h);
                            return n = p * v, r = h * v, t.copy(i).addScaledVector($n, n).addScaledVector(er, r)
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                        }
                    }], [{
                        key: "getNormal",
                        value: function (e, t, n, r) {
                            r.subVectors(n, t), Kn.subVectors(e, t), r.cross(Kn);
                            var i = r.lengthSq();
                            return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
                        }
                    }, {
                        key: "getBarycoord",
                        value: function (e, t, n, r, i) {
                            Kn.subVectors(r, t), Zn.subVectors(n, t), Jn.subVectors(e, t);
                            var a = Kn.dot(Kn),
                                o = Kn.dot(Zn),
                                s = Kn.dot(Jn),
                                l = Zn.dot(Zn),
                                u = Zn.dot(Jn),
                                c = a * l - o * o;
                            if (0 === c) return i.set(-2, -1, -1);
                            var h = 1 / c,
                                d = (l * s - o * u) * h,
                                f = (a * u - o * s) * h;
                            return i.set(1 - d - f, f, d)
                        }
                    }, {
                        key: "containsPoint",
                        value: function (e, t, n, r) {
                            return this.getBarycoord(e, t, n, r, Qn), Qn.x >= 0 && Qn.y >= 0 && Qn.x + Qn.y <= 1
                        }
                    }, {
                        key: "getUV",
                        value: function (e, t, n, r, i, a, o, s) {
                            return !1 === ar && (console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."), ar = !0), this.getInterpolation(e, t, n, r, i, a, o, s)
                        }
                    }, {
                        key: "getInterpolation",
                        value: function (e, t, n, r, i, a, o, s) {
                            return this.getBarycoord(e, t, n, r, Qn), s.setScalar(0), s.addScaledVector(i, Qn.x), s.addScaledVector(a, Qn.y), s.addScaledVector(o, Qn.z), s
                        }
                    }, {
                        key: "isFrontFacing",
                        value: function (e, t, n, r) {
                            return Kn.subVectors(n, t), Zn.subVectors(e, t), Kn.cross(Zn).dot(r) < 0
                        }
                    }]), e
                }(),
                sr = 0,
                lr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isMaterial = !0, Object.defineProperty(M(e), "id", {
                            value: sr++
                        }), e.uuid = ut(), e.name = "", e.type = "Material", e.blending = 1, e.side = 0, e.vertexColors = !1, e.opacity = 1, e.transparent = !1, e.alphaHash = !1, e.blendSrc = 204, e.blendDst = 205, e.blendEquation = N, e.blendSrcAlpha = null, e.blendDstAlpha = null, e.blendEquationAlpha = null, e.depthFunc = 3, e.depthTest = !0, e.depthWrite = !0, e.stencilWriteMask = 255, e.stencilFunc = 519, e.stencilRef = 0, e.stencilFuncMask = 255, e.stencilFail = Qe, e.stencilZFail = Qe, e.stencilZPass = Qe, e.stencilWrite = !1, e.clippingPlanes = null, e.clipIntersection = !1, e.clipShadows = !1, e.shadowSide = null, e.colorWrite = !0, e.precision = null, e.polygonOffset = !1, e.polygonOffsetFactor = 0, e.polygonOffsetUnits = 0, e.dithering = !1, e.alphaToCoverage = !1, e.premultipliedAlpha = !1, e.forceSinglePass = !1, e.visible = !0, e.toneMapped = !0, e.userData = {}, e.version = 0, e._alphaTest = 0, e
                    }
                    return o(n, [{
                        key: "alphaTest",
                        get: function () {
                            return this._alphaTest
                        },
                        set: function (e) {
                            this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
                        }
                    }, {
                        key: "onBuild",
                        value: function () {}
                    }, {
                        key: "onBeforeRender",
                        value: function () {}
                    }, {
                        key: "onBeforeCompile",
                        value: function () {}
                    }, {
                        key: "customProgramCacheKey",
                        value: function () {
                            return this.onBeforeCompile.toString()
                        }
                    }, {
                        key: "setValues",
                        value: function (e) {
                            if (void 0 !== e)
                                for (var t in e) {
                                    var n = e[t];
                                    if (void 0 !== n) {
                                        var r = this[t];
                                        void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE.Material: '".concat(t, "' is not a property of THREE.").concat(this.type, "."))
                                    } else console.warn("THREE.Material: parameter '".concat(t, "' has value of undefined."))
                                }
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = void 0 === e || "string" == typeof e;
                            t && (e = {
                                textures: {},
                                images: {}
                            });
                            var n = {
                                metadata: {
                                    version: 4.6,
                                    type: "Material",
                                    generator: "Material.toJSON"
                                }
                            };

                            function r(e) {
                                var t = [];
                                for (var n in e) {
                                    var r = e[n];
                                    delete r.metadata, t.push(r)
                                }
                                return t
                            }
                            if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), void 0 !== this.sheen && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), void 0 !== this.iridescence && (n.iridescence = this.iridescence), void 0 !== this.iridescenceIOR && (n.iridescenceIOR = this.iridescenceIOR), void 0 !== this.iridescenceThicknessRange && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy), void 0 !== this.anisotropyRotation && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, void 0 !== this.combine && (n.combine = this.combine)), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), void 0 !== this.transmission && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), void 0 !== this.thickness && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), void 0 !== this.attenuationDistance && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (n.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (n.size = this.size), null !== this.shadowSide && (n.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), 0 !== this.side && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, void 0 !== this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), void 0 !== this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.alphaHash && (n.alphaHash = this.alphaHash), !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.forceSinglePass && (n.forceSinglePass = this.forceSinglePass), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (n.flatShading = this.flatShading), !1 === this.visible && (n.visible = !1), !1 === this.toneMapped && (n.toneMapped = !1), !1 === this.fog && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData), t) {
                                var i = r(e.textures),
                                    a = r(e.images);
                                i.length > 0 && (n.textures = i), a.length > 0 && (n.images = a)
                            }
                            return n
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
                            var t = e.clippingPlanes,
                                n = null;
                            if (null !== t) {
                                var r = t.length;
                                n = new Array(r);
                                for (var i = 0; i !== r; ++i) n[i] = t[i].clone()
                            }
                            return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }, {
                        key: "needsUpdate",
                        set: function (e) {
                            !0 === e && this.version++
                        }
                    }]), n
                }(it),
                ur = {
                    aliceblue: 15792383,
                    antiquewhite: 16444375,
                    aqua: 65535,
                    aquamarine: 8388564,
                    azure: 15794175,
                    beige: 16119260,
                    bisque: 16770244,
                    black: 0,
                    blanchedalmond: 16772045,
                    blue: 255,
                    blueviolet: 9055202,
                    brown: 10824234,
                    burlywood: 14596231,
                    cadetblue: 6266528,
                    chartreuse: 8388352,
                    chocolate: 13789470,
                    coral: 16744272,
                    cornflowerblue: 6591981,
                    cornsilk: 16775388,
                    crimson: 14423100,
                    cyan: 65535,
                    darkblue: 139,
                    darkcyan: 35723,
                    darkgoldenrod: 12092939,
                    darkgray: 11119017,
                    darkgreen: 25600,
                    darkgrey: 11119017,
                    darkkhaki: 12433259,
                    darkmagenta: 9109643,
                    darkolivegreen: 5597999,
                    darkorange: 16747520,
                    darkorchid: 10040012,
                    darkred: 9109504,
                    darksalmon: 15308410,
                    darkseagreen: 9419919,
                    darkslateblue: 4734347,
                    darkslategray: 3100495,
                    darkslategrey: 3100495,
                    darkturquoise: 52945,
                    darkviolet: 9699539,
                    deeppink: 16716947,
                    deepskyblue: 49151,
                    dimgray: 6908265,
                    dimgrey: 6908265,
                    dodgerblue: 2003199,
                    firebrick: 11674146,
                    floralwhite: 16775920,
                    forestgreen: 2263842,
                    fuchsia: 16711935,
                    gainsboro: 14474460,
                    ghostwhite: 16316671,
                    gold: 16766720,
                    goldenrod: 14329120,
                    gray: 8421504,
                    green: 32768,
                    greenyellow: 11403055,
                    grey: 8421504,
                    honeydew: 15794160,
                    hotpink: 16738740,
                    indianred: 13458524,
                    indigo: 4915330,
                    ivory: 16777200,
                    khaki: 15787660,
                    lavender: 15132410,
                    lavenderblush: 16773365,
                    lawngreen: 8190976,
                    lemonchiffon: 16775885,
                    lightblue: 11393254,
                    lightcoral: 15761536,
                    lightcyan: 14745599,
                    lightgoldenrodyellow: 16448210,
                    lightgray: 13882323,
                    lightgreen: 9498256,
                    lightgrey: 13882323,
                    lightpink: 16758465,
                    lightsalmon: 16752762,
                    lightseagreen: 2142890,
                    lightskyblue: 8900346,
                    lightslategray: 7833753,
                    lightslategrey: 7833753,
                    lightsteelblue: 11584734,
                    lightyellow: 16777184,
                    lime: 65280,
                    limegreen: 3329330,
                    linen: 16445670,
                    magenta: 16711935,
                    maroon: 8388608,
                    mediumaquamarine: 6737322,
                    mediumblue: 205,
                    mediumorchid: 12211667,
                    mediumpurple: 9662683,
                    mediumseagreen: 3978097,
                    mediumslateblue: 8087790,
                    mediumspringgreen: 64154,
                    mediumturquoise: 4772300,
                    mediumvioletred: 13047173,
                    midnightblue: 1644912,
                    mintcream: 16121850,
                    mistyrose: 16770273,
                    moccasin: 16770229,
                    navajowhite: 16768685,
                    navy: 128,
                    oldlace: 16643558,
                    olive: 8421376,
                    olivedrab: 7048739,
                    orange: 16753920,
                    orangered: 16729344,
                    orchid: 14315734,
                    palegoldenrod: 15657130,
                    palegreen: 10025880,
                    paleturquoise: 11529966,
                    palevioletred: 14381203,
                    papayawhip: 16773077,
                    peachpuff: 16767673,
                    peru: 13468991,
                    pink: 16761035,
                    plum: 14524637,
                    powderblue: 11591910,
                    purple: 8388736,
                    rebeccapurple: 6697881,
                    red: 16711680,
                    rosybrown: 12357519,
                    royalblue: 4286945,
                    saddlebrown: 9127187,
                    salmon: 16416882,
                    sandybrown: 16032864,
                    seagreen: 3050327,
                    seashell: 16774638,
                    sienna: 10506797,
                    silver: 12632256,
                    skyblue: 8900331,
                    slateblue: 6970061,
                    slategray: 7372944,
                    slategrey: 7372944,
                    snow: 16775930,
                    springgreen: 65407,
                    steelblue: 4620980,
                    tan: 13808780,
                    teal: 32896,
                    thistle: 14204888,
                    tomato: 16737095,
                    turquoise: 4251856,
                    violet: 15631086,
                    wheat: 16113331,
                    white: 16777215,
                    whitesmoke: 16119285,
                    yellow: 16776960,
                    yellowgreen: 10145074
                },
                cr = {
                    h: 0,
                    s: 0,
                    l: 0
                },
                hr = {
                    h: 0,
                    s: 0,
                    l: 0
                };

            function dr(e, t, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
            }
            var fr = function (e) {
                    function t(e, n, r) {
                        return i(this, t), this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, n, r)
                    }
                    return o(t, [{
                        key: "set",
                        value: function (e, t, n) {
                            if (void 0 === t && void 0 === n) {
                                var r = e;
                                r && r.isColor ? this.copy(r) : "number" == typeof r ? this.setHex(r) : "string" == typeof r && this.setStyle(r)
                            } else this.setRGB(e, t, n);
                            return this
                        }
                    }, {
                        key: "setScalar",
                        value: function (e) {
                            return this.r = e, this.g = e, this.b = e, this
                        }
                    }, {
                        key: "setHex",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ke;
                            return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, It.toWorkingColorSpace(this, t), this
                        }
                    }, {
                        key: "setRGB",
                        value: function (e, t, n) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : It.workingColorSpace;
                            return this.r = e, this.g = t, this.b = n, It.toWorkingColorSpace(this, r), this
                        }
                    }, {
                        key: "setHSL",
                        value: function (e, t, n) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : It.workingColorSpace;
                            if (e = ht(e, 1), t = ct(t, 0, 1), n = ct(n, 0, 1), 0 === t) this.r = this.g = this.b = n;
                            else {
                                var i = n <= .5 ? n * (1 + t) : n + t - n * t,
                                    a = 2 * n - i;
                                this.r = dr(a, i, e + 1 / 3), this.g = dr(a, i, e), this.b = dr(a, i, e - 1 / 3)
                            }
                            return It.toWorkingColorSpace(this, r), this
                        }
                    }, {
                        key: "setStyle",
                        value: function (e) {
                            var t, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ke;

                            function r(t) {
                                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                            }
                            if (t = /^(\w+)\(([^\)]*)\)/.exec(e)) {
                                var i, a = t[1],
                                    o = t[2];
                                switch (a) {
                                    case "rgb":
                                    case "rgba":
                                        if (i = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(i[4]), this.setRGB(Math.min(255, parseInt(i[1], 10)) / 255, Math.min(255, parseInt(i[2], 10)) / 255, Math.min(255, parseInt(i[3], 10)) / 255, n);
                                        if (i = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(i[4]), this.setRGB(Math.min(100, parseInt(i[1], 10)) / 100, Math.min(100, parseInt(i[2], 10)) / 100, Math.min(100, parseInt(i[3], 10)) / 100, n);
                                        break;
                                    case "hsl":
                                    case "hsla":
                                        if (i = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return r(i[4]), this.setHSL(parseFloat(i[1]) / 360, parseFloat(i[2]) / 100, parseFloat(i[3]) / 100, n);
                                        break;
                                    default:
                                        console.warn("THREE.Color: Unknown color model " + e)
                                }
                            } else if (t = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                                var s = t[1],
                                    l = s.length;
                                if (3 === l) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, n);
                                if (6 === l) return this.setHex(parseInt(s, 16), n);
                                console.warn("THREE.Color: Invalid hex color " + e)
                            } else if (e && e.length > 0) return this.setColorName(e, n);
                            return this
                        }
                    }, {
                        key: "setColorName",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ke,
                                n = ur[e.toLowerCase()];
                            return void 0 !== n ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this.r, this.g, this.b)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.r = e.r, this.g = e.g, this.b = e.b, this
                        }
                    }, {
                        key: "copySRGBToLinear",
                        value: function (e) {
                            return this.r = At(e.r), this.g = At(e.g), this.b = At(e.b), this
                        }
                    }, {
                        key: "copyLinearToSRGB",
                        value: function (e) {
                            return this.r = wt(e.r), this.g = wt(e.g), this.b = wt(e.b), this
                        }
                    }, {
                        key: "convertSRGBToLinear",
                        value: function () {
                            return this.copySRGBToLinear(this), this
                        }
                    }, {
                        key: "convertLinearToSRGB",
                        value: function () {
                            return this.copyLinearToSRGB(this), this
                        }
                    }, {
                        key: "getHex",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ke;
                            return It.fromWorkingColorSpace(pr.copy(this), e), 65536 * Math.round(ct(255 * pr.r, 0, 255)) + 256 * Math.round(ct(255 * pr.g, 0, 255)) + Math.round(ct(255 * pr.b, 0, 255))
                        }
                    }, {
                        key: "getHexString",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ke;
                            return ("000000" + this.getHex(e).toString(16)).slice(-6)
                        }
                    }, {
                        key: "getHSL",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : It.workingColorSpace;
                            It.fromWorkingColorSpace(pr.copy(this), t);
                            var n, r, i = pr.r,
                                a = pr.g,
                                o = pr.b,
                                s = Math.max(i, a, o),
                                l = Math.min(i, a, o),
                                u = (l + s) / 2;
                            if (l === s) n = 0, r = 0;
                            else {
                                var c = s - l;
                                switch (r = u <= .5 ? c / (s + l) : c / (2 - s - l), s) {
                                    case i:
                                        n = (a - o) / c + (a < o ? 6 : 0);
                                        break;
                                    case a:
                                        n = (o - i) / c + 2;
                                        break;
                                    case o:
                                        n = (i - a) / c + 4
                                }
                                n /= 6
                            }
                            return e.h = n, e.s = r, e.l = u, e
                        }
                    }, {
                        key: "getRGB",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : It.workingColorSpace;
                            return It.fromWorkingColorSpace(pr.copy(this), t), e.r = pr.r, e.g = pr.g, e.b = pr.b, e
                        }
                    }, {
                        key: "getStyle",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ke;
                            It.fromWorkingColorSpace(pr.copy(this), e);
                            var t = pr.r,
                                n = pr.g,
                                r = pr.b;
                            return e !== Ke ? "color(".concat(e, " ").concat(t.toFixed(3), " ").concat(n.toFixed(3), " ").concat(r.toFixed(3), ")") : "rgb(".concat(Math.round(255 * t), ",").concat(Math.round(255 * n), ",").concat(Math.round(255 * r), ")")
                        }
                    }, {
                        key: "offsetHSL",
                        value: function (e, t, n) {
                            return this.getHSL(cr), cr.h += e, cr.s += t, cr.l += n, this.setHSL(cr.h, cr.s, cr.l), this
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            return this.r += e.r, this.g += e.g, this.b += e.b, this
                        }
                    }, {
                        key: "addColors",
                        value: function (e, t) {
                            return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                        }
                    }, {
                        key: "addScalar",
                        value: function (e) {
                            return this.r += e, this.g += e, this.b += e, this
                        }
                    }, {
                        key: "sub",
                        value: function (e) {
                            return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
                        }
                    }, {
                        key: "multiply",
                        value: function (e) {
                            return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                        }
                    }, {
                        key: "multiplyScalar",
                        value: function (e) {
                            return this.r *= e, this.g *= e, this.b *= e, this
                        }
                    }, {
                        key: "lerp",
                        value: function (e, t) {
                            return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                        }
                    }, {
                        key: "lerpColors",
                        value: function (e, t, n) {
                            return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
                        }
                    }, {
                        key: "lerpHSL",
                        value: function (e, t) {
                            this.getHSL(cr), e.getHSL(hr);
                            var n = dt(cr.h, hr.h, t),
                                r = dt(cr.s, hr.s, t),
                                i = dt(cr.l, hr.l, t);
                            return this.setHSL(n, r, i), this
                        }
                    }, {
                        key: "setFromVector3",
                        value: function (e) {
                            return this.r = e.x, this.g = e.y, this.b = e.z, this
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function (e) {
                            var t = this.r,
                                n = this.g,
                                r = this.b,
                                i = e.elements;
                            return this.r = i[0] * t + i[3] * n + i[6] * r, this.g = i[1] * t + i[4] * n + i[7] * r, this.b = i[2] * t + i[5] * n + i[8] * r, this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.r === this.r && e.g === this.g && e.b === this.b
                        }
                    }, {
                        key: "fromArray",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                        }
                    }, {
                        key: "toArray",
                        value: function () {
                            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                        }
                    }, {
                        key: "fromBufferAttribute",
                        value: function (e, t) {
                            return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            return this.getHex()
                        }
                    }, {
                        key: e,
                        value: w().mark((function e() {
                            return w().wrap((function (e) {
                                for (;;) switch (e.prev = e.next) {
                                    case 0:
                                        return e.next = 2, this.r;
                                    case 2:
                                        return e.next = 4, this.g;
                                    case 4:
                                        return e.next = 6, this.b;
                                    case 6:
                                    case "end":
                                        return e.stop()
                                }
                            }), e, this)
                        }))
                    }]), t
                }(Symbol.iterator),
                pr = new fr;
            fr.NAMES = ur;
            var mr = function (e) {
                E(n, e);
                var t = b(n);

                function n(e) {
                    var r;
                    return i(this, n), (r = t.call(this)).isMeshBasicMaterial = !0, r.type = "MeshBasicMaterial", r.color = new fr(16777215), r.map = null, r.lightMap = null, r.lightMapIntensity = 1, r.aoMap = null, r.aoMapIntensity = 1, r.specularMap = null, r.alphaMap = null, r.envMap = null, r.combine = 0, r.reflectivity = 1, r.refractionRatio = .98, r.wireframe = !1, r.wireframeLinewidth = 1, r.wireframeLinecap = "round", r.wireframeLinejoin = "round", r.fog = !0, r.setValues(e), r
                }
                return o(n, [{
                    key: "copy",
                    value: function (e) {
                        return g(y(n.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
                    }
                }]), n
            }(lr);
            var vr = new Xt,
                gr = new yt,
                _r = function () {
                    function e(t, n) {
                        var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                        if (i(this, e), Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                        this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = n, this.count = void 0 !== t ? t.length / n : 0, this.normalized = r, this.usage = $e, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.gpuType = te, this.version = 0
                    }
                    return o(e, [{
                        key: "onUploadCallback",
                        value: function () {}
                    }, {
                        key: "needsUpdate",
                        set: function (e) {
                            !0 === e && this.version++
                        }
                    }, {
                        key: "setUsage",
                        value: function (e) {
                            return this.usage = e, this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
                        }
                    }, {
                        key: "copyAt",
                        value: function (e, t, n) {
                            e *= this.itemSize, n *= t.itemSize;
                            for (var r = 0, i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
                            return this
                        }
                    }, {
                        key: "copyArray",
                        value: function (e) {
                            return this.array.set(e), this
                        }
                    }, {
                        key: "applyMatrix3",
                        value: function (e) {
                            if (2 === this.itemSize)
                                for (var t = 0, n = this.count; t < n; t++) gr.fromBufferAttribute(this, t), gr.applyMatrix3(e), this.setXY(t, gr.x, gr.y);
                            else if (3 === this.itemSize)
                                for (var r = 0, i = this.count; r < i; r++) vr.fromBufferAttribute(this, r), vr.applyMatrix3(e), this.setXYZ(r, vr.x, vr.y, vr.z);
                            return this
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            for (var t = 0, n = this.count; t < n; t++) vr.fromBufferAttribute(this, t), vr.applyMatrix4(e), this.setXYZ(t, vr.x, vr.y, vr.z);
                            return this
                        }
                    }, {
                        key: "applyNormalMatrix",
                        value: function (e) {
                            for (var t = 0, n = this.count; t < n; t++) vr.fromBufferAttribute(this, t), vr.applyNormalMatrix(e), this.setXYZ(t, vr.x, vr.y, vr.z);
                            return this
                        }
                    }, {
                        key: "transformDirection",
                        value: function (e) {
                            for (var t = 0, n = this.count; t < n; t++) vr.fromBufferAttribute(this, t), vr.transformDirection(e), this.setXYZ(t, vr.x, vr.y, vr.z);
                            return this
                        }
                    }, {
                        key: "set",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.array.set(e, t), this
                        }
                    }, {
                        key: "getComponent",
                        value: function (e, t) {
                            var n = this.array[e * this.itemSize + t];
                            return this.normalized && (n = vt(n, this.array)), n
                        }
                    }, {
                        key: "setComponent",
                        value: function (e, t, n) {
                            return this.normalized && (n = gt(n, this.array)), this.array[e * this.itemSize + t] = n, this
                        }
                    }, {
                        key: "getX",
                        value: function (e) {
                            var t = this.array[e * this.itemSize];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "setX",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.array[e * this.itemSize] = t, this
                        }
                    }, {
                        key: "getY",
                        value: function (e) {
                            var t = this.array[e * this.itemSize + 1];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "setY",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.array[e * this.itemSize + 1] = t, this
                        }
                    }, {
                        key: "getZ",
                        value: function (e) {
                            var t = this.array[e * this.itemSize + 2];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "setZ",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.array[e * this.itemSize + 2] = t, this
                        }
                    }, {
                        key: "getW",
                        value: function (e) {
                            var t = this.array[e * this.itemSize + 3];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "setW",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.array[e * this.itemSize + 3] = t, this
                        }
                    }, {
                        key: "setXY",
                        value: function (e, t, n) {
                            return e *= this.itemSize, this.normalized && (t = gt(t, this.array), n = gt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
                        }
                    }, {
                        key: "setXYZ",
                        value: function (e, t, n, r) {
                            return e *= this.itemSize, this.normalized && (t = gt(t, this.array), n = gt(n, this.array), r = gt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this
                        }
                    }, {
                        key: "setXYZW",
                        value: function (e, t, n, r, i) {
                            return e *= this.itemSize, this.normalized && (t = gt(t, this.array), n = gt(n, this.array), r = gt(r, this.array), i = gt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = r, this.array[e + 3] = i, this
                        }
                    }, {
                        key: "onUpload",
                        value: function (e) {
                            return this.onUploadCallback = e, this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new this.constructor(this.array, this.itemSize).copy(this)
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: Array.from(this.array),
                                normalized: this.normalized
                            };
                            return "" !== this.name && (e.name = this.name), this.usage !== $e && (e.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange), e
                        }
                    }]), e
                }(),
                yr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        return i(this, n), t.call(this, new Uint16Array(e), r, a)
                    }
                    return o(n)
                }(_r),
                xr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        return i(this, n), t.call(this, new Uint32Array(e), r, a)
                    }
                    return o(n)
                }(_r),
                Mr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        return i(this, n), t.call(this, new Float32Array(e), r, a)
                    }
                    return o(n)
                }(_r),
                Sr = 0,
                Er = new En,
                Tr = new Yn,
                br = new Xt,
                Ar = new Kt,
                wr = new Kt,
                Rr = new Xt,
                Cr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isBufferGeometry = !0, Object.defineProperty(M(e), "id", {
                            value: Sr++
                        }), e.uuid = ut(), e.name = "", e.type = "BufferGeometry", e.index = null, e.attributes = {}, e.morphAttributes = {}, e.morphTargetsRelative = !1, e.groups = [], e.boundingBox = null, e.boundingSphere = null, e.drawRange = {
                            start: 0,
                            count: 1 / 0
                        }, e.userData = {}, e
                    }
                    return o(n, [{
                        key: "getIndex",
                        value: function () {
                            return this.index
                        }
                    }, {
                        key: "setIndex",
                        value: function (e) {
                            return Array.isArray(e) ? this.index = new(St(e) ? xr : yr)(e, 1) : this.index = e, this
                        }
                    }, {
                        key: "getAttribute",
                        value: function (e) {
                            return this.attributes[e]
                        }
                    }, {
                        key: "setAttribute",
                        value: function (e, t) {
                            return this.attributes[e] = t, this
                        }
                    }, {
                        key: "deleteAttribute",
                        value: function (e) {
                            return delete this.attributes[e], this
                        }
                    }, {
                        key: "hasAttribute",
                        value: function (e) {
                            return void 0 !== this.attributes[e]
                        }
                    }, {
                        key: "addGroup",
                        value: function (e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                            this.groups.push({
                                start: e,
                                count: t,
                                materialIndex: n
                            })
                        }
                    }, {
                        key: "clearGroups",
                        value: function () {
                            this.groups = []
                        }
                    }, {
                        key: "setDrawRange",
                        value: function (e, t) {
                            this.drawRange.start = e, this.drawRange.count = t
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            var t = this.attributes.position;
                            void 0 !== t && (t.applyMatrix4(e), t.needsUpdate = !0);
                            var n = this.attributes.normal;
                            if (void 0 !== n) {
                                var r = (new xt).getNormalMatrix(e);
                                n.applyNormalMatrix(r), n.needsUpdate = !0
                            }
                            var i = this.attributes.tangent;
                            return void 0 !== i && (i.transformDirection(e), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                        }
                    }, {
                        key: "applyQuaternion",
                        value: function (e) {
                            return Er.makeRotationFromQuaternion(e), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "rotateX",
                        value: function (e) {
                            return Er.makeRotationX(e), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "rotateY",
                        value: function (e) {
                            return Er.makeRotationY(e), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "rotateZ",
                        value: function (e) {
                            return Er.makeRotationZ(e), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "translate",
                        value: function (e, t, n) {
                            return Er.makeTranslation(e, t, n), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "scale",
                        value: function (e, t, n) {
                            return Er.makeScale(e, t, n), this.applyMatrix4(Er), this
                        }
                    }, {
                        key: "lookAt",
                        value: function (e) {
                            return Tr.lookAt(e), Tr.updateMatrix(), this.applyMatrix4(Tr.matrix), this
                        }
                    }, {
                        key: "center",
                        value: function () {
                            return this.computeBoundingBox(), this.boundingBox.getCenter(br).negate(), this.translate(br.x, br.y, br.z), this
                        }
                    }, {
                        key: "setFromPoints",
                        value: function (e) {
                            for (var t = [], n = 0, r = e.length; n < r; n++) {
                                var i = e[n];
                                t.push(i.x, i.y, i.z || 0)
                            }
                            return this.setAttribute("position", new Mr(t, 3)), this
                        }
                    }, {
                        key: "computeBoundingBox",
                        value: function () {
                            null === this.boundingBox && (this.boundingBox = new Kt);
                            var e = this.attributes.position,
                                t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new Xt(-1 / 0, -1 / 0, -1 / 0), new Xt(1 / 0, 1 / 0, 1 / 0));
                            if (void 0 !== e) {
                                if (this.boundingBox.setFromBufferAttribute(e), t)
                                    for (var n = 0, r = t.length; n < r; n++) {
                                        var i = t[n];
                                        Ar.setFromBufferAttribute(i), this.morphTargetsRelative ? (Rr.addVectors(this.boundingBox.min, Ar.min), this.boundingBox.expandByPoint(Rr), Rr.addVectors(this.boundingBox.max, Ar.max), this.boundingBox.expandByPoint(Rr)) : (this.boundingBox.expandByPoint(Ar.min), this.boundingBox.expandByPoint(Ar.max))
                                    }
                            } else this.boundingBox.makeEmpty();
                            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                    }, {
                        key: "computeBoundingSphere",
                        value: function () {
                            null === this.boundingSphere && (this.boundingSphere = new pn);
                            var e = this.attributes.position,
                                t = this.morphAttributes.position;
                            if (e && e.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new Xt, 1 / 0);
                            if (e) {
                                var n = this.boundingSphere.center;
                                if (Ar.setFromBufferAttribute(e), t)
                                    for (var r = 0, i = t.length; r < i; r++) {
                                        var a = t[r];
                                        wr.setFromBufferAttribute(a), this.morphTargetsRelative ? (Rr.addVectors(Ar.min, wr.min), Ar.expandByPoint(Rr), Rr.addVectors(Ar.max, wr.max), Ar.expandByPoint(Rr)) : (Ar.expandByPoint(wr.min), Ar.expandByPoint(wr.max))
                                    }
                                Ar.getCenter(n);
                                for (var o = 0, s = 0, l = e.count; s < l; s++) Rr.fromBufferAttribute(e, s), o = Math.max(o, n.distanceToSquared(Rr));
                                if (t)
                                    for (var u = 0, c = t.length; u < c; u++)
                                        for (var h = t[u], d = this.morphTargetsRelative, f = 0, p = h.count; f < p; f++) Rr.fromBufferAttribute(h, f), d && (br.fromBufferAttribute(e, f), Rr.add(br)), o = Math.max(o, n.distanceToSquared(Rr));
                                this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                    }, {
                        key: "computeTangents",
                        value: function () {
                            var e = this.index,
                                t = this.attributes;
                            if (null !== e && void 0 !== t.position && void 0 !== t.normal && void 0 !== t.uv) {
                                var n = e.array,
                                    r = t.position.array,
                                    i = t.normal.array,
                                    a = t.uv.array,
                                    o = r.length / 3;
                                !1 === this.hasAttribute("tangent") && this.setAttribute("tangent", new _r(new Float32Array(4 * o), 4));
                                for (var s = this.getAttribute("tangent").array, l = [], u = [], c = 0; c < o; c++) l[c] = new Xt, u[c] = new Xt;
                                var h = new Xt,
                                    d = new Xt,
                                    f = new Xt,
                                    p = new yt,
                                    m = new yt,
                                    v = new yt,
                                    g = new Xt,
                                    _ = new Xt,
                                    y = this.groups;
                                0 === y.length && (y = [{
                                    start: 0,
                                    count: n.length
                                }]);
                                for (var x = 0, M = y.length; x < M; ++x)
                                    for (var S = y[x], E = S.start, T = E, b = E + S.count; T < b; T += 3) N(n[T + 0], n[T + 1], n[T + 2]);
                                for (var A = new Xt, w = new Xt, R = new Xt, C = new Xt, L = 0, P = y.length; L < P; ++L)
                                    for (var k = y[L], I = k.start, U = I, D = I + k.count; U < D; U += 3) O(n[U + 0]), O(n[U + 1]), O(n[U + 2])
                            } else console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");

                            function N(e, t, n) {
                                h.fromArray(r, 3 * e), d.fromArray(r, 3 * t), f.fromArray(r, 3 * n), p.fromArray(a, 2 * e), m.fromArray(a, 2 * t), v.fromArray(a, 2 * n), d.sub(h), f.sub(h), m.sub(p), v.sub(p);
                                var i = 1 / (m.x * v.y - v.x * m.y);
                                isFinite(i) && (g.copy(d).multiplyScalar(v.y).addScaledVector(f, -m.y).multiplyScalar(i), _.copy(f).multiplyScalar(m.x).addScaledVector(d, -v.x).multiplyScalar(i), l[e].add(g), l[t].add(g), l[n].add(g), u[e].add(_), u[t].add(_), u[n].add(_))
                            }

                            function O(e) {
                                R.fromArray(i, 3 * e), C.copy(R);
                                var t = l[e];
                                A.copy(t), A.sub(R.multiplyScalar(R.dot(t))).normalize(), w.crossVectors(C, t);
                                var n = w.dot(u[e]) < 0 ? -1 : 1;
                                s[4 * e] = A.x, s[4 * e + 1] = A.y, s[4 * e + 2] = A.z, s[4 * e + 3] = n
                            }
                        }
                    }, {
                        key: "computeVertexNormals",
                        value: function () {
                            var e = this.index,
                                t = this.getAttribute("position");
                            if (void 0 !== t) {
                                var n = this.getAttribute("normal");
                                if (void 0 === n) n = new _r(new Float32Array(3 * t.count), 3), this.setAttribute("normal", n);
                                else
                                    for (var r = 0, i = n.count; r < i; r++) n.setXYZ(r, 0, 0, 0);
                                var a = new Xt,
                                    o = new Xt,
                                    s = new Xt,
                                    l = new Xt,
                                    u = new Xt,
                                    c = new Xt,
                                    h = new Xt,
                                    d = new Xt;
                                if (e)
                                    for (var f = 0, p = e.count; f < p; f += 3) {
                                        var m = e.getX(f + 0),
                                            v = e.getX(f + 1),
                                            g = e.getX(f + 2);
                                        a.fromBufferAttribute(t, m), o.fromBufferAttribute(t, v), s.fromBufferAttribute(t, g), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, v), c.fromBufferAttribute(n, g), l.add(h), u.add(h), c.add(h), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(v, u.x, u.y, u.z), n.setXYZ(g, c.x, c.y, c.z)
                                    } else
                                        for (var _ = 0, y = t.count; _ < y; _ += 3) a.fromBufferAttribute(t, _ + 0), o.fromBufferAttribute(t, _ + 1), s.fromBufferAttribute(t, _ + 2), h.subVectors(s, o), d.subVectors(a, o), h.cross(d), n.setXYZ(_ + 0, h.x, h.y, h.z), n.setXYZ(_ + 1, h.x, h.y, h.z), n.setXYZ(_ + 2, h.x, h.y, h.z);
                                this.normalizeNormals(), n.needsUpdate = !0
                            }
                        }
                    }, {
                        key: "normalizeNormals",
                        value: function () {
                            for (var e = this.attributes.normal, t = 0, n = e.count; t < n; t++) Rr.fromBufferAttribute(e, t), Rr.normalize(), e.setXYZ(t, Rr.x, Rr.y, Rr.z)
                        }
                    }, {
                        key: "toNonIndexed",
                        value: function () {
                            function e(e, t) {
                                for (var n = e.array, r = e.itemSize, i = e.normalized, a = new n.constructor(t.length * r), o = 0, s = 0, l = 0, u = t.length; l < u; l++) {
                                    o = e.isInterleavedBufferAttribute ? t[l] * e.data.stride + e.offset : t[l] * r;
                                    for (var c = 0; c < r; c++) a[s++] = n[o++]
                                }
                                return new _r(a, r, i)
                            }
                            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
                            var t = new n,
                                r = this.index.array,
                                i = this.attributes;
                            for (var a in i) {
                                var o = e(i[a], r);
                                t.setAttribute(a, o)
                            }
                            var s = this.morphAttributes;
                            for (var l in s) {
                                for (var u = [], c = s[l], h = 0, d = c.length; h < d; h++) {
                                    var f = e(c[h], r);
                                    u.push(f)
                                }
                                t.morphAttributes[l] = u
                            }
                            t.morphTargetsRelative = this.morphTargetsRelative;
                            for (var p = this.groups, m = 0, v = p.length; m < v; m++) {
                                var g = p[m];
                                t.addGroup(g.start, g.count, g.materialIndex)
                            }
                            return t
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = {
                                metadata: {
                                    version: 4.6,
                                    type: "BufferGeometry",
                                    generator: "BufferGeometry.toJSON"
                                }
                            };
                            if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), void 0 !== this.parameters) {
                                var t = this.parameters;
                                for (var n in t) void 0 !== t[n] && (e[n] = t[n]);
                                return e
                            }
                            e.data = {
                                attributes: {}
                            };
                            var r = this.index;
                            null !== r && (e.data.index = {
                                type: r.array.constructor.name,
                                array: Array.prototype.slice.call(r.array)
                            });
                            var i = this.attributes;
                            for (var a in i) {
                                var o = i[a];
                                e.data.attributes[a] = o.toJSON(e.data)
                            }
                            var s = {},
                                l = !1;
                            for (var u in this.morphAttributes) {
                                for (var c = this.morphAttributes[u], h = [], d = 0, f = c.length; d < f; d++) {
                                    var p = c[d];
                                    h.push(p.toJSON(e.data))
                                }
                                h.length > 0 && (s[u] = h, l = !0)
                            }
                            l && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
                            var m = this.groups;
                            m.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(m)));
                            var v = this.boundingSphere;
                            return null !== v && (e.data.boundingSphere = {
                                center: v.center.toArray(),
                                radius: v.radius
                            }), e
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
                            var t = {};
                            this.name = e.name;
                            var n = e.index;
                            null !== n && this.setIndex(n.clone(t));
                            var r = e.attributes;
                            for (var i in r) {
                                var a = r[i];
                                this.setAttribute(i, a.clone(t))
                            }
                            var o = e.morphAttributes;
                            for (var s in o) {
                                for (var l = [], u = o[s], c = 0, h = u.length; c < h; c++) l.push(u[c].clone(t));
                                this.morphAttributes[s] = l
                            }
                            this.morphTargetsRelative = e.morphTargetsRelative;
                            for (var d = e.groups, f = 0, p = d.length; f < p; f++) {
                                var m = d[f];
                                this.addGroup(m.start, m.count, m.materialIndex)
                            }
                            var v = e.boundingBox;
                            null !== v && (this.boundingBox = v.clone());
                            var g = e.boundingSphere;
                            return null !== g && (this.boundingSphere = g.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }]), n
                }(it),
                Lr = new En,
                Pr = new Sn,
                kr = new pn,
                Ir = new Xt,
                Ur = new Xt,
                Dr = new Xt,
                Nr = new Xt,
                Or = new Xt,
                Fr = new Xt,
                Br = new yt,
                zr = new yt,
                Hr = new yt,
                Gr = new Xt,
                Vr = new Xt,
                Wr = new Xt,
                jr = new Xt,
                Xr = new Xt,
                qr = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Cr,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new mr;
                        return i(this, n), (e = t.call(this)).isMesh = !0, e.type = "Mesh", e.geometry = r, e.material = a, e.updateMorphTargets(), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function () {
                            var e = this.geometry.morphAttributes,
                                t = Object.keys(e);
                            if (t.length > 0) {
                                var n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        var a = n[r].name || String(r);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                                    }
                                }
                            }
                        }
                    }, {
                        key: "getVertexPosition",
                        value: function (e, t) {
                            var n = this.geometry,
                                r = n.attributes.position,
                                i = n.morphAttributes.position,
                                a = n.morphTargetsRelative;
                            t.fromBufferAttribute(r, e);
                            var o = this.morphTargetInfluences;
                            if (i && o) {
                                Fr.set(0, 0, 0);
                                for (var s = 0, l = i.length; s < l; s++) {
                                    var u = o[s],
                                        c = i[s];
                                    0 !== u && (Or.fromBufferAttribute(c, e), a ? Fr.addScaledVector(Or, u) : Fr.addScaledVector(Or.sub(t), u))
                                }
                                t.add(Fr)
                            }
                            return t
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            var n = this.geometry,
                                r = this.material,
                                i = this.matrixWorld;
                            if (void 0 !== r) {
                                if (null === n.boundingSphere && n.computeBoundingSphere(), kr.copy(n.boundingSphere), kr.applyMatrix4(i), Pr.copy(e.ray).recast(e.near), !1 === kr.containsPoint(Pr.origin)) {
                                    if (null === Pr.intersectSphere(kr, Ir)) return;
                                    if (Pr.origin.distanceToSquared(Ir) > Math.pow(e.far - e.near, 2)) return
                                }
                                Lr.copy(i).invert(), Pr.copy(e.ray).applyMatrix4(Lr), null !== n.boundingBox && !1 === Pr.intersectsBox(n.boundingBox) || this._computeIntersections(e, t, Pr)
                            }
                        }
                    }, {
                        key: "_computeIntersections",
                        value: function (e, t, n) {
                            var r, i = this.geometry,
                                a = this.material,
                                o = i.index,
                                s = i.attributes.position,
                                l = i.attributes.uv,
                                u = i.attributes.uv1,
                                c = i.attributes.normal,
                                h = i.groups,
                                d = i.drawRange;
                            if (null !== o)
                                if (Array.isArray(a))
                                    for (var f = 0, p = h.length; f < p; f++)
                                        for (var m = h[f], v = a[m.materialIndex], g = Math.max(m.start, d.start), _ = Math.min(o.count, Math.min(m.start + m.count, d.start + d.count)); g < _; g += 3) {
                                            (r = Yr(this, v, e, n, l, u, c, o.getX(g), o.getX(g + 1), o.getX(g + 2))) && (r.faceIndex = Math.floor(g / 3), r.face.materialIndex = m.materialIndex, t.push(r))
                                        } else
                                            for (var y = Math.max(0, d.start), x = Math.min(o.count, d.start + d.count); y < x; y += 3) {
                                                (r = Yr(this, a, e, n, l, u, c, o.getX(y), o.getX(y + 1), o.getX(y + 2))) && (r.faceIndex = Math.floor(y / 3), t.push(r))
                                            } else if (void 0 !== s)
                                                if (Array.isArray(a))
                                                    for (var M = 0, S = h.length; M < S; M++)
                                                        for (var E = h[M], T = a[E.materialIndex], b = Math.max(E.start, d.start), A = Math.min(s.count, Math.min(E.start + E.count, d.start + d.count)); b < A; b += 3) {
                                                            (r = Yr(this, T, e, n, l, u, c, b, b + 1, b + 2)) && (r.faceIndex = Math.floor(b / 3), r.face.materialIndex = E.materialIndex, t.push(r))
                                                        } else
                                                            for (var w = Math.max(0, d.start), R = Math.min(s.count, d.start + d.count); w < R; w += 3) {
                                                                (r = Yr(this, a, e, n, l, u, c, w, w + 1, w + 2)) && (r.faceIndex = Math.floor(w / 3), t.push(r))
                                                            }
                        }
                    }]), n
                }(Yn);

            function Yr(e, t, n, r, i, a, o, s, l, u) {
                e.getVertexPosition(s, Ur), e.getVertexPosition(l, Dr), e.getVertexPosition(u, Nr);
                var c = function (e, t, n, r, i, a, o, s) {
                    if (null === (1 === t.side ? r.intersectTriangle(o, a, i, !0, s) : r.intersectTriangle(i, a, o, 0 === t.side, s))) return null;
                    Xr.copy(s), Xr.applyMatrix4(e.matrixWorld);
                    var l = n.ray.origin.distanceTo(Xr);
                    return l < n.near || l > n.far ? null : {
                        distance: l,
                        point: Xr.clone(),
                        object: e
                    }
                }(e, t, n, r, Ur, Dr, Nr, jr);
                if (c) {
                    i && (Br.fromBufferAttribute(i, s), zr.fromBufferAttribute(i, l), Hr.fromBufferAttribute(i, u), c.uv = or.getInterpolation(jr, Ur, Dr, Nr, Br, zr, Hr, new yt)), a && (Br.fromBufferAttribute(a, s), zr.fromBufferAttribute(a, l), Hr.fromBufferAttribute(a, u), c.uv1 = or.getInterpolation(jr, Ur, Dr, Nr, Br, zr, Hr, new yt), c.uv2 = c.uv1), o && (Gr.fromBufferAttribute(o, s), Vr.fromBufferAttribute(o, l), Wr.fromBufferAttribute(o, u), c.normal = or.getInterpolation(jr, Ur, Dr, Nr, Gr, Vr, Wr, new Xt), c.normal.dot(r.direction) > 0 && c.normal.multiplyScalar(-1));
                    var h = {
                        a: s,
                        b: l,
                        c: u,
                        normal: new Xt,
                        materialIndex: 0
                    };
                    or.getNormal(Ur, Dr, Nr, h.normal), c.face = h
                }
                return c
            }
            var Kr = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                        o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                        s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
                        l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
                        u = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 1;
                    i(this, n), (e = t.call(this)).type = "BoxGeometry", e.parameters = {
                        width: r,
                        height: a,
                        depth: o,
                        widthSegments: s,
                        heightSegments: l,
                        depthSegments: u
                    };
                    var c = M(e);
                    s = Math.floor(s), l = Math.floor(l), u = Math.floor(u);
                    var h = [],
                        d = [],
                        f = [],
                        p = [],
                        m = 0,
                        v = 0;

                    function g(e, t, n, r, i, a, o, s, l, u, g) {
                        for (var _ = a / l, y = o / u, x = a / 2, M = o / 2, S = s / 2, E = l + 1, T = u + 1, b = 0, A = 0, w = new Xt, R = 0; R < T; R++)
                            for (var C = R * y - M, L = 0; L < E; L++) {
                                var P = L * _ - x;
                                w[e] = P * r, w[t] = C * i, w[n] = S, d.push(w.x, w.y, w.z), w[e] = 0, w[t] = 0, w[n] = s > 0 ? 1 : -1, f.push(w.x, w.y, w.z), p.push(L / l), p.push(1 - R / u), b += 1
                            }
                        for (var k = 0; k < u; k++)
                            for (var I = 0; I < l; I++) {
                                var U = m + I + E * k,
                                    D = m + I + E * (k + 1),
                                    N = m + (I + 1) + E * (k + 1),
                                    O = m + (I + 1) + E * k;
                                h.push(U, D, O), h.push(D, N, O), A += 6
                            }
                        c.addGroup(v, A, g), v += A, m += b
                    }
                    return g("z", "y", "x", -1, -1, o, a, r, u, l, 0), g("z", "y", "x", 1, -1, o, a, -r, u, l, 1), g("x", "z", "y", 1, 1, r, o, a, s, u, 2), g("x", "z", "y", 1, -1, r, o, -a, s, u, 3), g("x", "y", "z", 1, -1, r, a, o, s, l, 4), g("x", "y", "z", -1, -1, r, a, -o, s, l, 5), e.setIndex(h), e.setAttribute("position", new Mr(d, 3)), e.setAttribute("normal", new Mr(f, 3)), e.setAttribute("uv", new Mr(p, 2)), e
                }
                return o(n, [{
                    key: "copy",
                    value: function (e) {
                        return g(y(n.prototype), "copy", this).call(this, e), this.parameters = Object.assign({}, e.parameters), this
                    }
                }], [{
                    key: "fromJSON",
                    value: function (e) {
                        return new n(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
                    }
                }]), n
            }(Cr);

            function Zr(e) {
                var t = {};
                for (var n in e)
                    for (var r in t[n] = {}, e[n]) {
                        var i = e[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[n][r] = null) : t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
                    }
                return t
            }

            function Jr(e) {
                for (var t = {}, n = 0; n < e.length; n++) {
                    var r = Zr(e[n]);
                    for (var i in r) t[i] = r[i]
                }
                return t
            }

            function Qr(e) {
                return null === e.getRenderTarget() ? e.outputColorSpace : Ze
            }
            var $r = {
                    clone: Zr,
                    merge: Jr
                },
                ei = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isShaderMaterial = !0, r.type = "ShaderMaterial", r.defines = {}, r.uniforms = {}, r.uniformsGroups = [], r.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", r.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", r.linewidth = 1, r.wireframe = !1, r.wireframeLinewidth = 1, r.fog = !1, r.lights = !1, r.clipping = !1, r.forceSinglePass = !0, r.extensions = {
                            derivatives: !1,
                            fragDepth: !1,
                            drawBuffers: !1,
                            shaderTextureLOD: !1
                        }, r.defaultAttributeValues = {
                            color: [1, 1, 1],
                            uv: [0, 0],
                            uv1: [0, 0]
                        }, r.index0AttributeName = void 0, r.uniformsNeedUpdate = !1, r.glslVersion = null, void 0 !== e && r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Zr(e.uniforms), this.uniformsGroups = function (e) {
                                for (var t = [], n = 0; n < e.length; n++) t.push(e[n].clone());
                                return t
                            }(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            for (var r in t.glslVersion = this.glslVersion, t.uniforms = {}, this.uniforms) {
                                var i = this.uniforms[r].value;
                                i && i.isTexture ? t.uniforms[r] = {
                                    type: "t",
                                    value: i.toJSON(e).uuid
                                } : i && i.isColor ? t.uniforms[r] = {
                                    type: "c",
                                    value: i.getHex()
                                } : i && i.isVector2 ? t.uniforms[r] = {
                                    type: "v2",
                                    value: i.toArray()
                                } : i && i.isVector3 ? t.uniforms[r] = {
                                    type: "v3",
                                    value: i.toArray()
                                } : i && i.isVector4 ? t.uniforms[r] = {
                                    type: "v4",
                                    value: i.toArray()
                                } : i && i.isMatrix3 ? t.uniforms[r] = {
                                    type: "m3",
                                    value: i.toArray()
                                } : i && i.isMatrix4 ? t.uniforms[r] = {
                                    type: "m4",
                                    value: i.toArray()
                                } : t.uniforms[r] = {
                                    value: i
                                }
                            }
                            Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
                            var a = {};
                            for (var o in this.extensions) !0 === this.extensions[o] && (a[o] = !0);
                            return Object.keys(a).length > 0 && (t.extensions = a), t
                        }
                    }]), n
                }(lr),
                ti = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isCamera = !0, e.type = "Camera", e.matrixWorldInverse = new En, e.projectionMatrix = new En, e.projectionMatrixInverse = new En, e.coordinateSystem = nt, e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
                        }
                    }, {
                        key: "getWorldDirection",
                        value: function (e) {
                            this.updateWorldMatrix(!0, !1);
                            var t = this.matrixWorld.elements;
                            return e.set(-t[8], -t[9], -t[10]).normalize()
                        }
                    }, {
                        key: "updateMatrixWorld",
                        value: function (e) {
                            g(y(n.prototype), "updateMatrixWorld", this).call(this, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                    }, {
                        key: "updateWorldMatrix",
                        value: function (e, t) {
                            g(y(n.prototype), "updateWorldMatrix", this).call(this, e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }]), n
                }(Yn),
                ni = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 50,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2e3;
                        return i(this, n), (e = t.call(this)).isPerspectiveCamera = !0, e.type = "PerspectiveCamera", e.fov = r, e.zoom = 1, e.near = o, e.far = s, e.focus = 10, e.aspect = a, e.view = null, e.filmGauge = 35, e.filmOffset = 0, e.updateProjectionMatrix(), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = null === e.view ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
                        }
                    }, {
                        key: "setFocalLength",
                        value: function (e) {
                            var t = .5 * this.getFilmHeight() / e;
                            this.fov = 2 * lt * Math.atan(t), this.updateProjectionMatrix()
                        }
                    }, {
                        key: "getFocalLength",
                        value: function () {
                            var e = Math.tan(.5 * st * this.fov);
                            return .5 * this.getFilmHeight() / e
                        }
                    }, {
                        key: "getEffectiveFOV",
                        value: function () {
                            return 2 * lt * Math.atan(Math.tan(.5 * st * this.fov) / this.zoom)
                        }
                    }, {
                        key: "getFilmWidth",
                        value: function () {
                            return this.filmGauge * Math.min(this.aspect, 1)
                        }
                    }, {
                        key: "getFilmHeight",
                        value: function () {
                            return this.filmGauge / Math.max(this.aspect, 1)
                        }
                    }, {
                        key: "setViewOffset",
                        value: function (e, t, n, r, i, a) {
                            this.aspect = e / t, null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                        }
                    }, {
                        key: "clearViewOffset",
                        value: function () {
                            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }
                    }, {
                        key: "updateProjectionMatrix",
                        value: function () {
                            var e = this.near,
                                t = e * Math.tan(.5 * st * this.fov) / this.zoom,
                                n = 2 * t,
                                r = this.aspect * n,
                                i = -.5 * r,
                                a = this.view;
                            if (null !== this.view && this.view.enabled) {
                                var o = a.fullWidth,
                                    s = a.fullHeight;
                                i += a.offsetX * r / o, t -= a.offsetY * n / s, r *= a.width / o, n *= a.height / s
                            }
                            var l = this.filmOffset;
                            0 !== l && (i += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
                        }
                    }]), n
                }(ti),
                ri = -90,
                ii = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        var o;
                        i(this, n), (o = t.call(this)).type = "CubeCamera", o.renderTarget = a, o.coordinateSystem = null;
                        var s = new ni(ri, 1, e, r);
                        s.layers = o.layers, o.add(s);
                        var l = new ni(ri, 1, e, r);
                        l.layers = o.layers, o.add(l);
                        var u = new ni(ri, 1, e, r);
                        u.layers = o.layers, o.add(u);
                        var c = new ni(ri, 1, e, r);
                        c.layers = o.layers, o.add(c);
                        var h = new ni(ri, 1, e, r);
                        h.layers = o.layers, o.add(h);
                        var d = new ni(ri, 1, e, r);
                        return d.layers = o.layers, o.add(d), o
                    }
                    return o(n, [{
                        key: "updateCoordinateSystem",
                        value: function () {
                            var e, t = this.coordinateSystem,
                                n = this.children.concat(),
                                r = m(n, 6),
                                i = r[0],
                                a = r[1],
                                o = r[2],
                                s = r[3],
                                l = r[4],
                                u = r[5],
                                c = p(n);
                            try {
                                for (c.s(); !(e = c.n()).done;) {
                                    var h = e.value;
                                    this.remove(h)
                                }
                            } catch (e) {
                                c.e(e)
                            } finally {
                                c.f()
                            }
                            if (t === nt) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), a.up.set(0, 1, 0), a.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), s.up.set(0, 0, 1), s.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
                            else {
                                if (t !== rt) throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + t);
                                i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), a.up.set(0, -1, 0), a.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), s.up.set(0, 0, -1), s.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1)
                            }
                            var d, f = p(n);
                            try {
                                for (f.s(); !(d = f.n()).done;) {
                                    var v = d.value;
                                    this.add(v), v.updateMatrixWorld()
                                }
                            } catch (e) {
                                f.e(e)
                            } finally {
                                f.f()
                            }
                        }
                    }, {
                        key: "update",
                        value: function (e, t) {
                            null === this.parent && this.updateMatrixWorld();
                            var n = this.renderTarget;
                            this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
                            var r = m(this.children, 6),
                                i = r[0],
                                a = r[1],
                                o = r[2],
                                s = r[3],
                                l = r[4],
                                u = r[5],
                                c = e.getRenderTarget(),
                                h = e.xr.enabled;
                            e.xr.enabled = !1;
                            var d = n.texture.generateMipmaps;
                            n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0), e.render(t, i), e.setRenderTarget(n, 1), e.render(t, a), e.setRenderTarget(n, 2), e.render(t, o), e.setRenderTarget(n, 3), e.render(t, s), e.setRenderTarget(n, 4), e.render(t, l), n.texture.generateMipmaps = d, e.setRenderTarget(n, 5), e.render(t, u), e.setRenderTarget(c), e.xr.enabled = h, n.texture.needsPMREMUpdate = !0
                        }
                    }]), n
                }(Yn),
                ai = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o, s, l, u, c, h, d) {
                        var f;
                        return i(this, n), e = void 0 !== e ? e : [], r = void 0 !== r ? r : O, (f = t.call(this, e, r, a, o, s, l, u, c, h, d)).isCubeTexture = !0, f.flipY = !1, f
                    }
                    return o(n, [{
                        key: "images",
                        get: function () {
                            return this.image
                        },
                        set: function (e) {
                            this.image = e
                        }
                    }]), n
                }(Bt),
                oi = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        i(this, n), (e = t.call(this, r, r, a)).isWebGLCubeRenderTarget = !0;
                        var o = {
                                width: r,
                                height: r,
                                depth: 1
                            },
                            s = [o, o, o, o, o, o];
                        return void 0 !== a.encoding && (bt("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), a.colorSpace = a.encoding === qe ? Ke : Ye), e.texture = new ai(s, a.mapping, a.wrapS, a.wrapT, a.magFilter, a.minFilter, a.format, a.type, a.anisotropy, a.colorSpace), e.texture.isRenderTargetTexture = !0, e.texture.generateMipmaps = void 0 !== a.generateMipmaps && a.generateMipmaps, e.texture.minFilter = void 0 !== a.minFilter ? a.minFilter : Y, e
                    }
                    return o(n, [{
                        key: "fromEquirectangularTexture",
                        value: function (e, t) {
                            this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
                            var n = {
                                    tEquirect: {
                                        value: null
                                    }
                                },
                                r = "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                                i = "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
                                a = new Kr(5, 5, 5),
                                o = new ei({
                                    name: "CubemapFromEquirect",
                                    uniforms: Zr(n),
                                    vertexShader: r,
                                    fragmentShader: i,
                                    side: 1,
                                    blending: 0
                                });
                            o.uniforms.tEquirect.value = t;
                            var s = new qr(a, o),
                                l = t.minFilter;
                            return t.minFilter === Z && (t.minFilter = Y), new ii(1, 10, this).update(e, s), t.minFilter = l, s.geometry.dispose(), s.material.dispose(), this
                        }
                    }, {
                        key: "clear",
                        value: function (e, t, n, r) {
                            for (var i = e.getRenderTarget(), a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, r);
                            e.setRenderTarget(i)
                        }
                    }]), n
                }(Gt),
                si = new Xt,
                li = new Xt,
                ui = new xt,
                ci = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Xt(1, 0, 0),
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        i(this, e), this.isPlane = !0, this.normal = t, this.constant = n
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t) {
                            return this.normal.copy(e), this.constant = t, this
                        }
                    }, {
                        key: "setComponents",
                        value: function (e, t, n, r) {
                            return this.normal.set(e, t, n), this.constant = r, this
                        }
                    }, {
                        key: "setFromNormalAndCoplanarPoint",
                        value: function (e, t) {
                            return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                        }
                    }, {
                        key: "setFromCoplanarPoints",
                        value: function (e, t, n) {
                            var r = si.subVectors(n, t).cross(li.subVectors(e, t)).normalize();
                            return this.setFromNormalAndCoplanarPoint(r, e), this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.normal.copy(e.normal), this.constant = e.constant, this
                        }
                    }, {
                        key: "normalize",
                        value: function () {
                            var e = 1 / this.normal.length();
                            return this.normal.multiplyScalar(e), this.constant *= e, this
                        }
                    }, {
                        key: "negate",
                        value: function () {
                            return this.constant *= -1, this.normal.negate(), this
                        }
                    }, {
                        key: "distanceToPoint",
                        value: function (e) {
                            return this.normal.dot(e) + this.constant
                        }
                    }, {
                        key: "distanceToSphere",
                        value: function (e) {
                            return this.distanceToPoint(e.center) - e.radius
                        }
                    }, {
                        key: "projectPoint",
                        value: function (e, t) {
                            return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
                        }
                    }, {
                        key: "intersectLine",
                        value: function (e, t) {
                            var n = e.delta(si),
                                r = this.normal.dot(n);
                            if (0 === r) return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
                            var i = -(e.start.dot(this.normal) + this.constant) / r;
                            return i < 0 || i > 1 ? null : t.copy(e.start).addScaledVector(n, i)
                        }
                    }, {
                        key: "intersectsLine",
                        value: function (e) {
                            var t = this.distanceToPoint(e.start),
                                n = this.distanceToPoint(e.end);
                            return t < 0 && n > 0 || n < 0 && t > 0
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            return e.intersectsPlane(this)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function (e) {
                            return e.intersectsPlane(this)
                        }
                    }, {
                        key: "coplanarPoint",
                        value: function (e) {
                            return e.copy(this.normal).multiplyScalar(-this.constant)
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e, t) {
                            var n = t || ui.getNormalMatrix(e),
                                r = this.coplanarPoint(si).applyMatrix4(e),
                                i = this.normal.applyMatrix3(n).normalize();
                            return this.constant = -r.dot(i), this
                        }
                    }, {
                        key: "translate",
                        value: function (e) {
                            return this.constant -= e.dot(this.normal), this
                        }
                    }, {
                        key: "equals",
                        value: function (e) {
                            return e.normal.equals(this.normal) && e.constant === this.constant
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }(),
                hi = new pn,
                di = new Xt,
                fi = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new ci,
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new ci,
                            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : new ci,
                            a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : new ci,
                            o = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : new ci,
                            s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : new ci;
                        i(this, e), this.planes = [t, n, r, a, o, s]
                    }
                    return o(e, [{
                        key: "set",
                        value: function (e, t, n, r, i, a) {
                            var o = this.planes;
                            return o[0].copy(e), o[1].copy(t), o[2].copy(n), o[3].copy(r), o[4].copy(i), o[5].copy(a), this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            for (var t = this.planes, n = 0; n < 6; n++) t[n].copy(e.planes[n]);
                            return this
                        }
                    }, {
                        key: "setFromProjectionMatrix",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : nt,
                                n = this.planes,
                                r = e.elements,
                                i = r[0],
                                a = r[1],
                                o = r[2],
                                s = r[3],
                                l = r[4],
                                u = r[5],
                                c = r[6],
                                h = r[7],
                                d = r[8],
                                f = r[9],
                                p = r[10],
                                m = r[11],
                                v = r[12],
                                g = r[13],
                                _ = r[14],
                                y = r[15];
                            if (n[0].setComponents(s - i, h - l, m - d, y - v).normalize(), n[1].setComponents(s + i, h + l, m + d, y + v).normalize(), n[2].setComponents(s + a, h + u, m + f, y + g).normalize(), n[3].setComponents(s - a, h - u, m - f, y - g).normalize(), n[4].setComponents(s - o, h - c, m - p, y - _).normalize(), t === nt) n[5].setComponents(s + o, h + c, m + p, y + _).normalize();
                            else {
                                if (t !== rt) throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
                                n[5].setComponents(o, c, p, _).normalize()
                            }
                            return this
                        }
                    }, {
                        key: "intersectsObject",
                        value: function (e) {
                            if (void 0 !== e.boundingSphere) null === e.boundingSphere && e.computeBoundingSphere(), hi.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
                            else {
                                var t = e.geometry;
                                null === t.boundingSphere && t.computeBoundingSphere(), hi.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
                            }
                            return this.intersectsSphere(hi)
                        }
                    }, {
                        key: "intersectsSprite",
                        value: function (e) {
                            return hi.center.set(0, 0, 0), hi.radius = .7071067811865476, hi.applyMatrix4(e.matrixWorld), this.intersectsSphere(hi)
                        }
                    }, {
                        key: "intersectsSphere",
                        value: function (e) {
                            for (var t = this.planes, n = e.center, r = -e.radius, i = 0; i < 6; i++) {
                                if (t[i].distanceToPoint(n) < r) return !1
                            }
                            return !0
                        }
                    }, {
                        key: "intersectsBox",
                        value: function (e) {
                            for (var t = this.planes, n = 0; n < 6; n++) {
                                var r = t[n];
                                if (di.x = r.normal.x > 0 ? e.max.x : e.min.x, di.y = r.normal.y > 0 ? e.max.y : e.min.y, di.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(di) < 0) return !1
                            }
                            return !0
                        }
                    }, {
                        key: "containsPoint",
                        value: function (e) {
                            for (var t = this.planes, n = 0; n < 6; n++)
                                if (t[n].distanceToPoint(e) < 0) return !1;
                            return !0
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }]), e
                }();

            function pi() {
                var e = null,
                    t = !1,
                    n = null,
                    r = null;

                function i(t, a) {
                    n(t, a), r = e.requestAnimationFrame(i)
                }
                return {
                    start: function () {
                        !0 !== t && null !== n && (r = e.requestAnimationFrame(i), t = !0)
                    },
                    stop: function () {
                        e.cancelAnimationFrame(r), t = !1
                    },
                    setAnimationLoop: function (e) {
                        n = e
                    },
                    setContext: function (t) {
                        e = t
                    }
                }
            }

            function mi(e, t) {
                var n = t.isWebGL2,
                    r = new WeakMap;
                return {
                    get: function (e) {
                        return e.isInterleavedBufferAttribute && (e = e.data), r.get(e)
                    },
                    remove: function (t) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        var n = r.get(t);
                        n && (e.deleteBuffer(n.buffer), r.delete(t))
                    },
                    update: function (t, i) {
                        if (t.isGLBufferAttribute) {
                            var a = r.get(t);
                            (!a || a.version < t.version) && r.set(t, {
                                buffer: t.buffer,
                                type: t.type,
                                bytesPerElement: t.elementSize,
                                version: t.version
                            })
                        } else {
                            t.isInterleavedBufferAttribute && (t = t.data);
                            var o = r.get(t);
                            void 0 === o ? r.set(t, function (t, r) {
                                var i, a = t.array,
                                    o = t.usage,
                                    s = e.createBuffer();
                                if (e.bindBuffer(r, s), e.bufferData(r, a, o), t.onUploadCallback(), a instanceof Float32Array) i = e.FLOAT;
                                else if (a instanceof Uint16Array)
                                    if (t.isFloat16BufferAttribute) {
                                        if (!n) throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
                                        i = e.HALF_FLOAT
                                    } else i = e.UNSIGNED_SHORT;
                                else if (a instanceof Int16Array) i = e.SHORT;
                                else if (a instanceof Uint32Array) i = e.UNSIGNED_INT;
                                else if (a instanceof Int32Array) i = e.INT;
                                else if (a instanceof Int8Array) i = e.BYTE;
                                else if (a instanceof Uint8Array) i = e.UNSIGNED_BYTE;
                                else {
                                    if (!(a instanceof Uint8ClampedArray)) throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + a);
                                    i = e.UNSIGNED_BYTE
                                }
                                return {
                                    buffer: s,
                                    type: i,
                                    bytesPerElement: a.BYTES_PER_ELEMENT,
                                    version: t.version
                                }
                            }(t, i)) : o.version < t.version && (! function (t, r, i) {
                                var a = r.array,
                                    o = r.updateRange;
                                e.bindBuffer(i, t), -1 === o.count ? e.bufferSubData(i, 0, a) : (n ? e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a, o.offset, o.count) : e.bufferSubData(i, o.offset * a.BYTES_PER_ELEMENT, a.subarray(o.offset, o.offset + o.count)), o.count = -1), r.onUploadCallback()
                            }(o.buffer, t, i), o.version = t.version)
                        }
                    }
                }
            }
            var vi = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        i(this, n), (e = t.call(this)).type = "PlaneGeometry", e.parameters = {
                            width: r,
                            height: a,
                            widthSegments: o,
                            heightSegments: s
                        };
                        for (var l = r / 2, u = a / 2, c = Math.floor(o), h = Math.floor(s), d = c + 1, f = h + 1, p = r / c, m = a / h, v = [], g = [], _ = [], y = [], x = 0; x < f; x++)
                            for (var M = x * m - u, S = 0; S < d; S++) {
                                var E = S * p - l;
                                g.push(E, -M, 0), _.push(0, 0, 1), y.push(S / c), y.push(1 - x / h)
                            }
                        for (var T = 0; T < h; T++)
                            for (var b = 0; b < c; b++) {
                                var A = b + d * T,
                                    w = b + d * (T + 1),
                                    R = b + 1 + d * (T + 1),
                                    C = b + 1 + d * T;
                                v.push(A, w, C), v.push(w, R, C)
                            }
                        return e.setIndex(v), e.setAttribute("position", new Mr(g, 3)), e.setAttribute("normal", new Mr(_, 3)), e.setAttribute("uv", new Mr(y, 2)), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.parameters = Object.assign({}, e.parameters), this
                        }
                    }], [{
                        key: "fromJSON",
                        value: function (e) {
                            return new n(e.width, e.height, e.widthSegments, e.heightSegments)
                        }
                    }]), n
                }(Cr),
                gi = {
                    alphahash_fragment: "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
                    alphahash_pars_fragment: "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
                    alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
                    iridescence_fragment: "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
                    common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    colorspace_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
                    envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_fragment: "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
                    lights_lambert_pars_fragment: "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
                    lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
                    lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
                    map_particle_pars_fragment: "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphcolor_vertex: "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
                    normal_fragment_maps: "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
                    normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
                    normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
                    clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
                    clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
                    clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
                    iridescence_pars_fragment: "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
                    opaque_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
                    transmission_fragment: "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
                    transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
                    uv_pars_fragment: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
                    uv_vertex: "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    background_frag: "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    backgroundCube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    backgroundCube_frag: "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
                    meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
                    shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}"
                },
                _i = {
                    common: {
                        diffuse: {
                            value: new fr(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new xt
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new xt
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new xt
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: .98
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new xt
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new xt
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new xt
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new xt
                        },
                        normalScale: {
                            value: new yt(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new xt
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new xt
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new xt
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new xt
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new fr(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new fr(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new xt
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new xt
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new fr(16777215)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new yt(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new xt
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new xt
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                },
                yi = {
                    basic: {
                        uniforms: Jr([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.fog]),
                        vertexShader: gi.meshbasic_vert,
                        fragmentShader: gi.meshbasic_frag
                    },
                    lambert: {
                        uniforms: Jr([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, _i.lights, {
                            emissive: {
                                value: new fr(0)
                            }
                        }]),
                        vertexShader: gi.meshlambert_vert,
                        fragmentShader: gi.meshlambert_frag
                    },
                    phong: {
                        uniforms: Jr([_i.common, _i.specularmap, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, _i.lights, {
                            emissive: {
                                value: new fr(0)
                            },
                            specular: {
                                value: new fr(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: gi.meshphong_vert,
                        fragmentShader: gi.meshphong_frag
                    },
                    standard: {
                        uniforms: Jr([_i.common, _i.envmap, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.roughnessmap, _i.metalnessmap, _i.fog, _i.lights, {
                            emissive: {
                                value: new fr(0)
                            },
                            roughness: {
                                value: 1
                            },
                            metalness: {
                                value: 0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: gi.meshphysical_vert,
                        fragmentShader: gi.meshphysical_frag
                    },
                    toon: {
                        uniforms: Jr([_i.common, _i.aomap, _i.lightmap, _i.emissivemap, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.gradientmap, _i.fog, _i.lights, {
                            emissive: {
                                value: new fr(0)
                            }
                        }]),
                        vertexShader: gi.meshtoon_vert,
                        fragmentShader: gi.meshtoon_frag
                    },
                    matcap: {
                        uniforms: Jr([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, _i.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: gi.meshmatcap_vert,
                        fragmentShader: gi.meshmatcap_frag
                    },
                    points: {
                        uniforms: Jr([_i.points, _i.fog]),
                        vertexShader: gi.points_vert,
                        fragmentShader: gi.points_frag
                    },
                    dashed: {
                        uniforms: Jr([_i.common, _i.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: gi.linedashed_vert,
                        fragmentShader: gi.linedashed_frag
                    },
                    depth: {
                        uniforms: Jr([_i.common, _i.displacementmap]),
                        vertexShader: gi.depth_vert,
                        fragmentShader: gi.depth_frag
                    },
                    normal: {
                        uniforms: Jr([_i.common, _i.bumpmap, _i.normalmap, _i.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: gi.meshnormal_vert,
                        fragmentShader: gi.meshnormal_frag
                    },
                    sprite: {
                        uniforms: Jr([_i.sprite, _i.fog]),
                        vertexShader: gi.sprite_vert,
                        fragmentShader: gi.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new xt
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: gi.background_vert,
                        fragmentShader: gi.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: gi.backgroundCube_vert,
                        fragmentShader: gi.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: gi.cube_vert,
                        fragmentShader: gi.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: gi.equirect_vert,
                        fragmentShader: gi.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: Jr([_i.common, _i.displacementmap, {
                            referencePosition: {
                                value: new Xt
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: gi.distanceRGBA_vert,
                        fragmentShader: gi.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: Jr([_i.lights, _i.fog, {
                            color: {
                                value: new fr(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: gi.shadow_vert,
                        fragmentShader: gi.shadow_frag
                    }
                };
            yi.physical = {
                uniforms: Jr([yi.standard.uniforms, {
                    clearcoat: {
                        value: 0
                    },
                    clearcoatMap: {
                        value: null
                    },
                    clearcoatMapTransform: {
                        value: new xt
                    },
                    clearcoatNormalMap: {
                        value: null
                    },
                    clearcoatNormalMapTransform: {
                        value: new xt
                    },
                    clearcoatNormalScale: {
                        value: new yt(1, 1)
                    },
                    clearcoatRoughness: {
                        value: 0
                    },
                    clearcoatRoughnessMap: {
                        value: null
                    },
                    clearcoatRoughnessMapTransform: {
                        value: new xt
                    },
                    iridescence: {
                        value: 0
                    },
                    iridescenceMap: {
                        value: null
                    },
                    iridescenceMapTransform: {
                        value: new xt
                    },
                    iridescenceIOR: {
                        value: 1.3
                    },
                    iridescenceThicknessMinimum: {
                        value: 100
                    },
                    iridescenceThicknessMaximum: {
                        value: 400
                    },
                    iridescenceThicknessMap: {
                        value: null
                    },
                    iridescenceThicknessMapTransform: {
                        value: new xt
                    },
                    sheen: {
                        value: 0
                    },
                    sheenColor: {
                        value: new fr(0)
                    },
                    sheenColorMap: {
                        value: null
                    },
                    sheenColorMapTransform: {
                        value: new xt
                    },
                    sheenRoughness: {
                        value: 1
                    },
                    sheenRoughnessMap: {
                        value: null
                    },
                    sheenRoughnessMapTransform: {
                        value: new xt
                    },
                    transmission: {
                        value: 0
                    },
                    transmissionMap: {
                        value: null
                    },
                    transmissionMapTransform: {
                        value: new xt
                    },
                    transmissionSamplerSize: {
                        value: new yt
                    },
                    transmissionSamplerMap: {
                        value: null
                    },
                    thickness: {
                        value: 0
                    },
                    thicknessMap: {
                        value: null
                    },
                    thicknessMapTransform: {
                        value: new xt
                    },
                    attenuationDistance: {
                        value: 0
                    },
                    attenuationColor: {
                        value: new fr(0)
                    },
                    specularColor: {
                        value: new fr(1, 1, 1)
                    },
                    specularColorMap: {
                        value: null
                    },
                    specularColorMapTransform: {
                        value: new xt
                    },
                    specularIntensity: {
                        value: 1
                    },
                    specularIntensityMap: {
                        value: null
                    },
                    specularIntensityMapTransform: {
                        value: new xt
                    },
                    anisotropyVector: {
                        value: new yt
                    },
                    anisotropyMap: {
                        value: null
                    },
                    anisotropyMapTransform: {
                        value: new xt
                    }
                }]),
                vertexShader: gi.meshphysical_vert,
                fragmentShader: gi.meshphysical_frag
            };
            var xi = {
                r: 0,
                b: 0,
                g: 0
            };

            function Mi(e, t, n, r, i, a, o) {
                var s, l, u = new fr(0),
                    c = !0 === a ? 0 : 1,
                    h = null,
                    d = 0,
                    f = null;

                function p(t, n) {
                    t.getRGB(xi, Qr(e)), r.buffers.color.setClear(xi.r, xi.g, xi.b, n, o)
                }
                return {
                    getClearColor: function () {
                        return u
                    },
                    setClearColor: function (e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        u.set(e), p(u, c = t)
                    },
                    getClearAlpha: function () {
                        return c
                    },
                    setClearAlpha: function (e) {
                        p(u, c = e)
                    },
                    render: function (a, m) {
                        var v = !1,
                            g = !0 === m.isScene ? m.background : null;
                        switch (g && g.isTexture && (g = (m.backgroundBlurriness > 0 ? n : t).get(g)), null === g ? p(u, c) : g && g.isColor && (p(g, 1), v = !0), e.xr.getEnvironmentBlendMode()) {
                            case "opaque":
                                v = !0;
                                break;
                            case "additive":
                                r.buffers.color.setClear(0, 0, 0, 1, o), v = !0;
                                break;
                            case "alpha-blend":
                                r.buffers.color.setClear(0, 0, 0, 0, o), v = !0
                        }(e.autoClear || v) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), g && (g.isCubeTexture || g.mapping === H) ? (void 0 === l && ((l = new qr(new Kr(1, 1, 1), new ei({
                            name: "BackgroundCubeMaterial",
                            uniforms: Zr(yi.backgroundCube.uniforms),
                            vertexShader: yi.backgroundCube.vertexShader,
                            fragmentShader: yi.backgroundCube.fragmentShader,
                            side: 1,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), l.geometry.deleteAttribute("uv"), l.onBeforeRender = function (e, t, n) {
                            this.matrixWorld.copyPosition(n.matrixWorld)
                        }, Object.defineProperty(l.material, "envMap", {
                            get: function () {
                                return this.uniforms.envMap.value
                            }
                        }), i.update(l)), l.material.uniforms.envMap.value = g, l.material.uniforms.flipEnvMap.value = g.isCubeTexture && !1 === g.isRenderTargetTexture ? -1 : 1, l.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, l.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, l.material.toneMapped = g.colorSpace !== Ke, h === g && d === g.version && f === e.toneMapping || (l.material.needsUpdate = !0, h = g, d = g.version, f = e.toneMapping), l.layers.enableAll(), a.unshift(l, l.geometry, l.material, 0, 0, null)) : g && g.isTexture && (void 0 === s && ((s = new qr(new vi(2, 2), new ei({
                            name: "BackgroundMaterial",
                            uniforms: Zr(yi.background.uniforms),
                            vertexShader: yi.background.vertexShader,
                            fragmentShader: yi.background.fragmentShader,
                            side: 0,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.deleteAttribute("normal"), Object.defineProperty(s.material, "map", {
                            get: function () {
                                return this.uniforms.t2D.value
                            }
                        }), i.update(s)), s.material.uniforms.t2D.value = g, s.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, s.material.toneMapped = g.colorSpace !== Ke, !0 === g.matrixAutoUpdate && g.updateMatrix(), s.material.uniforms.uvTransform.value.copy(g.matrix), h === g && d === g.version && f === e.toneMapping || (s.material.needsUpdate = !0, h = g, d = g.version, f = e.toneMapping), s.layers.enableAll(), a.unshift(s, s.geometry, s.material, 0, 0, null))
                    }
                }
            }

            function Si(e, t, n, r) {
                var i = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    a = r.isWebGL2 ? null : t.get("OES_vertex_array_object"),
                    o = r.isWebGL2 || null !== a,
                    s = {},
                    l = f(null),
                    u = l,
                    c = !1;

                function h(t) {
                    return r.isWebGL2 ? e.bindVertexArray(t) : a.bindVertexArrayOES(t)
                }

                function d(t) {
                    return r.isWebGL2 ? e.deleteVertexArray(t) : a.deleteVertexArrayOES(t)
                }

                function f(e) {
                    for (var t = [], n = [], r = [], a = 0; a < i; a++) t[a] = 0, n[a] = 0, r[a] = 0;
                    return {
                        geometry: null,
                        program: null,
                        wireframe: !1,
                        newAttributes: t,
                        enabledAttributes: n,
                        attributeDivisors: r,
                        object: e,
                        attributes: {},
                        index: null
                    }
                }

                function p() {
                    for (var e = u.newAttributes, t = 0, n = e.length; t < n; t++) e[t] = 0
                }

                function m(e) {
                    v(e, 0)
                }

                function v(n, i) {
                    var a = u.newAttributes,
                        o = u.enabledAttributes,
                        s = u.attributeDivisors;
                    (a[n] = 1, 0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1), s[n] !== i) && ((r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), s[n] = i)
                }

                function g() {
                    for (var t = u.newAttributes, n = u.enabledAttributes, r = 0, i = n.length; r < i; r++) n[r] !== t[r] && (e.disableVertexAttribArray(r), n[r] = 0)
                }

                function _(t, n, r, i, a, o, s) {
                    !0 === s ? e.vertexAttribIPointer(t, n, r, a, o) : e.vertexAttribPointer(t, n, r, i, a, o)
                }

                function y() {
                    x(), c = !0, u !== l && h((u = l).object)
                }

                function x() {
                    l.geometry = null, l.program = null, l.wireframe = !1
                }
                return {
                    setup: function (i, l, d, y, x) {
                        var M = !1;
                        if (o) {
                            var S = function (t, n, i) {
                                var o = !0 === i.wireframe,
                                    l = s[t.id];
                                void 0 === l && (l = {}, s[t.id] = l);
                                var u = l[n.id];
                                void 0 === u && (u = {}, l[n.id] = u);
                                var c = u[o];
                                void 0 === c && (c = f(r.isWebGL2 ? e.createVertexArray() : a.createVertexArrayOES()), u[o] = c);
                                return c
                            }(y, d, l);
                            u !== S && h((u = S).object), M = function (e, t, n, r) {
                                var i = u.attributes,
                                    a = t.attributes,
                                    o = 0,
                                    s = n.getAttributes();
                                for (var l in s) {
                                    if (s[l].location >= 0) {
                                        var c = i[l],
                                            h = a[l];
                                        if (void 0 === h && ("instanceMatrix" === l && e.instanceMatrix && (h = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (h = e.instanceColor)), void 0 === c) return !0;
                                        if (c.attribute !== h) return !0;
                                        if (h && c.data !== h.data) return !0;
                                        o++
                                    }
                                }
                                return u.attributesNum !== o || u.index !== r
                            }(i, y, d, x), M && function (e, t, n, r) {
                                var i = {},
                                    a = t.attributes,
                                    o = 0,
                                    s = n.getAttributes();
                                for (var l in s) {
                                    if (s[l].location >= 0) {
                                        var c = a[l];
                                        void 0 === c && ("instanceMatrix" === l && e.instanceMatrix && (c = e.instanceMatrix), "instanceColor" === l && e.instanceColor && (c = e.instanceColor));
                                        var h = {};
                                        h.attribute = c, c && c.data && (h.data = c.data), i[l] = h, o++
                                    }
                                }
                                u.attributes = i, u.attributesNum = o, u.index = r
                            }(i, y, d, x)
                        } else {
                            var E = !0 === l.wireframe;
                            u.geometry === y.id && u.program === d.id && u.wireframe === E || (u.geometry = y.id, u.program = d.id, u.wireframe = E, M = !0)
                        }
                        null !== x && n.update(x, e.ELEMENT_ARRAY_BUFFER), (M || c) && (c = !1, function (i, a, o, s) {
                            if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays")) return;
                            p();
                            var l = s.attributes,
                                u = o.getAttributes(),
                                c = a.defaultAttributeValues;
                            for (var h in u) {
                                var d = u[h];
                                if (d.location >= 0) {
                                    var f = l[h];
                                    if (void 0 === f && ("instanceMatrix" === h && i.instanceMatrix && (f = i.instanceMatrix), "instanceColor" === h && i.instanceColor && (f = i.instanceColor)), void 0 !== f) {
                                        var y = f.normalized,
                                            x = f.itemSize,
                                            M = n.get(f);
                                        if (void 0 === M) continue;
                                        var S = M.buffer,
                                            E = M.type,
                                            T = M.bytesPerElement,
                                            b = !0 === r.isWebGL2 && (E === e.INT || E === e.UNSIGNED_INT || f.gpuType === $);
                                        if (f.isInterleavedBufferAttribute) {
                                            var A = f.data,
                                                w = A.stride,
                                                R = f.offset;
                                            if (A.isInstancedInterleavedBuffer) {
                                                for (var C = 0; C < d.locationSize; C++) v(d.location + C, A.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = A.meshPerAttribute * A.count)
                                            } else
                                                for (var L = 0; L < d.locationSize; L++) m(d.location + L);
                                            e.bindBuffer(e.ARRAY_BUFFER, S);
                                            for (var P = 0; P < d.locationSize; P++) _(d.location + P, x / d.locationSize, E, y, w * T, (R + x / d.locationSize * P) * T, b)
                                        } else {
                                            if (f.isInstancedBufferAttribute) {
                                                for (var k = 0; k < d.locationSize; k++) v(d.location + k, f.meshPerAttribute);
                                                !0 !== i.isInstancedMesh && void 0 === s._maxInstanceCount && (s._maxInstanceCount = f.meshPerAttribute * f.count)
                                            } else
                                                for (var I = 0; I < d.locationSize; I++) m(d.location + I);
                                            e.bindBuffer(e.ARRAY_BUFFER, S);
                                            for (var U = 0; U < d.locationSize; U++) _(d.location + U, x / d.locationSize, E, y, x * T, x / d.locationSize * U * T, b)
                                        }
                                    } else if (void 0 !== c) {
                                        var D = c[h];
                                        if (void 0 !== D) switch (D.length) {
                                            case 2:
                                                e.vertexAttrib2fv(d.location, D);
                                                break;
                                            case 3:
                                                e.vertexAttrib3fv(d.location, D);
                                                break;
                                            case 4:
                                                e.vertexAttrib4fv(d.location, D);
                                                break;
                                            default:
                                                e.vertexAttrib1fv(d.location, D)
                                        }
                                    }
                                }
                            }
                            g()
                        }(i, l, d, y), null !== x && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, n.get(x).buffer))
                    },
                    reset: y,
                    resetDefaultState: x,
                    dispose: function () {
                        for (var e in y(), s) {
                            var t = s[e];
                            for (var n in t) {
                                var r = t[n];
                                for (var i in r) d(r[i].object), delete r[i];
                                delete t[n]
                            }
                            delete s[e]
                        }
                    },
                    releaseStatesOfGeometry: function (e) {
                        if (void 0 !== s[e.id]) {
                            var t = s[e.id];
                            for (var n in t) {
                                var r = t[n];
                                for (var i in r) d(r[i].object), delete r[i];
                                delete t[n]
                            }
                            delete s[e.id]
                        }
                    },
                    releaseStatesOfProgram: function (e) {
                        for (var t in s) {
                            var n = s[t];
                            if (void 0 !== n[e.id]) {
                                var r = n[e.id];
                                for (var i in r) d(r[i].object), delete r[i];
                                delete n[e.id]
                            }
                        }
                    },
                    initAttributes: p,
                    enableAttribute: m,
                    disableUnusedAttributes: g
                }
            }

            function Ei(e, t, n, r) {
                var i, a = r.isWebGL2;
                this.setMode = function (e) {
                    i = e
                }, this.render = function (t, r) {
                    e.drawArrays(i, t, r), n.update(r, i, 1)
                }, this.renderInstances = function (r, o, s) {
                    if (0 !== s) {
                        var l, u;
                        if (a) l = e, u = "drawArraysInstanced";
                        else if (u = "drawArraysInstancedANGLE", null === (l = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        l[u](i, r, o, s), n.update(o, i, s)
                    }
                }
            }

            function Ti(e, t, n) {
                var r;

                function i(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                var a = "undefined" != typeof WebGL2RenderingContext && "WebGL2RenderingContext" === e.constructor.name,
                    o = void 0 !== n.precision ? n.precision : "highp",
                    s = i(o);
                s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s);
                var l = a || t.has("WEBGL_draw_buffers"),
                    u = !0 === n.logarithmicDepthBuffer,
                    c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                    h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    d = e.getParameter(e.MAX_TEXTURE_SIZE),
                    f = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
                    p = e.getParameter(e.MAX_VERTEX_ATTRIBS),
                    m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
                    v = e.getParameter(e.MAX_VARYING_VECTORS),
                    g = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
                    _ = h > 0,
                    y = a || t.has("OES_texture_float");
                return {
                    isWebGL2: a,
                    drawBuffers: l,
                    getMaxAnisotropy: function () {
                        if (void 0 !== r) return r;
                        if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                            var n = t.get("EXT_texture_filter_anisotropic");
                            r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else r = 0;
                        return r
                    },
                    getMaxPrecision: i,
                    precision: o,
                    logarithmicDepthBuffer: u,
                    maxTextures: c,
                    maxVertexTextures: h,
                    maxTextureSize: d,
                    maxCubemapSize: f,
                    maxAttributes: p,
                    maxVertexUniforms: m,
                    maxVaryings: v,
                    maxFragmentUniforms: g,
                    vertexTextures: _,
                    floatFragmentTextures: y,
                    floatVertexTextures: _ && y,
                    maxSamples: a ? e.getParameter(e.MAX_SAMPLES) : 0
                }
            }

            function bi(e) {
                var t = this,
                    n = null,
                    r = 0,
                    i = !1,
                    a = !1,
                    o = new ci,
                    s = new xt,
                    l = {
                        value: null,
                        needsUpdate: !1
                    };

                function u(e, n, r, i) {
                    var a = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== a) {
                        if (u = l.value, !0 !== i || null === u) {
                            var c = r + 4 * a,
                                h = n.matrixWorldInverse;
                            s.getNormalMatrix(h), (null === u || u.length < c) && (u = new Float32Array(c));
                            for (var d = 0, f = r; d !== a; ++d, f += 4) o.copy(e[d]).applyMatrix4(h, s), o.normal.toArray(u, f), u[f + 3] = o.constant
                        }
                        l.value = u, l.needsUpdate = !0
                    }
                    return t.numPlanes = a, t.numIntersection = 0, u
                }
                this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (e, t) {
                    var n = 0 !== e.length || t || 0 !== r || i;
                    return i = t, r = e.length, n
                }, this.beginShadows = function () {
                    a = !0, u(null)
                }, this.endShadows = function () {
                    a = !1
                }, this.setGlobalState = function (e, t) {
                    n = u(e, t, 0)
                }, this.setState = function (o, s, c) {
                    var h = o.clippingPlanes,
                        d = o.clipIntersection,
                        f = o.clipShadows,
                        p = e.get(o);
                    if (!i || null === h || 0 === h.length || a && !f) a ? u(null) : function () {
                        l.value !== n && (l.value = n, l.needsUpdate = r > 0);
                        t.numPlanes = r, t.numIntersection = 0
                    }();
                    else {
                        var m = a ? 0 : r,
                            v = 4 * m,
                            g = p.clippingState || null;
                        l.value = g, g = u(h, s, v, c);
                        for (var _ = 0; _ !== v; ++_) g[_] = n[_];
                        p.clippingState = g, this.numIntersection = d ? this.numPlanes : 0, this.numPlanes += m
                    }
                }
            }

            function Ai(e) {
                var t = new WeakMap;

                function n(e, t) {
                    return t === B ? e.mapping = O : t === z && (e.mapping = F), e
                }

                function r(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", r);
                    var i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function (i) {
                        if (i && i.isTexture && !1 === i.isRenderTargetTexture) {
                            var a = i.mapping;
                            if (a === B || a === z) {
                                if (t.has(i)) return n(t.get(i).texture, i.mapping);
                                var o = i.image;
                                if (o && o.height > 0) {
                                    var s = new oi(o.height / 2);
                                    return s.fromEquirectangularTexture(e, i), t.set(i, s), i.addEventListener("dispose", r), n(s.texture, i.mapping)
                                }
                                return null
                            }
                        }
                        return i
                    },
                    dispose: function () {
                        t = new WeakMap
                    }
                }
            }
            var wi = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : -1,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : -1,
                            l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : .1,
                            u = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2e3;
                        return i(this, n), (e = t.call(this)).isOrthographicCamera = !0, e.type = "OrthographicCamera", e.zoom = 1, e.view = null, e.left = r, e.right = a, e.top = o, e.bottom = s, e.near = l, e.far = u, e.updateProjectionMatrix(), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = null === e.view ? null : Object.assign({}, e.view), this
                        }
                    }, {
                        key: "setViewOffset",
                        value: function (e, t, n, r, i, a) {
                            null === this.view && (this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = a, this.updateProjectionMatrix()
                        }
                    }, {
                        key: "clearViewOffset",
                        value: function () {
                            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                        }
                    }, {
                        key: "updateProjectionMatrix",
                        value: function () {
                            var e = (this.right - this.left) / (2 * this.zoom),
                                t = (this.top - this.bottom) / (2 * this.zoom),
                                n = (this.right + this.left) / 2,
                                r = (this.top + this.bottom) / 2,
                                i = n - e,
                                a = n + e,
                                o = r + t,
                                s = r - t;
                            if (null !== this.view && this.view.enabled) {
                                var l = (this.right - this.left) / this.view.fullWidth / this.zoom,
                                    u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                                a = (i += l * this.view.offsetX) + l * this.view.width, s = (o -= u * this.view.offsetY) - u * this.view.height
                            }
                            this.projectionMatrix.makeOrthographic(i, a, o, s, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
                        }
                    }]), n
                }(ti),
                Ri = [.125, .215, .35, .446, .526, .582],
                Ci = 20,
                Li = new wi,
                Pi = new fr,
                ki = null,
                Ii = (1 + Math.sqrt(5)) / 2,
                Ui = 1 / Ii,
                Di = [new Xt(1, 1, 1), new Xt(-1, 1, 1), new Xt(1, 1, -1), new Xt(-1, 1, -1), new Xt(0, Ii, Ui), new Xt(0, Ii, -Ui), new Xt(Ui, 0, Ii), new Xt(-Ui, 0, Ii), new Xt(Ii, Ui, 0), new Xt(-Ii, Ui, 0)],
                Ni = function () {
                    function e(t) {
                        i(this, e), this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
                    }
                    return o(e, [{
                        key: "fromScene",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : .1,
                                r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 100;
                            ki = this._renderer.getRenderTarget(), this._setSize(256);
                            var i = this._allocateTargets();
                            return i.depthBuffer = !0, this._sceneToCubeUV(e, n, r, i), t > 0 && this._blur(i, 0, 0, t), this._applyPMREM(i), this._cleanup(i), i
                        }
                    }, {
                        key: "fromEquirectangular",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            return this._fromTexture(e, t)
                        }
                    }, {
                        key: "fromCubemap",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                            return this._fromTexture(e, t)
                        }
                    }, {
                        key: "compileCubemapShader",
                        value: function () {
                            null === this._cubemapMaterial && (this._cubemapMaterial = zi(), this._compileMaterial(this._cubemapMaterial))
                        }
                    }, {
                        key: "compileEquirectangularShader",
                        value: function () {
                            null === this._equirectMaterial && (this._equirectMaterial = Bi(), this._compileMaterial(this._equirectMaterial))
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this._dispose(), null !== this._cubemapMaterial && this._cubemapMaterial.dispose(), null !== this._equirectMaterial && this._equirectMaterial.dispose()
                        }
                    }, {
                        key: "_setSize",
                        value: function (e) {
                            this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
                        }
                    }, {
                        key: "_dispose",
                        value: function () {
                            null !== this._blurMaterial && this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose();
                            for (var e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
                        }
                    }, {
                        key: "_cleanup",
                        value: function (e) {
                            this._renderer.setRenderTarget(ki), e.scissorTest = !1, Fi(e, 0, 0, e.width, e.height)
                        }
                    }, {
                        key: "_fromTexture",
                        value: function (e, t) {
                            e.mapping === O || e.mapping === F ? this._setSize(0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), ki = this._renderer.getRenderTarget();
                            var n = t || this._allocateTargets();
                            return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
                        }
                    }, {
                        key: "_allocateTargets",
                        value: function () {
                            var e = 3 * Math.max(this._cubeSize, 112),
                                t = 4 * this._cubeSize,
                                n = {
                                    magFilter: Y,
                                    minFilter: Y,
                                    generateMipmaps: !1,
                                    type: ne,
                                    format: oe,
                                    colorSpace: Ze,
                                    depthBuffer: !1
                                },
                                r = Oi(e, t, n);
                            if (null === this._pingPongRenderTarget || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
                                null !== this._pingPongRenderTarget && this._dispose(), this._pingPongRenderTarget = Oi(e, t, n);
                                var i = this._lodMax,
                                    a = function (e) {
                                        for (var t = [], n = [], r = [], i = e, a = e - 4 + 1 + Ri.length, o = 0; o < a; o++) {
                                            var s = Math.pow(2, i);
                                            n.push(s);
                                            var l = 1 / s;
                                            o > e - 4 ? l = Ri[o - e + 4 - 1] : 0 === o && (l = 0), r.push(l);
                                            for (var u = 1 / (s - 2), c = -u, h = 1 + u, d = [c, c, h, c, h, h, c, c, h, h, c, h], f = 6, p = 6, m = 3, v = 2, g = 1, _ = new Float32Array(m * p * f), y = new Float32Array(v * p * f), x = new Float32Array(g * p * f), M = 0; M < f; M++) {
                                                var S = M % 3 * 2 / 3 - 1,
                                                    E = M > 2 ? 0 : -1,
                                                    T = [S, E, 0, S + 2 / 3, E, 0, S + 2 / 3, E + 1, 0, S, E, 0, S + 2 / 3, E + 1, 0, S, E + 1, 0];
                                                _.set(T, m * p * M), y.set(d, v * p * M);
                                                var b = [M, M, M, M, M, M];
                                                x.set(b, g * p * M)
                                            }
                                            var A = new Cr;
                                            A.setAttribute("position", new _r(_, m)), A.setAttribute("uv", new _r(y, v)), A.setAttribute("faceIndex", new _r(x, g)), t.push(A), i > 4 && i--
                                        }
                                        return {
                                            lodPlanes: t,
                                            sizeLods: n,
                                            sigmas: r
                                        }
                                    }(i);
                                this._sizeLods = a.sizeLods, this._lodPlanes = a.lodPlanes, this._sigmas = a.sigmas, this._blurMaterial = function (e, t, n) {
                                    var r = new Float32Array(Ci),
                                        i = new Xt(0, 1, 0),
                                        a = new ei({
                                            name: "SphericalGaussianBlur",
                                            defines: {
                                                n: Ci,
                                                CUBEUV_TEXEL_WIDTH: 1 / t,
                                                CUBEUV_TEXEL_HEIGHT: 1 / n,
                                                CUBEUV_MAX_MIP: "".concat(e, ".0")
                                            },
                                            uniforms: {
                                                envMap: {
                                                    value: null
                                                },
                                                samples: {
                                                    value: 1
                                                },
                                                weights: {
                                                    value: r
                                                },
                                                latitudinal: {
                                                    value: !1
                                                },
                                                dTheta: {
                                                    value: 0
                                                },
                                                mipInt: {
                                                    value: 0
                                                },
                                                poleAxis: {
                                                    value: i
                                                }
                                            },
                                            vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                                            fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                                            blending: 0,
                                            depthTest: !1,
                                            depthWrite: !1
                                        });
                                    return a
                                }(i, e, t)
                            }
                            return r
                        }
                    }, {
                        key: "_compileMaterial",
                        value: function (e) {
                            var t = new qr(this._lodPlanes[0], e);
                            this._renderer.compile(t, Li)
                        }
                    }, {
                        key: "_sceneToCubeUV",
                        value: function (e, t, n, r) {
                            var i = new ni(90, 1, t, n),
                                a = [1, -1, 1, 1, 1, 1],
                                o = [1, 1, 1, -1, -1, -1],
                                s = this._renderer,
                                l = s.autoClear,
                                u = s.toneMapping;
                            s.getClearColor(Pi), s.toneMapping = 0, s.autoClear = !1;
                            var c = new mr({
                                    name: "PMREM.Background",
                                    side: 1,
                                    depthWrite: !1,
                                    depthTest: !1
                                }),
                                h = new qr(new Kr, c),
                                d = !1,
                                f = e.background;
                            f ? f.isColor && (c.color.copy(f), e.background = null, d = !0) : (c.color.copy(Pi), d = !0);
                            for (var p = 0; p < 6; p++) {
                                var m = p % 3;
                                0 === m ? (i.up.set(0, a[p], 0), i.lookAt(o[p], 0, 0)) : 1 === m ? (i.up.set(0, 0, a[p]), i.lookAt(0, o[p], 0)) : (i.up.set(0, a[p], 0), i.lookAt(0, 0, o[p]));
                                var v = this._cubeSize;
                                Fi(r, m * v, p > 2 ? v : 0, v, v), s.setRenderTarget(r), d && s.render(h, i), s.render(e, i)
                            }
                            h.geometry.dispose(), h.material.dispose(), s.toneMapping = u, s.autoClear = l, e.background = f
                        }
                    }, {
                        key: "_textureToCubeUV",
                        value: function (e, t) {
                            var n = this._renderer,
                                r = e.mapping === O || e.mapping === F;
                            r ? (null === this._cubemapMaterial && (this._cubemapMaterial = zi()), this._cubemapMaterial.uniforms.flipEnvMap.value = !1 === e.isRenderTargetTexture ? -1 : 1) : null === this._equirectMaterial && (this._equirectMaterial = Bi());
                            var i = r ? this._cubemapMaterial : this._equirectMaterial,
                                a = new qr(this._lodPlanes[0], i);
                            i.uniforms.envMap.value = e;
                            var o = this._cubeSize;
                            Fi(t, 0, 0, 3 * o, 2 * o), n.setRenderTarget(t), n.render(a, Li)
                        }
                    }, {
                        key: "_applyPMREM",
                        value: function (e) {
                            var t = this._renderer,
                                n = t.autoClear;
                            t.autoClear = !1;
                            for (var r = 1; r < this._lodPlanes.length; r++) {
                                var i = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
                                    a = Di[(r - 1) % Di.length];
                                this._blur(e, r - 1, r, i, a)
                            }
                            t.autoClear = n
                        }
                    }, {
                        key: "_blur",
                        value: function (e, t, n, r, i) {
                            var a = this._pingPongRenderTarget;
                            this._halfBlur(e, a, t, n, r, "latitudinal", i), this._halfBlur(a, e, n, n, r, "longitudinal", i)
                        }
                    }, {
                        key: "_halfBlur",
                        value: function (e, t, n, r, i, a, o) {
                            var s = this._renderer,
                                l = this._blurMaterial;
                            "latitudinal" !== a && "longitudinal" !== a && console.error("blur direction must be either latitudinal or longitudinal!");
                            var u = new qr(this._lodPlanes[r], l),
                                c = l.uniforms,
                                h = this._sizeLods[n] - 1,
                                d = isFinite(i) ? Math.PI / (2 * h) : 2 * Math.PI / 39,
                                f = i / d,
                                p = isFinite(i) ? 1 + Math.floor(3 * f) : Ci;
                            p > Ci && console.warn("sigmaRadians, ".concat(i, ", is too large and will clip, as it requested ").concat(p, " samples when the maximum is set to ").concat(Ci));
                            for (var m = [], v = 0, g = 0; g < Ci; ++g) {
                                var _ = g / f,
                                    y = Math.exp(-_ * _ / 2);
                                m.push(y), 0 === g ? v += y : g < p && (v += 2 * y)
                            }
                            for (var x = 0; x < m.length; x++) m[x] = m[x] / v;
                            c.envMap.value = e.texture, c.samples.value = p, c.weights.value = m, c.latitudinal.value = "latitudinal" === a, o && (c.poleAxis.value = o);
                            var M = this._lodMax;
                            c.dTheta.value = d, c.mipInt.value = M - n;
                            var S = this._sizeLods[r];
                            Fi(t, 3 * S * (r > M - 4 ? r - M + 4 : 0), 4 * (this._cubeSize - S), 3 * S, 2 * S), s.setRenderTarget(t), s.render(u, Li)
                        }
                    }]), e
                }();

            function Oi(e, t, n) {
                var r = new Gt(e, t, n);
                return r.texture.mapping = H, r.texture.name = "PMREM.cubeUv", r.scissorTest = !0, r
            }

            function Fi(e, t, n, r, i) {
                e.viewport.set(t, n, r, i), e.scissor.set(t, n, r, i)
            }

            function Bi() {
                return new ei({
                    name: "EquirectangularToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function zi() {
                return new ei({
                    name: "CubemapToCubeUV",
                    uniforms: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        }
                    },
                    vertexShader: "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t",
                    fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
                    blending: 0,
                    depthTest: !1,
                    depthWrite: !1
                })
            }

            function Hi(e) {
                var t = new WeakMap,
                    n = null;

                function r(e) {
                    var n = e.target;
                    n.removeEventListener("dispose", r);
                    var i = t.get(n);
                    void 0 !== i && (t.delete(n), i.dispose())
                }
                return {
                    get: function (i) {
                        if (i && i.isTexture) {
                            var a = i.mapping,
                                o = a === B || a === z,
                                s = a === O || a === F;
                            if (o || s) {
                                if (i.isRenderTargetTexture && !0 === i.needsPMREMUpdate) {
                                    i.needsPMREMUpdate = !1;
                                    var l = t.get(i);
                                    return null === n && (n = new Ni(e)), l = o ? n.fromEquirectangular(i, l) : n.fromCubemap(i, l), t.set(i, l), l.texture
                                }
                                if (t.has(i)) return t.get(i).texture;
                                var u = i.image;
                                if (o && u && u.height > 0 || s && u && function (e) {
                                        for (var t = 0, n = 6, r = 0; r < n; r++) void 0 !== e[r] && t++;
                                        return t === n
                                    }(u)) {
                                    null === n && (n = new Ni(e));
                                    var c = o ? n.fromEquirectangular(i) : n.fromCubemap(i);
                                    return t.set(i, c), i.addEventListener("dispose", r), c.texture
                                }
                                return null
                            }
                        }
                        return i
                    },
                    dispose: function () {
                        t = new WeakMap, null !== n && (n.dispose(), n = null)
                    }
                }
            }

            function Gi(e) {
                var t = {};

                function n(n) {
                    if (void 0 !== t[n]) return t[n];
                    var r;
                    switch (n) {
                        case "WEBGL_depth_texture":
                            r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                            break;
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        default:
                            r = e.getExtension(n)
                    }
                    return t[n] = r, r
                }
                return {
                    has: function (e) {
                        return null !== n(e)
                    },
                    init: function (e) {
                        e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
                    },
                    get: function (e) {
                        var t = n(e);
                        return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."), t
                    }
                }
            }

            function Vi(e, t, n, r) {
                var i = {},
                    a = new WeakMap;

                function o(e) {
                    var s = e.target;
                    for (var l in null !== s.index && t.remove(s.index), s.attributes) t.remove(s.attributes[l]);
                    for (var u in s.morphAttributes)
                        for (var c = s.morphAttributes[u], h = 0, d = c.length; h < d; h++) t.remove(c[h]);
                    s.removeEventListener("dispose", o), delete i[s.id];
                    var f = a.get(s);
                    f && (t.remove(f), a.delete(s)), r.releaseStatesOfGeometry(s), !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount, n.memory.geometries--
                }

                function s(e) {
                    var n = [],
                        r = e.index,
                        i = e.attributes.position,
                        o = 0;
                    if (null !== r) {
                        var s = r.array;
                        o = r.version;
                        for (var l = 0, u = s.length; l < u; l += 3) {
                            var c = s[l + 0],
                                h = s[l + 1],
                                d = s[l + 2];
                            n.push(c, h, h, d, d, c)
                        }
                    } else {
                        if (void 0 === i) return;
                        var f = i.array;
                        o = i.version;
                        for (var p = 0, m = f.length / 3 - 1; p < m; p += 3) {
                            var v = p + 0,
                                g = p + 1,
                                _ = p + 2;
                            n.push(v, g, g, _, _, v)
                        }
                    }
                    var y = new(St(n) ? xr : yr)(n, 1);
                    y.version = o;
                    var x = a.get(e);
                    x && t.remove(x), a.set(e, y)
                }
                return {
                    get: function (e, t) {
                        return !0 === i[t.id] || (t.addEventListener("dispose", o), i[t.id] = !0, n.memory.geometries++), t
                    },
                    update: function (n) {
                        var r = n.attributes;
                        for (var i in r) t.update(r[i], e.ARRAY_BUFFER);
                        var a = n.morphAttributes;
                        for (var o in a)
                            for (var s = a[o], l = 0, u = s.length; l < u; l++) t.update(s[l], e.ARRAY_BUFFER)
                    },
                    getWireframeAttribute: function (e) {
                        var t = a.get(e);
                        if (t) {
                            var n = e.index;
                            null !== n && t.version < n.version && s(e)
                        } else s(e);
                        return a.get(e)
                    }
                }
            }

            function Wi(e, t, n, r) {
                var i, a, o, s = r.isWebGL2;
                this.setMode = function (e) {
                    i = e
                }, this.setIndex = function (e) {
                    a = e.type, o = e.bytesPerElement
                }, this.render = function (t, r) {
                    e.drawElements(i, r, a, t * o), n.update(r, i, 1)
                }, this.renderInstances = function (r, l, u) {
                    if (0 !== u) {
                        var c, h;
                        if (s) c = e, h = "drawElementsInstanced";
                        else if (h = "drawElementsInstancedANGLE", null === (c = t.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                        c[h](i, l, a, r * o, u), n.update(l, i, u)
                    }
                }
            }

            function ji(e) {
                var t = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: t,
                    programs: null,
                    autoReset: !0,
                    reset: function () {
                        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
                    },
                    update: function (n, r, i) {
                        switch (t.calls++, r) {
                            case e.TRIANGLES:
                                t.triangles += i * (n / 3);
                                break;
                            case e.LINES:
                                t.lines += i * (n / 2);
                                break;
                            case e.LINE_STRIP:
                                t.lines += i * (n - 1);
                                break;
                            case e.LINE_LOOP:
                                t.lines += i * n;
                                break;
                            case e.POINTS:
                                t.points += i * n;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", r)
                        }
                    }
                }
            }

            function Xi(e, t) {
                return e[0] - t[0]
            }

            function qi(e, t) {
                return Math.abs(t[1]) - Math.abs(e[1])
            }

            function Yi(e, t, n) {
                for (var r = {}, i = new Float32Array(8), a = new WeakMap, o = new zt, s = [], l = 0; l < 8; l++) s[l] = [l, 0];
                return {
                    update: function (l, u, c) {
                        var h = l.morphTargetInfluences;
                        if (!0 === t.isWebGL2) {
                            var d = u.morphAttributes.position || u.morphAttributes.normal || u.morphAttributes.color,
                                f = void 0 !== d ? d.length : 0,
                                p = a.get(u);
                            if (void 0 === p || p.count !== f) {
                                void 0 !== p && p.texture.dispose();
                                var m = void 0 !== u.morphAttributes.position,
                                    v = void 0 !== u.morphAttributes.normal,
                                    g = void 0 !== u.morphAttributes.color,
                                    _ = u.morphAttributes.position || [],
                                    y = u.morphAttributes.normal || [],
                                    x = u.morphAttributes.color || [],
                                    M = 0;
                                !0 === m && (M = 1), !0 === v && (M = 2), !0 === g && (M = 3);
                                var S = u.attributes.position.count * M,
                                    E = 1;
                                S > t.maxTextureSize && (E = Math.ceil(S / t.maxTextureSize), S = t.maxTextureSize);
                                var T = new Float32Array(S * E * 4 * f),
                                    b = new Vt(T, S, E, f);
                                b.type = te, b.needsUpdate = !0;
                                for (var A = 4 * M, w = 0; w < f; w++)
                                    for (var R = _[w], C = y[w], L = x[w], P = S * E * 4 * w, k = 0; k < R.count; k++) {
                                        var I = k * A;
                                        !0 === m && (o.fromBufferAttribute(R, k), T[P + I + 0] = o.x, T[P + I + 1] = o.y, T[P + I + 2] = o.z, T[P + I + 3] = 0), !0 === v && (o.fromBufferAttribute(C, k), T[P + I + 4] = o.x, T[P + I + 5] = o.y, T[P + I + 6] = o.z, T[P + I + 7] = 0), !0 === g && (o.fromBufferAttribute(L, k), T[P + I + 8] = o.x, T[P + I + 9] = o.y, T[P + I + 10] = o.z, T[P + I + 11] = 4 === L.itemSize ? o.w : 1)
                                    }

                                function J() {
                                    b.dispose(), a.delete(u), u.removeEventListener("dispose", J)
                                }
                                p = {
                                    count: f,
                                    texture: b,
                                    size: new yt(S, E)
                                }, a.set(u, p), u.addEventListener("dispose", J)
                            }
                            for (var U = 0, D = 0; D < h.length; D++) U += h[D];
                            var N = u.morphTargetsRelative ? 1 : 1 - U;
                            c.getUniforms().setValue(e, "morphTargetBaseInfluence", N), c.getUniforms().setValue(e, "morphTargetInfluences", h), c.getUniforms().setValue(e, "morphTargetsTexture", p.texture, n), c.getUniforms().setValue(e, "morphTargetsTextureSize", p.size)
                        } else {
                            var O = void 0 === h ? 0 : h.length,
                                F = r[u.id];
                            if (void 0 === F || F.length !== O) {
                                F = [];
                                for (var B = 0; B < O; B++) F[B] = [B, 0];
                                r[u.id] = F
                            }
                            for (var z = 0; z < O; z++) {
                                var H = F[z];
                                H[0] = z, H[1] = h[z]
                            }
                            F.sort(qi);
                            for (var G = 0; G < 8; G++) G < O && F[G][1] ? (s[G][0] = F[G][0], s[G][1] = F[G][1]) : (s[G][0] = Number.MAX_SAFE_INTEGER, s[G][1] = 0);
                            s.sort(Xi);
                            for (var V = u.morphAttributes.position, W = u.morphAttributes.normal, j = 0, X = 0; X < 8; X++) {
                                var q = s[X],
                                    Y = q[0],
                                    K = q[1];
                                Y !== Number.MAX_SAFE_INTEGER && K ? (V && u.getAttribute("morphTarget" + X) !== V[Y] && u.setAttribute("morphTarget" + X, V[Y]), W && u.getAttribute("morphNormal" + X) !== W[Y] && u.setAttribute("morphNormal" + X, W[Y]), i[X] = K, j += K) : (V && !0 === u.hasAttribute("morphTarget" + X) && u.deleteAttribute("morphTarget" + X), W && !0 === u.hasAttribute("morphNormal" + X) && u.deleteAttribute("morphNormal" + X), i[X] = 0)
                            }
                            var Z = u.morphTargetsRelative ? 1 : 1 - j;
                            c.getUniforms().setValue(e, "morphTargetBaseInfluence", Z), c.getUniforms().setValue(e, "morphTargetInfluences", i)
                        }
                    }
                }
            }

            function Ki(e, t, n, r) {
                var i = new WeakMap;

                function a(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", a), n.remove(t.instanceMatrix), null !== t.instanceColor && n.remove(t.instanceColor)
                }
                return {
                    update: function (o) {
                        var s = r.render.frame,
                            l = o.geometry,
                            u = t.get(o, l);
                        if (i.get(u) !== s && (t.update(u), i.set(u, s)), o.isInstancedMesh && (!1 === o.hasEventListener("dispose", a) && o.addEventListener("dispose", a), i.get(o) !== s && (n.update(o.instanceMatrix, e.ARRAY_BUFFER), null !== o.instanceColor && n.update(o.instanceColor, e.ARRAY_BUFFER), i.set(o, s))), o.isSkinnedMesh) {
                            var c = o.skeleton;
                            i.get(c) !== s && (c.update(), i.set(c, s))
                        }
                        return u
                    },
                    dispose: function () {
                        i = new WeakMap
                    }
                }
            }
            var Zi = new Bt,
                Ji = new Vt,
                Qi = new Wt,
                $i = new ai,
                ea = [],
                ta = [],
                na = new Float32Array(16),
                ra = new Float32Array(9),
                ia = new Float32Array(4);

            function aa(e, t, n) {
                var r = e[0];
                if (r <= 0 || r > 0) return e;
                var i = t * n,
                    a = ea[i];
                if (void 0 === a && (a = new Float32Array(i), ea[i] = a), 0 !== t) {
                    r.toArray(a, 0);
                    for (var o = 1, s = 0; o !== t; ++o) s += n, e[o].toArray(a, s)
                }
                return a
            }

            function oa(e, t) {
                if (e.length !== t.length) return !1;
                for (var n = 0, r = e.length; n < r; n++)
                    if (e[n] !== t[n]) return !1;
                return !0
            }

            function sa(e, t) {
                for (var n = 0, r = t.length; n < r; n++) e[n] = t[n]
            }

            function la(e, t) {
                var n = ta[t];
                void 0 === n && (n = new Int32Array(t), ta[t] = n);
                for (var r = 0; r !== t; ++r) n[r] = e.allocateTextureUnit();
                return n
            }

            function ua(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1f(this.addr, t), n[0] = t)
            }

            function ca(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (oa(n, t)) return;
                    e.uniform2fv(this.addr, t), sa(n, t)
                }
            }

            function ha(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else if (void 0 !== t.r) n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b), n[0] = t.r, n[1] = t.g, n[2] = t.b);
                else {
                    if (oa(n, t)) return;
                    e.uniform3fv(this.addr, t), sa(n, t)
                }
            }

            function da(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (oa(n, t)) return;
                    e.uniform4fv(this.addr, t), sa(n, t)
                }
            }

            function fa(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (oa(n, t)) return;
                    e.uniformMatrix2fv(this.addr, !1, t), sa(n, t)
                } else {
                    if (oa(n, r)) return;
                    ia.set(r), e.uniformMatrix2fv(this.addr, !1, ia), sa(n, r)
                }
            }

            function pa(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (oa(n, t)) return;
                    e.uniformMatrix3fv(this.addr, !1, t), sa(n, t)
                } else {
                    if (oa(n, r)) return;
                    ra.set(r), e.uniformMatrix3fv(this.addr, !1, ra), sa(n, r)
                }
            }

            function ma(e, t) {
                var n = this.cache,
                    r = t.elements;
                if (void 0 === r) {
                    if (oa(n, t)) return;
                    e.uniformMatrix4fv(this.addr, !1, t), sa(n, t)
                } else {
                    if (oa(n, r)) return;
                    na.set(r), e.uniformMatrix4fv(this.addr, !1, na), sa(n, r)
                }
            }

            function va(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1i(this.addr, t), n[0] = t)
            }

            function ga(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2i(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (oa(n, t)) return;
                    e.uniform2iv(this.addr, t), sa(n, t)
                }
            }

            function _a(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3i(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (oa(n, t)) return;
                    e.uniform3iv(this.addr, t), sa(n, t)
                }
            }

            function ya(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4i(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (oa(n, t)) return;
                    e.uniform4iv(this.addr, t), sa(n, t)
                }
            }

            function xa(e, t) {
                var n = this.cache;
                n[0] !== t && (e.uniform1ui(this.addr, t), n[0] = t)
            }

            function Ma(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y || (e.uniform2ui(this.addr, t.x, t.y), n[0] = t.x, n[1] = t.y);
                else {
                    if (oa(n, t)) return;
                    e.uniform2uiv(this.addr, t), sa(n, t)
                }
            }

            function Sa(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3ui(this.addr, t.x, t.y, t.z), n[0] = t.x, n[1] = t.y, n[2] = t.z);
                else {
                    if (oa(n, t)) return;
                    e.uniform3uiv(this.addr, t), sa(n, t)
                }
            }

            function Ea(e, t) {
                var n = this.cache;
                if (void 0 !== t.x) n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w), n[0] = t.x, n[1] = t.y, n[2] = t.z, n[3] = t.w);
                else {
                    if (oa(n, t)) return;
                    e.uniform4uiv(this.addr, t), sa(n, t)
                }
            }

            function Ta(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2D(t || Zi, i)
            }

            function ba(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(t || Qi, i)
            }

            function Aa(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTextureCube(t || $i, i)
            }

            function wa(e, t, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (e.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(t || Ji, i)
            }

            function Ra(e, t) {
                e.uniform1fv(this.addr, t)
            }

            function Ca(e, t) {
                var n = aa(t, this.size, 2);
                e.uniform2fv(this.addr, n)
            }

            function La(e, t) {
                var n = aa(t, this.size, 3);
                e.uniform3fv(this.addr, n)
            }

            function Pa(e, t) {
                var n = aa(t, this.size, 4);
                e.uniform4fv(this.addr, n)
            }

            function ka(e, t) {
                var n = aa(t, this.size, 4);
                e.uniformMatrix2fv(this.addr, !1, n)
            }

            function Ia(e, t) {
                var n = aa(t, this.size, 9);
                e.uniformMatrix3fv(this.addr, !1, n)
            }

            function Ua(e, t) {
                var n = aa(t, this.size, 16);
                e.uniformMatrix4fv(this.addr, !1, n)
            }

            function Da(e, t) {
                e.uniform1iv(this.addr, t)
            }

            function Na(e, t) {
                e.uniform2iv(this.addr, t)
            }

            function Oa(e, t) {
                e.uniform3iv(this.addr, t)
            }

            function Fa(e, t) {
                e.uniform4iv(this.addr, t)
            }

            function Ba(e, t) {
                e.uniform1uiv(this.addr, t)
            }

            function za(e, t) {
                e.uniform2uiv(this.addr, t)
            }

            function Ha(e, t) {
                e.uniform3uiv(this.addr, t)
            }

            function Ga(e, t) {
                e.uniform4uiv(this.addr, t)
            }

            function Va(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    a = la(n, i);
                oa(r, a) || (e.uniform1iv(this.addr, a), sa(r, a));
                for (var o = 0; o !== i; ++o) n.setTexture2D(t[o] || Zi, a[o])
            }

            function Wa(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    a = la(n, i);
                oa(r, a) || (e.uniform1iv(this.addr, a), sa(r, a));
                for (var o = 0; o !== i; ++o) n.setTexture3D(t[o] || Qi, a[o])
            }

            function ja(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    a = la(n, i);
                oa(r, a) || (e.uniform1iv(this.addr, a), sa(r, a));
                for (var o = 0; o !== i; ++o) n.setTextureCube(t[o] || $i, a[o])
            }

            function Xa(e, t, n) {
                var r = this.cache,
                    i = t.length,
                    a = la(n, i);
                oa(r, a) || (e.uniform1iv(this.addr, a), sa(r, a));
                for (var o = 0; o !== i; ++o) n.setTexture2DArray(t[o] || Ji, a[o])
            }
            var qa = o((function e(t, n, r) {
                    i(this, e), this.id = t, this.addr = r, this.cache = [], this.setValue = function (e) {
                        switch (e) {
                            case 5126:
                                return ua;
                            case 35664:
                                return ca;
                            case 35665:
                                return ha;
                            case 35666:
                                return da;
                            case 35674:
                                return fa;
                            case 35675:
                                return pa;
                            case 35676:
                                return ma;
                            case 5124:
                            case 35670:
                                return va;
                            case 35667:
                            case 35671:
                                return ga;
                            case 35668:
                            case 35672:
                                return _a;
                            case 35669:
                            case 35673:
                                return ya;
                            case 5125:
                                return xa;
                            case 36294:
                                return Ma;
                            case 36295:
                                return Sa;
                            case 36296:
                                return Ea;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Ta;
                            case 35679:
                            case 36299:
                            case 36307:
                                return ba;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return Aa;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return wa
                        }
                    }(n.type)
                })),
                Ya = o((function e(t, n, r) {
                    i(this, e), this.id = t, this.addr = r, this.cache = [], this.size = n.size, this.setValue = function (e) {
                        switch (e) {
                            case 5126:
                                return Ra;
                            case 35664:
                                return Ca;
                            case 35665:
                                return La;
                            case 35666:
                                return Pa;
                            case 35674:
                                return ka;
                            case 35675:
                                return Ia;
                            case 35676:
                                return Ua;
                            case 5124:
                            case 35670:
                                return Da;
                            case 35667:
                            case 35671:
                                return Na;
                            case 35668:
                            case 35672:
                                return Oa;
                            case 35669:
                            case 35673:
                                return Fa;
                            case 5125:
                                return Ba;
                            case 36294:
                                return za;
                            case 36295:
                                return Ha;
                            case 36296:
                                return Ga;
                            case 35678:
                            case 36198:
                            case 36298:
                            case 36306:
                            case 35682:
                                return Va;
                            case 35679:
                            case 36299:
                            case 36307:
                                return Wa;
                            case 35680:
                            case 36300:
                            case 36308:
                            case 36293:
                                return ja;
                            case 36289:
                            case 36303:
                            case 36311:
                            case 36292:
                                return Xa
                        }
                    }(n.type)
                })),
                Ka = function () {
                    function e(t) {
                        i(this, e), this.id = t, this.seq = [], this.map = {}
                    }
                    return o(e, [{
                        key: "setValue",
                        value: function (e, t, n) {
                            for (var r = this.seq, i = 0, a = r.length; i !== a; ++i) {
                                var o = r[i];
                                o.setValue(e, t[o.id], n)
                            }
                        }
                    }]), e
                }(),
                Za = /(\w+)(\])?(\[|\.)?/g;

            function Ja(e, t) {
                e.seq.push(t), e.map[t.id] = t
            }

            function Qa(e, t, n) {
                var r = e.name,
                    i = r.length;
                for (Za.lastIndex = 0;;) {
                    var a = Za.exec(r),
                        o = Za.lastIndex,
                        s = a[1],
                        l = "]" === a[2],
                        u = a[3];
                    if (l && (s |= 0), void 0 === u || "[" === u && o + 2 === i) {
                        Ja(n, void 0 === u ? new qa(s, e, t) : new Ya(s, e, t));
                        break
                    }
                    var c = n.map[s];
                    void 0 === c && Ja(n, c = new Ka(s)), n = c
                }
            }
            var $a = function () {
                function e(t, n) {
                    i(this, e), this.seq = [], this.map = {};
                    for (var r = t.getProgramParameter(n, t.ACTIVE_UNIFORMS), a = 0; a < r; ++a) {
                        var o = t.getActiveUniform(n, a);
                        Qa(o, t.getUniformLocation(n, o.name), this)
                    }
                }
                return o(e, [{
                    key: "setValue",
                    value: function (e, t, n, r) {
                        var i = this.map[t];
                        void 0 !== i && i.setValue(e, n, r)
                    }
                }, {
                    key: "setOptional",
                    value: function (e, t, n) {
                        var r = t[n];
                        void 0 !== r && this.setValue(e, n, r)
                    }
                }], [{
                    key: "upload",
                    value: function (e, t, n, r) {
                        for (var i = 0, a = t.length; i !== a; ++i) {
                            var o = t[i],
                                s = n[o.id];
                            !1 !== s.needsUpdate && o.setValue(e, s.value, r)
                        }
                    }
                }, {
                    key: "seqWithValue",
                    value: function (e, t) {
                        for (var n = [], r = 0, i = e.length; r !== i; ++r) {
                            var a = e[r];
                            a.id in t && n.push(a)
                        }
                        return n
                    }
                }]), e
            }();

            function eo(e, t, n) {
                var r = e.createShader(t);
                return e.shaderSource(r, n), e.compileShader(r), r
            }
            var to = 0;

            function no(e, t, n) {
                var r = e.getShaderParameter(t, e.COMPILE_STATUS),
                    i = e.getShaderInfoLog(t).trim();
                if (r && "" === i) return "";
                var a = /ERROR: 0:(\d+)/.exec(i);
                if (a) {
                    var o = parseInt(a[1]);
                    return n.toUpperCase() + "\n\n" + i + "\n\n" + function (e, t) {
                        for (var n = e.split("\n"), r = [], i = Math.max(t - 6, 0), a = Math.min(t + 6, n.length), o = i; o < a; o++) {
                            var s = o + 1;
                            r.push("".concat(s === t ? ">" : " ", " ").concat(s, ": ").concat(n[o]))
                        }
                        return r.join("\n")
                    }(e.getShaderSource(t), o)
                }
                return i
            }

            function ro(e, t) {
                var n = function (e) {
                    switch (e) {
                        case Ze:
                            return ["Linear", "( value )"];
                        case Ke:
                            return ["sRGB", "( value )"];
                        default:
                            return console.warn("THREE.WebGLProgram: Unsupported color space:", e), ["Linear", "( value )"]
                    }
                }(t);
                return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function io(e, t) {
                var n;
                switch (t) {
                    case 1:
                        n = "Linear";
                        break;
                    case 2:
                        n = "Reinhard";
                        break;
                    case 3:
                        n = "OptimizedCineon";
                        break;
                    case 4:
                        n = "ACESFilmic";
                        break;
                    case 5:
                        n = "Custom";
                        break;
                    default:
                        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), n = "Linear"
                }
                return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function ao(e) {
                return "" !== e
            }

            function oo(e, t) {
                var n = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
                return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, n).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
            }

            function so(e, t) {
                return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
            }
            var lo = /^[ \t]*#include +<([\w\d./]+)>/gm;

            function uo(e) {
                return e.replace(lo, ho)
            }
            var co = new Map([
                ["encodings_fragment", "colorspace_fragment"],
                ["encodings_pars_fragment", "colorspace_pars_fragment"],
                ["output_fragment", "opaque_fragment"]
            ]);

            function ho(e, t) {
                var n = gi[t];
                if (void 0 === n) {
                    var r = co.get(t);
                    if (void 0 === r) throw new Error("Can not resolve #include <" + t + ">");
                    n = gi[r], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', t, r)
                }
                return uo(n)
            }
            var fo = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

            function po(e) {
                return e.replace(fo, mo)
            }

            function mo(e, t, n, r) {
                for (var i = "", a = parseInt(t); a < parseInt(n); a++) i += r.replace(/\[\s*i\s*\]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
                return i
            }

            function vo(e) {
                var t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
                return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"), t
            }

            function go(e, t, n, r) {
                var i, a, o = e.getContext(),
                    s = n.defines,
                    l = n.vertexShader,
                    u = n.fragmentShader,
                    c = function (e) {
                        var t = "SHADOWMAP_TYPE_BASIC";
                        return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"), t
                    }(n),
                    h = function (e) {
                        var t = "ENVMAP_TYPE_CUBE";
                        if (e.envMap) switch (e.envMapMode) {
                            case O:
                            case F:
                                t = "ENVMAP_TYPE_CUBE";
                                break;
                            case H:
                                t = "ENVMAP_TYPE_CUBE_UV"
                        }
                        return t
                    }(n),
                    d = function (e) {
                        var t = "ENVMAP_MODE_REFLECTION";
                        e.envMap && e.envMapMode === F && (t = "ENVMAP_MODE_REFRACTION");
                        return t
                    }(n),
                    f = function (e) {
                        var t = "ENVMAP_BLENDING_NONE";
                        if (e.envMap) switch (e.combine) {
                            case 0:
                                t = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case 1:
                                t = "ENVMAP_BLENDING_MIX";
                                break;
                            case 2:
                                t = "ENVMAP_BLENDING_ADD"
                        }
                        return t
                    }(n),
                    p = function (e) {
                        var t = e.envMapCubeUVHeight;
                        if (null === t) return null;
                        var n = Math.log2(t) - 2,
                            r = 1 / t;
                        return {
                            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
                            texelHeight: r,
                            maxMip: n
                        }
                    }(n),
                    m = n.isWebGL2 ? "" : function (e) {
                        return [e.extensionDerivatives || e.envMapCubeUVHeight || e.bumpMap || e.normalMapTangentSpace || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap || e.transmission) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ao).join("\n")
                    }(n),
                    v = function (e) {
                        var t = [];
                        for (var n in e) {
                            var r = e[n];
                            !1 !== r && t.push("#define " + n + " " + r)
                        }
                        return t.join("\n")
                    }(s),
                    g = o.createProgram(),
                    _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
                n.isRawShaderMaterial ? ((i = ["#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ao).join("\n")).length > 0 && (i += "\n"), (a = [m, "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v].filter(ao).join("\n")).length > 0 && (a += "\n")) : (i = [vo(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + d : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.mapUv ? "#define MAP_UV " + n.mapUv : "", n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "", n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "", n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "", n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "", n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "", n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "", n.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv : "", n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "", n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "", n.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv : "", n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "", n.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv : "", n.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv : "", n.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv : "", n.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv : "", n.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv : "", n.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv : "", n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "", n.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv : "", n.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv : "", n.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv : "", n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride : "", n.morphTargetsCount > 0 && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "\tattribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "\tattribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "\tattribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ao).join("\n"), a = [m, vo(n), "#define SHADER_TYPE " + n.shaderType, "#define SHADER_NAME " + n.shaderName, v, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + h : "", n.envMap ? "#define " + d : "", n.envMap ? "#define " + f : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.anisotropy ? "#define USE_ANISOTROPY" : "", n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.iridescence ? "#define USE_IRIDESCENCE" : "", n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.alphaHash ? "#define USE_ALPHAHASH" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.vertexTangents && !1 === n.flatShading ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUv1s ? "#define USE_UV1" : "", n.vertexUv2s ? "#define USE_UV2" : "", n.vertexUv3s ? "#define USE_UV3" : "", n.pointsUvs ? "#define USE_POINTS_UV" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.useLegacyLights ? "#define LEGACY_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? gi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? io("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.opaque ? "#define OPAQUE" : "", gi.colorspace_pars_fragment, ro("linearToOutputTexel", n.outputColorSpace), n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ao).join("\n")), l = so(l = oo(l = uo(l), n), n), u = so(u = oo(u = uo(u), n), n), l = po(l), u = po(u), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (_ = "#version 300 es\n", i = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + i, a = ["#define varying in", n.glslVersion === et ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === et ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + a);
                var y, x, M = _ + i + l,
                    S = _ + a + u,
                    E = eo(o, o.VERTEX_SHADER, M),
                    T = eo(o, o.FRAGMENT_SHADER, S);
                if (o.attachShader(g, E), o.attachShader(g, T), void 0 !== n.index0AttributeName ? o.bindAttribLocation(g, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(g, 0, "position"), o.linkProgram(g), e.debug.checkShaderErrors) {
                    var b = o.getProgramInfoLog(g).trim(),
                        A = o.getShaderInfoLog(E).trim(),
                        w = o.getShaderInfoLog(T).trim(),
                        R = !0,
                        C = !0;
                    if (!1 === o.getProgramParameter(g, o.LINK_STATUS))
                        if (R = !1, "function" == typeof e.debug.onShaderError) e.debug.onShaderError(o, g, E, T);
                        else {
                            var L = no(o, E, "vertex"),
                                P = no(o, T, "fragment");
                            console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(g, o.VALIDATE_STATUS) + "\n\nProgram Info Log: " + b + "\n" + L + "\n" + P)
                        }
                    else "" !== b ? console.warn("THREE.WebGLProgram: Program Info Log:", b) : "" !== A && "" !== w || (C = !1);
                    C && (this.diagnostics = {
                        runnable: R,
                        programLog: b,
                        vertexShader: {
                            log: A,
                            prefix: i
                        },
                        fragmentShader: {
                            log: w,
                            prefix: a
                        }
                    })
                }
                return o.deleteShader(E), o.deleteShader(T), this.getUniforms = function () {
                    return void 0 === y && (y = new $a(o, g)), y
                }, this.getAttributes = function () {
                    return void 0 === x && (x = function (e, t) {
                        for (var n = {}, r = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), i = 0; i < r; i++) {
                            var a = e.getActiveAttrib(t, i),
                                o = a.name,
                                s = 1;
                            a.type === e.FLOAT_MAT2 && (s = 2), a.type === e.FLOAT_MAT3 && (s = 3), a.type === e.FLOAT_MAT4 && (s = 4), n[o] = {
                                type: a.type,
                                location: e.getAttribLocation(t, o),
                                locationSize: s
                            }
                        }
                        return n
                    }(o, g)), x
                }, this.destroy = function () {
                    r.releaseStatesOfProgram(this), o.deleteProgram(g), this.program = void 0
                }, this.type = n.shaderType, this.name = n.shaderName, this.id = to++, this.cacheKey = t, this.usedTimes = 1, this.program = g, this.vertexShader = E, this.fragmentShader = T, this
            }
            var _o = 0,
                yo = function () {
                    function e() {
                        i(this, e), this.shaderCache = new Map, this.materialCache = new Map
                    }
                    return o(e, [{
                        key: "update",
                        value: function (e) {
                            var t = e.vertexShader,
                                n = e.fragmentShader,
                                r = this._getShaderStage(t),
                                i = this._getShaderStage(n),
                                a = this._getShaderCacheForMaterial(e);
                            return !1 === a.has(r) && (a.add(r), r.usedTimes++), !1 === a.has(i) && (a.add(i), i.usedTimes++), this
                        }
                    }, {
                        key: "remove",
                        value: function (e) {
                            var t, n = this.materialCache.get(e),
                                r = p(n);
                            try {
                                for (r.s(); !(t = r.n()).done;) {
                                    var i = t.value;
                                    i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code)
                                }
                            } catch (e) {
                                r.e(e)
                            } finally {
                                r.f()
                            }
                            return this.materialCache.delete(e), this
                        }
                    }, {
                        key: "getVertexShaderID",
                        value: function (e) {
                            return this._getShaderStage(e.vertexShader).id
                        }
                    }, {
                        key: "getFragmentShaderID",
                        value: function (e) {
                            return this._getShaderStage(e.fragmentShader).id
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.shaderCache.clear(), this.materialCache.clear()
                        }
                    }, {
                        key: "_getShaderCacheForMaterial",
                        value: function (e) {
                            var t = this.materialCache,
                                n = t.get(e);
                            return void 0 === n && (n = new Set, t.set(e, n)), n
                        }
                    }, {
                        key: "_getShaderStage",
                        value: function (e) {
                            var t = this.shaderCache,
                                n = t.get(e);
                            return void 0 === n && (n = new xo(e), t.set(e, n)), n
                        }
                    }]), e
                }(),
                xo = o((function e(t) {
                    i(this, e), this.id = _o++, this.code = t, this.usedTimes = 0
                }));

            function Mo(e, t, n, r, i, a, o) {
                var s = new Un,
                    l = new yo,
                    u = [],
                    c = i.isWebGL2,
                    h = i.logarithmicDepthBuffer,
                    d = i.vertexTextures,
                    f = i.precision,
                    p = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "toon",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    };

                function m(e) {
                    return 0 === e ? "uv" : "uv".concat(e)
                }
                return {
                    getParameters: function (a, s, u, v, g) {
                        var _ = v.fog,
                            y = g.geometry,
                            x = a.isMeshStandardMaterial ? v.environment : null,
                            M = (a.isMeshStandardMaterial ? n : t).get(a.envMap || x),
                            S = M && M.mapping === H ? M.image.height : null,
                            E = p[a.type];
                        null !== a.precision && (f = i.getMaxPrecision(a.precision)) !== a.precision && console.warn("THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", f, "instead.");
                        var T, b, A, w, R = y.morphAttributes.position || y.morphAttributes.normal || y.morphAttributes.color,
                            C = void 0 !== R ? R.length : 0,
                            L = 0;
                        if (void 0 !== y.morphAttributes.position && (L = 1), void 0 !== y.morphAttributes.normal && (L = 2), void 0 !== y.morphAttributes.color && (L = 3), E) {
                            var P = yi[E];
                            T = P.vertexShader, b = P.fragmentShader
                        } else T = a.vertexShader, b = a.fragmentShader, l.update(a), A = l.getVertexShaderID(a), w = l.getFragmentShaderID(a);
                        var k = e.getRenderTarget(),
                            I = !0 === g.isInstancedMesh,
                            U = !!a.map,
                            D = !!a.matcap,
                            N = !!M,
                            O = !!a.aoMap,
                            F = !!a.lightMap,
                            B = !!a.bumpMap,
                            z = !!a.normalMap,
                            G = !!a.displacementMap,
                            V = !!a.emissiveMap,
                            W = !!a.metalnessMap,
                            j = !!a.roughnessMap,
                            X = a.anisotropy > 0,
                            q = a.clearcoat > 0,
                            Y = a.iridescence > 0,
                            K = a.sheen > 0,
                            Z = a.transmission > 0,
                            J = X && !!a.anisotropyMap,
                            Q = q && !!a.clearcoatMap,
                            $ = q && !!a.clearcoatNormalMap,
                            ee = q && !!a.clearcoatRoughnessMap,
                            te = Y && !!a.iridescenceMap,
                            ne = Y && !!a.iridescenceThicknessMap,
                            re = K && !!a.sheenColorMap,
                            ie = K && !!a.sheenRoughnessMap,
                            ae = !!a.specularMap,
                            oe = !!a.specularColorMap,
                            se = !!a.specularIntensityMap,
                            le = Z && !!a.transmissionMap,
                            ue = Z && !!a.thicknessMap,
                            ce = !!a.gradientMap,
                            he = !!a.alphaMap,
                            de = a.alphaTest > 0,
                            fe = !!a.alphaHash,
                            pe = !!a.extensions,
                            me = !!y.attributes.uv1,
                            ve = !!y.attributes.uv2,
                            ge = !!y.attributes.uv3,
                            _e = 0;
                        return a.toneMapped && (null !== k && !0 !== k.isXRRenderTarget || (_e = e.toneMapping)), {
                            isWebGL2: c,
                            shaderID: E,
                            shaderType: a.type,
                            shaderName: a.name,
                            vertexShader: T,
                            fragmentShader: b,
                            defines: a.defines,
                            customVertexShaderID: A,
                            customFragmentShaderID: w,
                            isRawShaderMaterial: !0 === a.isRawShaderMaterial,
                            glslVersion: a.glslVersion,
                            precision: f,
                            instancing: I,
                            instancingColor: I && null !== g.instanceColor,
                            supportsVertexTextures: d,
                            outputColorSpace: null === k ? e.outputColorSpace : !0 === k.isXRRenderTarget ? k.texture.colorSpace : Ze,
                            map: U,
                            matcap: D,
                            envMap: N,
                            envMapMode: N && M.mapping,
                            envMapCubeUVHeight: S,
                            aoMap: O,
                            lightMap: F,
                            bumpMap: B,
                            normalMap: z,
                            displacementMap: d && G,
                            emissiveMap: V,
                            normalMapObjectSpace: z && 1 === a.normalMapType,
                            normalMapTangentSpace: z && 0 === a.normalMapType,
                            metalnessMap: W,
                            roughnessMap: j,
                            anisotropy: X,
                            anisotropyMap: J,
                            clearcoat: q,
                            clearcoatMap: Q,
                            clearcoatNormalMap: $,
                            clearcoatRoughnessMap: ee,
                            iridescence: Y,
                            iridescenceMap: te,
                            iridescenceThicknessMap: ne,
                            sheen: K,
                            sheenColorMap: re,
                            sheenRoughnessMap: ie,
                            specularMap: ae,
                            specularColorMap: oe,
                            specularIntensityMap: se,
                            transmission: Z,
                            transmissionMap: le,
                            thicknessMap: ue,
                            gradientMap: ce,
                            opaque: !1 === a.transparent && 1 === a.blending,
                            alphaMap: he,
                            alphaTest: de,
                            alphaHash: fe,
                            combine: a.combine,
                            mapUv: U && m(a.map.channel),
                            aoMapUv: O && m(a.aoMap.channel),
                            lightMapUv: F && m(a.lightMap.channel),
                            bumpMapUv: B && m(a.bumpMap.channel),
                            normalMapUv: z && m(a.normalMap.channel),
                            displacementMapUv: G && m(a.displacementMap.channel),
                            emissiveMapUv: V && m(a.emissiveMap.channel),
                            metalnessMapUv: W && m(a.metalnessMap.channel),
                            roughnessMapUv: j && m(a.roughnessMap.channel),
                            anisotropyMapUv: J && m(a.anisotropyMap.channel),
                            clearcoatMapUv: Q && m(a.clearcoatMap.channel),
                            clearcoatNormalMapUv: $ && m(a.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: ee && m(a.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: te && m(a.iridescenceMap.channel),
                            iridescenceThicknessMapUv: ne && m(a.iridescenceThicknessMap.channel),
                            sheenColorMapUv: re && m(a.sheenColorMap.channel),
                            sheenRoughnessMapUv: ie && m(a.sheenRoughnessMap.channel),
                            specularMapUv: ae && m(a.specularMap.channel),
                            specularColorMapUv: oe && m(a.specularColorMap.channel),
                            specularIntensityMapUv: se && m(a.specularIntensityMap.channel),
                            transmissionMapUv: le && m(a.transmissionMap.channel),
                            thicknessMapUv: ue && m(a.thicknessMap.channel),
                            alphaMapUv: he && m(a.alphaMap.channel),
                            vertexTangents: !!y.attributes.tangent && (z || X),
                            vertexColors: a.vertexColors,
                            vertexAlphas: !0 === a.vertexColors && !!y.attributes.color && 4 === y.attributes.color.itemSize,
                            vertexUv1s: me,
                            vertexUv2s: ve,
                            vertexUv3s: ge,
                            pointsUvs: !0 === g.isPoints && !!y.attributes.uv && (U || he),
                            fog: !!_,
                            useFog: !0 === a.fog,
                            fogExp2: _ && _.isFogExp2,
                            flatShading: !0 === a.flatShading,
                            sizeAttenuation: !0 === a.sizeAttenuation,
                            logarithmicDepthBuffer: h,
                            skinning: !0 === g.isSkinnedMesh,
                            morphTargets: void 0 !== y.morphAttributes.position,
                            morphNormals: void 0 !== y.morphAttributes.normal,
                            morphColors: void 0 !== y.morphAttributes.color,
                            morphTargetsCount: C,
                            morphTextureStride: L,
                            numDirLights: s.directional.length,
                            numPointLights: s.point.length,
                            numSpotLights: s.spot.length,
                            numSpotLightMaps: s.spotLightMap.length,
                            numRectAreaLights: s.rectArea.length,
                            numHemiLights: s.hemi.length,
                            numDirLightShadows: s.directionalShadowMap.length,
                            numPointLightShadows: s.pointShadowMap.length,
                            numSpotLightShadows: s.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: s.numSpotLightShadowsWithMaps,
                            numClippingPlanes: o.numPlanes,
                            numClipIntersection: o.numIntersection,
                            dithering: a.dithering,
                            shadowMapEnabled: e.shadowMap.enabled && u.length > 0,
                            shadowMapType: e.shadowMap.type,
                            toneMapping: _e,
                            useLegacyLights: e._useLegacyLights,
                            premultipliedAlpha: a.premultipliedAlpha,
                            doubleSided: 2 === a.side,
                            flipSided: 1 === a.side,
                            useDepthPacking: a.depthPacking >= 0,
                            depthPacking: a.depthPacking || 0,
                            index0AttributeName: a.index0AttributeName,
                            extensionDerivatives: pe && !0 === a.extensions.derivatives,
                            extensionFragDepth: pe && !0 === a.extensions.fragDepth,
                            extensionDrawBuffers: pe && !0 === a.extensions.drawBuffers,
                            extensionShaderTextureLOD: pe && !0 === a.extensions.shaderTextureLOD,
                            rendererExtensionFragDepth: c || r.has("EXT_frag_depth"),
                            rendererExtensionDrawBuffers: c || r.has("WEBGL_draw_buffers"),
                            rendererExtensionShaderTextureLod: c || r.has("EXT_shader_texture_lod"),
                            customProgramCacheKey: a.customProgramCacheKey()
                        }
                    },
                    getProgramCacheKey: function (t) {
                        var n = [];
                        if (t.shaderID ? n.push(t.shaderID) : (n.push(t.customVertexShaderID), n.push(t.customFragmentShaderID)), void 0 !== t.defines)
                            for (var r in t.defines) n.push(r), n.push(t.defines[r]);
                        return !1 === t.isRawShaderMaterial && (! function (e, t) {
                            e.push(t.precision), e.push(t.outputColorSpace), e.push(t.envMapMode), e.push(t.envMapCubeUVHeight), e.push(t.mapUv), e.push(t.alphaMapUv), e.push(t.lightMapUv), e.push(t.aoMapUv), e.push(t.bumpMapUv), e.push(t.normalMapUv), e.push(t.displacementMapUv), e.push(t.emissiveMapUv), e.push(t.metalnessMapUv), e.push(t.roughnessMapUv), e.push(t.anisotropyMapUv), e.push(t.clearcoatMapUv), e.push(t.clearcoatNormalMapUv), e.push(t.clearcoatRoughnessMapUv), e.push(t.iridescenceMapUv), e.push(t.iridescenceThicknessMapUv), e.push(t.sheenColorMapUv), e.push(t.sheenRoughnessMapUv), e.push(t.specularMapUv), e.push(t.specularColorMapUv), e.push(t.specularIntensityMapUv), e.push(t.transmissionMapUv), e.push(t.thicknessMapUv), e.push(t.combine), e.push(t.fogExp2), e.push(t.sizeAttenuation), e.push(t.morphTargetsCount), e.push(t.morphAttributeCount), e.push(t.numDirLights), e.push(t.numPointLights), e.push(t.numSpotLights), e.push(t.numSpotLightMaps), e.push(t.numHemiLights), e.push(t.numRectAreaLights), e.push(t.numDirLightShadows), e.push(t.numPointLightShadows), e.push(t.numSpotLightShadows), e.push(t.numSpotLightShadowsWithMaps), e.push(t.shadowMapType), e.push(t.toneMapping), e.push(t.numClippingPlanes), e.push(t.numClipIntersection), e.push(t.depthPacking)
                        }(n, t), function (e, t) {
                            s.disableAll(), t.isWebGL2 && s.enable(0);
                            t.supportsVertexTextures && s.enable(1);
                            t.instancing && s.enable(2);
                            t.instancingColor && s.enable(3);
                            t.matcap && s.enable(4);
                            t.envMap && s.enable(5);
                            t.normalMapObjectSpace && s.enable(6);
                            t.normalMapTangentSpace && s.enable(7);
                            t.clearcoat && s.enable(8);
                            t.iridescence && s.enable(9);
                            t.alphaTest && s.enable(10);
                            t.vertexColors && s.enable(11);
                            t.vertexAlphas && s.enable(12);
                            t.vertexUv1s && s.enable(13);
                            t.vertexUv2s && s.enable(14);
                            t.vertexUv3s && s.enable(15);
                            t.vertexTangents && s.enable(16);
                            t.anisotropy && s.enable(17);
                            e.push(s.mask), s.disableAll(), t.fog && s.enable(0);
                            t.useFog && s.enable(1);
                            t.flatShading && s.enable(2);
                            t.logarithmicDepthBuffer && s.enable(3);
                            t.skinning && s.enable(4);
                            t.morphTargets && s.enable(5);
                            t.morphNormals && s.enable(6);
                            t.morphColors && s.enable(7);
                            t.premultipliedAlpha && s.enable(8);
                            t.shadowMapEnabled && s.enable(9);
                            t.useLegacyLights && s.enable(10);
                            t.doubleSided && s.enable(11);
                            t.flipSided && s.enable(12);
                            t.useDepthPacking && s.enable(13);
                            t.dithering && s.enable(14);
                            t.transmission && s.enable(15);
                            t.sheen && s.enable(16);
                            t.opaque && s.enable(17);
                            t.pointsUvs && s.enable(18);
                            e.push(s.mask)
                        }(n, t), n.push(e.outputColorSpace)), n.push(t.customProgramCacheKey), n.join()
                    },
                    getUniforms: function (e) {
                        var t, n = p[e.type];
                        if (n) {
                            var r = yi[n];
                            t = $r.clone(r.uniforms)
                        } else t = e.uniforms;
                        return t
                    },
                    acquireProgram: function (t, n) {
                        for (var r, i = 0, o = u.length; i < o; i++) {
                            var s = u[i];
                            if (s.cacheKey === n) {
                                ++(r = s).usedTimes;
                                break
                            }
                        }
                        return void 0 === r && (r = new go(e, n, t, a), u.push(r)), r
                    },
                    releaseProgram: function (e) {
                        if (0 == --e.usedTimes) {
                            var t = u.indexOf(e);
                            u[t] = u[u.length - 1], u.pop(), e.destroy()
                        }
                    },
                    releaseShaderCache: function (e) {
                        l.remove(e)
                    },
                    programs: u,
                    dispose: function () {
                        l.dispose()
                    }
                }
            }

            function So() {
                var e = new WeakMap;
                return {
                    get: function (t) {
                        var n = e.get(t);
                        return void 0 === n && (n = {}, e.set(t, n)), n
                    },
                    remove: function (t) {
                        e.delete(t)
                    },
                    update: function (t, n, r) {
                        e.get(t)[n] = r
                    },
                    dispose: function () {
                        e = new WeakMap
                    }
                }
            }

            function Eo(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
            }

            function To(e, t) {
                return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
            }

            function bo() {
                var e = [],
                    t = 0,
                    n = [],
                    r = [],
                    i = [];

                function a(n, r, i, a, o, s) {
                    var l = e[t];
                    return void 0 === l ? (l = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: i,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: o,
                        group: s
                    }, e[t] = l) : (l.id = n.id, l.object = n, l.geometry = r, l.material = i, l.groupOrder = a, l.renderOrder = n.renderOrder, l.z = o, l.group = s), t++, l
                }
                return {
                    opaque: n,
                    transmissive: r,
                    transparent: i,
                    init: function () {
                        t = 0, n.length = 0, r.length = 0, i.length = 0
                    },
                    push: function (e, t, o, s, l, u) {
                        var c = a(e, t, o, s, l, u);
                        o.transmission > 0 ? r.push(c) : !0 === o.transparent ? i.push(c) : n.push(c)
                    },
                    unshift: function (e, t, o, s, l, u) {
                        var c = a(e, t, o, s, l, u);
                        o.transmission > 0 ? r.unshift(c) : !0 === o.transparent ? i.unshift(c) : n.unshift(c)
                    },
                    finish: function () {
                        for (var n = t, r = e.length; n < r; n++) {
                            var i = e[n];
                            if (null === i.id) break;
                            i.id = null, i.object = null, i.geometry = null, i.material = null, i.group = null
                        }
                    },
                    sort: function (e, t) {
                        n.length > 1 && n.sort(e || Eo), r.length > 1 && r.sort(t || To), i.length > 1 && i.sort(t || To)
                    }
                }
            }

            function Ao() {
                var e = new WeakMap;
                return {
                    get: function (t, n) {
                        var r, i = e.get(t);
                        return void 0 === i ? (r = new bo, e.set(t, [r])) : n >= i.length ? (r = new bo, i.push(r)) : r = i[n], r
                    },
                    dispose: function () {
                        e = new WeakMap
                    }
                }
            }

            function wo() {
                var e = {};
                return {
                    get: function (t) {
                        if (void 0 !== e[t.id]) return e[t.id];
                        var n;
                        switch (t.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new Xt,
                                    color: new fr
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new Xt,
                                    direction: new Xt,
                                    color: new fr,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new Xt,
                                    color: new fr,
                                    distance: 0,
                                    decay: 0
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new Xt,
                                    skyColor: new fr,
                                    groundColor: new fr
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new fr,
                                    position: new Xt,
                                    halfWidth: new Xt,
                                    halfHeight: new Xt
                                }
                        }
                        return e[t.id] = n, n
                    }
                }
            }
            var Ro = 0;

            function Co(e, t) {
                return (t.castShadow ? 2 : 0) - (e.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (e.map ? 1 : 0)
            }

            function Lo(e, t) {
                for (var n, r = new wo, i = (n = {}, {
                        get: function (e) {
                            if (void 0 !== n[e.id]) return n[e.id];
                            var t;
                            switch (e.type) {
                                case "DirectionalLight":
                                case "SpotLight":
                                    t = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new yt
                                    };
                                    break;
                                case "PointLight":
                                    t = {
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new yt,
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1e3
                                    }
                            }
                            return n[e.id] = t, t
                        }
                    }), a = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0
                    }, o = 0; o < 9; o++) a.probe.push(new Xt);
                var s = new Xt,
                    l = new En,
                    u = new En;
                return {
                    setup: function (n, o) {
                        for (var s = 0, l = 0, u = 0, c = 0; c < 9; c++) a.probe[c].set(0, 0, 0);
                        var h = 0,
                            d = 0,
                            f = 0,
                            p = 0,
                            m = 0,
                            v = 0,
                            g = 0,
                            _ = 0,
                            y = 0,
                            x = 0;
                        n.sort(Co);
                        for (var M = !0 === o ? Math.PI : 1, S = 0, E = n.length; S < E; S++) {
                            var T = n[S],
                                b = T.color,
                                A = T.intensity,
                                w = T.distance,
                                R = T.shadow && T.shadow.map ? T.shadow.map.texture : null;
                            if (T.isAmbientLight) s += b.r * A * M, l += b.g * A * M, u += b.b * A * M;
                            else if (T.isLightProbe)
                                for (var C = 0; C < 9; C++) a.probe[C].addScaledVector(T.sh.coefficients[C], A);
                            else if (T.isDirectionalLight) {
                                var L = r.get(T);
                                if (L.color.copy(T.color).multiplyScalar(T.intensity * M), T.castShadow) {
                                    var P = T.shadow,
                                        k = i.get(T);
                                    k.shadowBias = P.bias, k.shadowNormalBias = P.normalBias, k.shadowRadius = P.radius, k.shadowMapSize = P.mapSize, a.directionalShadow[h] = k, a.directionalShadowMap[h] = R, a.directionalShadowMatrix[h] = T.shadow.matrix, v++
                                }
                                a.directional[h] = L, h++
                            } else if (T.isSpotLight) {
                                var I = r.get(T);
                                I.position.setFromMatrixPosition(T.matrixWorld), I.color.copy(b).multiplyScalar(A * M), I.distance = w, I.coneCos = Math.cos(T.angle), I.penumbraCos = Math.cos(T.angle * (1 - T.penumbra)), I.decay = T.decay, a.spot[f] = I;
                                var U = T.shadow;
                                if (T.map && (a.spotLightMap[y] = T.map, y++, U.updateMatrices(T), T.castShadow && x++), a.spotLightMatrix[f] = U.matrix, T.castShadow) {
                                    var D = i.get(T);
                                    D.shadowBias = U.bias, D.shadowNormalBias = U.normalBias, D.shadowRadius = U.radius, D.shadowMapSize = U.mapSize, a.spotShadow[f] = D, a.spotShadowMap[f] = R, _++
                                }
                                f++
                            } else if (T.isRectAreaLight) {
                                var N = r.get(T);
                                N.color.copy(b).multiplyScalar(A), N.halfWidth.set(.5 * T.width, 0, 0), N.halfHeight.set(0, .5 * T.height, 0), a.rectArea[p] = N, p++
                            } else if (T.isPointLight) {
                                var O = r.get(T);
                                if (O.color.copy(T.color).multiplyScalar(T.intensity * M), O.distance = T.distance, O.decay = T.decay, T.castShadow) {
                                    var F = T.shadow,
                                        B = i.get(T);
                                    B.shadowBias = F.bias, B.shadowNormalBias = F.normalBias, B.shadowRadius = F.radius, B.shadowMapSize = F.mapSize, B.shadowCameraNear = F.camera.near, B.shadowCameraFar = F.camera.far, a.pointShadow[d] = B, a.pointShadowMap[d] = R, a.pointShadowMatrix[d] = T.shadow.matrix, g++
                                }
                                a.point[d] = O, d++
                            } else if (T.isHemisphereLight) {
                                var z = r.get(T);
                                z.skyColor.copy(T.color).multiplyScalar(A * M), z.groundColor.copy(T.groundColor).multiplyScalar(A * M), a.hemi[m] = z, m++
                            }
                        }
                        p > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (a.rectAreaLTC1 = _i.LTC_FLOAT_1, a.rectAreaLTC2 = _i.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (a.rectAreaLTC1 = _i.LTC_HALF_1, a.rectAreaLTC2 = _i.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), a.ambient[0] = s, a.ambient[1] = l, a.ambient[2] = u;
                        var H = a.hash;
                        H.directionalLength === h && H.pointLength === d && H.spotLength === f && H.rectAreaLength === p && H.hemiLength === m && H.numDirectionalShadows === v && H.numPointShadows === g && H.numSpotShadows === _ && H.numSpotMaps === y || (a.directional.length = h, a.spot.length = f, a.rectArea.length = p, a.point.length = d, a.hemi.length = m, a.directionalShadow.length = v, a.directionalShadowMap.length = v, a.pointShadow.length = g, a.pointShadowMap.length = g, a.spotShadow.length = _, a.spotShadowMap.length = _, a.directionalShadowMatrix.length = v, a.pointShadowMatrix.length = g, a.spotLightMatrix.length = _ + y - x, a.spotLightMap.length = y, a.numSpotLightShadowsWithMaps = x, H.directionalLength = h, H.pointLength = d, H.spotLength = f, H.rectAreaLength = p, H.hemiLength = m, H.numDirectionalShadows = v, H.numPointShadows = g, H.numSpotShadows = _, H.numSpotMaps = y, a.version = Ro++)
                    },
                    setupView: function (e, t) {
                        for (var n = 0, r = 0, i = 0, o = 0, c = 0, h = t.matrixWorldInverse, d = 0, f = e.length; d < f; d++) {
                            var p = e[d];
                            if (p.isDirectionalLight) {
                                var m = a.directional[n];
                                m.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), m.direction.sub(s), m.direction.transformDirection(h), n++
                            } else if (p.isSpotLight) {
                                var v = a.spot[i];
                                v.position.setFromMatrixPosition(p.matrixWorld), v.position.applyMatrix4(h), v.direction.setFromMatrixPosition(p.matrixWorld), s.setFromMatrixPosition(p.target.matrixWorld), v.direction.sub(s), v.direction.transformDirection(h), i++
                            } else if (p.isRectAreaLight) {
                                var g = a.rectArea[o];
                                g.position.setFromMatrixPosition(p.matrixWorld), g.position.applyMatrix4(h), u.identity(), l.copy(p.matrixWorld), l.premultiply(h), u.extractRotation(l), g.halfWidth.set(.5 * p.width, 0, 0), g.halfHeight.set(0, .5 * p.height, 0), g.halfWidth.applyMatrix4(u), g.halfHeight.applyMatrix4(u), o++
                            } else if (p.isPointLight) {
                                var _ = a.point[r];
                                _.position.setFromMatrixPosition(p.matrixWorld), _.position.applyMatrix4(h), r++
                            } else if (p.isHemisphereLight) {
                                var y = a.hemi[c];
                                y.direction.setFromMatrixPosition(p.matrixWorld), y.direction.transformDirection(h), c++
                            }
                        }
                    },
                    state: a
                }
            }

            function Po(e, t) {
                var n = new Lo(e, t),
                    r = [],
                    i = [];
                return {
                    init: function () {
                        r.length = 0, i.length = 0
                    },
                    state: {
                        lightsArray: r,
                        shadowsArray: i,
                        lights: n
                    },
                    setupLights: function (e) {
                        n.setup(r, e)
                    },
                    setupLightsView: function (e) {
                        n.setupView(r, e)
                    },
                    pushLight: function (e) {
                        r.push(e)
                    },
                    pushShadow: function (e) {
                        i.push(e)
                    }
                }
            }

            function ko(e, t) {
                var n = new WeakMap;
                return {
                    get: function (r) {
                        var i, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                            o = n.get(r);
                        return void 0 === o ? (i = new Po(e, t), n.set(r, [i])) : a >= o.length ? (i = new Po(e, t), o.push(i)) : i = o[a], i
                    },
                    dispose: function () {
                        n = new WeakMap
                    }
                }
            }
            var Io = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isMeshDepthMaterial = !0, r.type = "MeshDepthMaterial", r.depthPacking = 3200, r.map = null, r.alphaMap = null, r.displacementMap = null, r.displacementScale = 1, r.displacementBias = 0, r.wireframe = !1, r.wireframeLinewidth = 1, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
                        }
                    }]), n
                }(lr),
                Uo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isMeshDistanceMaterial = !0, r.type = "MeshDistanceMaterial", r.map = null, r.alphaMap = null, r.displacementMap = null, r.displacementScale = 1, r.displacementBias = 0, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
                        }
                    }]), n
                }(lr);

            function Do(e, t, n) {
                var r, i = new fi,
                    a = new yt,
                    o = new yt,
                    s = new zt,
                    u = new Io({
                        depthPacking: 3201
                    }),
                    c = new Uo,
                    h = {},
                    d = n.maxTextureSize,
                    f = (l(r = {}, 0, 1), l(r, 1, 0), l(r, 2, 2), r),
                    p = new ei({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new yt
                            },
                            radius: {
                                value: 4
                            }
                        },
                        vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
                        fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
                    }),
                    m = p.clone();
                m.defines.HORIZONTAL_PASS = 1;
                var v = new Cr;
                v.setAttribute("position", new _r(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
                var g = new qr(v, p),
                    _ = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1;
                var y = this.type;

                function x(n, r) {
                    var i = t.update(g);
                    p.defines.VSM_SAMPLES !== n.blurSamples && (p.defines.VSM_SAMPLES = n.blurSamples, m.defines.VSM_SAMPLES = n.blurSamples, p.needsUpdate = !0, m.needsUpdate = !0), null === n.mapPass && (n.mapPass = new Gt(a.x, a.y)), p.uniforms.shadow_pass.value = n.map.texture, p.uniforms.resolution.value = n.mapSize, p.uniforms.radius.value = n.radius, e.setRenderTarget(n.mapPass), e.clear(), e.renderBufferDirect(r, null, i, p, g, null), m.uniforms.shadow_pass.value = n.mapPass.texture, m.uniforms.resolution.value = n.mapSize, m.uniforms.radius.value = n.radius, e.setRenderTarget(n.map), e.clear(), e.renderBufferDirect(r, null, i, m, g, null)
                }

                function M(t, n, r, i) {
                    var a = null,
                        o = !0 === r.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
                    if (void 0 !== o) a = o;
                    else if (a = !0 === r.isPointLight ? c : u, e.localClippingEnabled && !0 === n.clipShadows && Array.isArray(n.clippingPlanes) && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0 || n.map && n.alphaTest > 0) {
                        var s = a.uuid,
                            l = n.uuid,
                            d = h[s];
                        void 0 === d && (d = {}, h[s] = d);
                        var p = d[l];
                        void 0 === p && (p = a.clone(), d[l] = p), a = p
                    }(a.visible = n.visible, a.wireframe = n.wireframe, a.side = 3 === i ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : f[n.side], a.alphaMap = n.alphaMap, a.alphaTest = n.alphaTest, a.map = n.map, a.clipShadows = n.clipShadows, a.clippingPlanes = n.clippingPlanes, a.clipIntersection = n.clipIntersection, a.displacementMap = n.displacementMap, a.displacementScale = n.displacementScale, a.displacementBias = n.displacementBias, a.wireframeLinewidth = n.wireframeLinewidth, a.linewidth = n.linewidth, !0 === r.isPointLight && !0 === a.isMeshDistanceMaterial) && (e.properties.get(a).light = r);
                    return a
                }

                function S(n, r, a, o, s) {
                    if (!1 !== n.visible) {
                        if (n.layers.test(r.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || i.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(a.matrixWorldInverse, n.matrixWorld);
                            var l = t.update(n),
                                u = n.material;
                            if (Array.isArray(u))
                                for (var c = l.groups, h = 0, d = c.length; h < d; h++) {
                                    var f = c[h],
                                        p = u[f.materialIndex];
                                    if (p && p.visible) {
                                        var m = M(n, p, o, s);
                                        e.renderBufferDirect(a, null, l, m, n, f)
                                    }
                                } else if (u.visible) {
                                    var v = M(n, u, o, s);
                                    e.renderBufferDirect(a, null, l, v, n, null)
                                }
                        }
                        for (var g = n.children, _ = 0, y = g.length; _ < y; _++) S(g[_], r, a, o, s)
                    }
                }
                this.render = function (t, n, r) {
                    if (!1 !== _.enabled && (!1 !== _.autoUpdate || !1 !== _.needsUpdate) && 0 !== t.length) {
                        var l = e.getRenderTarget(),
                            u = e.getActiveCubeFace(),
                            c = e.getActiveMipmapLevel(),
                            h = e.state;
                        h.setBlending(0), h.buffers.color.setClear(1, 1, 1, 1), h.buffers.depth.setTest(!0), h.setScissorTest(!1);
                        for (var f = 3 !== y && 3 === this.type, p = 3 === y && 3 !== this.type, m = 0, v = t.length; m < v; m++) {
                            var g = t[m],
                                M = g.shadow;
                            if (void 0 !== M) {
                                if (!1 !== M.autoUpdate || !1 !== M.needsUpdate) {
                                    a.copy(M.mapSize);
                                    var E = M.getFrameExtents();
                                    if (a.multiply(E), o.copy(M.mapSize), (a.x > d || a.y > d) && (a.x > d && (o.x = Math.floor(d / E.x), a.x = o.x * E.x, M.mapSize.x = o.x), a.y > d && (o.y = Math.floor(d / E.y), a.y = o.y * E.y, M.mapSize.y = o.y)), null === M.map || !0 === f || !0 === p) {
                                        var T = 3 !== this.type ? {
                                            minFilter: j,
                                            magFilter: j
                                        } : {};
                                        null !== M.map && M.map.dispose(), M.map = new Gt(a.x, a.y, T), M.map.texture.name = g.name + ".shadowMap", M.camera.updateProjectionMatrix()
                                    }
                                    e.setRenderTarget(M.map), e.clear();
                                    for (var b = M.getViewportCount(), A = 0; A < b; A++) {
                                        var w = M.getViewport(A);
                                        s.set(o.x * w.x, o.y * w.y, o.x * w.z, o.y * w.w), h.viewport(s), M.updateMatrices(g, A), i = M.getFrustum(), S(n, r, M.camera, g, this.type)
                                    }!0 !== M.isPointLightShadow && 3 === this.type && x(M, r), M.needsUpdate = !1
                                }
                            } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                        }
                        y = this.type, _.needsUpdate = !1, e.setRenderTarget(l, u, c)
                    }
                }
            }

            function No(e, t, n) {
                var r, i, a = n.isWebGL2;
                var o = new function () {
                        var t = !1,
                            n = new zt,
                            r = null,
                            i = new zt(0, 0, 0, 0);
                        return {
                            setMask: function (n) {
                                r === n || t || (e.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t, r, a, o, s) {
                                !0 === s && (t *= o, r *= o, a *= o), n.set(t, r, a, o), !1 === i.equals(n) && (e.clearColor(t, r, a, o), i.copy(n))
                            },
                            reset: function () {
                                t = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    s = new function () {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function (t) {
                                t ? W(e.DEPTH_TEST) : j(e.DEPTH_TEST)
                            },
                            setMask: function (r) {
                                n === r || t || (e.depthMask(r), n = r)
                            },
                            setFunc: function (t) {
                                if (r !== t) {
                                    switch (t) {
                                        case 0:
                                            e.depthFunc(e.NEVER);
                                            break;
                                        case 1:
                                            e.depthFunc(e.ALWAYS);
                                            break;
                                        case 2:
                                            e.depthFunc(e.LESS);
                                            break;
                                        case 3:
                                        default:
                                            e.depthFunc(e.LEQUAL);
                                            break;
                                        case 4:
                                            e.depthFunc(e.EQUAL);
                                            break;
                                        case 5:
                                            e.depthFunc(e.GEQUAL);
                                            break;
                                        case 6:
                                            e.depthFunc(e.GREATER);
                                            break;
                                        case 7:
                                            e.depthFunc(e.NOTEQUAL)
                                    }
                                    r = t
                                }
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t) {
                                i !== t && (e.clearDepth(t), i = t)
                            },
                            reset: function () {
                                t = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    u = new function () {
                        var t = !1,
                            n = null,
                            r = null,
                            i = null,
                            a = null,
                            o = null,
                            s = null,
                            l = null,
                            u = null;
                        return {
                            setTest: function (n) {
                                t || (n ? W(e.STENCIL_TEST) : j(e.STENCIL_TEST))
                            },
                            setMask: function (r) {
                                n === r || t || (e.stencilMask(r), n = r)
                            },
                            setFunc: function (t, n, o) {
                                r === t && i === n && a === o || (e.stencilFunc(t, n, o), r = t, i = n, a = o)
                            },
                            setOp: function (t, n, r) {
                                o === t && s === n && l === r || (e.stencilOp(t, n, r), o = t, s = n, l = r)
                            },
                            setLocked: function (e) {
                                t = e
                            },
                            setClear: function (t) {
                                u !== t && (e.clearStencil(t), u = t)
                            },
                            reset: function () {
                                t = !1, n = null, r = null, i = null, a = null, o = null, s = null, l = null, u = null
                            }
                        }
                    },
                    c = new WeakMap,
                    h = new WeakMap,
                    d = {},
                    f = {},
                    p = new WeakMap,
                    m = [],
                    v = null,
                    g = !1,
                    _ = null,
                    y = null,
                    x = null,
                    M = null,
                    S = null,
                    E = null,
                    T = null,
                    b = !1,
                    A = null,
                    w = null,
                    R = null,
                    C = null,
                    L = null,
                    P = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    k = !1,
                    I = 0,
                    U = e.getParameter(e.VERSION); - 1 !== U.indexOf("WebGL") ? (I = parseFloat(/^WebGL (\d)/.exec(U)[1]), k = I >= 1) : -1 !== U.indexOf("OpenGL ES") && (I = parseFloat(/^OpenGL ES (\d)/.exec(U)[1]), k = I >= 2);
                var D = null,
                    O = {},
                    F = e.getParameter(e.SCISSOR_BOX),
                    B = e.getParameter(e.VIEWPORT),
                    z = (new zt).fromArray(F),
                    H = (new zt).fromArray(B);

                function G(t, n, r, i) {
                    var o = new Uint8Array(4),
                        s = e.createTexture();
                    e.bindTexture(t, s), e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST), e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
                    for (var l = 0; l < r; l++) !a || t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY ? e.texImage2D(n + l, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, o) : e.texImage3D(n, 0, e.RGBA, 1, 1, i, 0, e.RGBA, e.UNSIGNED_BYTE, o);
                    return s
                }
                var V = {};

                function W(t) {
                    !0 !== d[t] && (e.enable(t), d[t] = !0)
                }

                function j(t) {
                    !1 !== d[t] && (e.disable(t), d[t] = !1)
                }
                V[e.TEXTURE_2D] = G(e.TEXTURE_2D, e.TEXTURE_2D, 1), V[e.TEXTURE_CUBE_MAP] = G(e.TEXTURE_CUBE_MAP, e.TEXTURE_CUBE_MAP_POSITIVE_X, 6), a && (V[e.TEXTURE_2D_ARRAY] = G(e.TEXTURE_2D_ARRAY, e.TEXTURE_2D_ARRAY, 1, 1), V[e.TEXTURE_3D] = G(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)), o.setClear(0, 0, 0, 1), s.setClear(1), u.setClear(0), W(e.DEPTH_TEST), s.setFunc(3), Z(!1), J(1), W(e.CULL_FACE), K(0);
                var X = (l(r = {}, N, e.FUNC_ADD), l(r, 101, e.FUNC_SUBTRACT), l(r, 102, e.FUNC_REVERSE_SUBTRACT), r);
                if (a) X[103] = e.MIN, X[104] = e.MAX;
                else {
                    var q = t.get("EXT_blend_minmax");
                    null !== q && (X[103] = q.MIN_EXT, X[104] = q.MAX_EXT)
                }
                var Y = (l(i = {}, 200, e.ZERO), l(i, 201, e.ONE), l(i, 202, e.SRC_COLOR), l(i, 204, e.SRC_ALPHA), l(i, 210, e.SRC_ALPHA_SATURATE), l(i, 208, e.DST_COLOR), l(i, 206, e.DST_ALPHA), l(i, 203, e.ONE_MINUS_SRC_COLOR), l(i, 205, e.ONE_MINUS_SRC_ALPHA), l(i, 209, e.ONE_MINUS_DST_COLOR), l(i, 207, e.ONE_MINUS_DST_ALPHA), i);

                function K(t, n, r, i, a, o, s, l) {
                    if (0 !== t) {
                        if (!1 === g && (W(e.BLEND), g = !0), 5 === t) a = a || n, o = o || r, s = s || i, n === y && a === S || (e.blendEquationSeparate(X[n], X[a]), y = n, S = a), r === x && i === M && o === E && s === T || (e.blendFuncSeparate(Y[r], Y[i], Y[o], Y[s]), x = r, M = i, E = o, T = s), _ = t, b = !1;
                        else if (t !== _ || l !== b) {
                            if (y === N && S === N || (e.blendEquation(e.FUNC_ADD), y = N, S = N), l) switch (t) {
                                case 1:
                                    e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.ONE, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            } else switch (t) {
                                case 1:
                                    e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA);
                                    break;
                                case 2:
                                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                                    break;
                                case 3:
                                    e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
                                    break;
                                case 4:
                                    e.blendFunc(e.ZERO, e.SRC_COLOR);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", t)
                            }
                            x = null, M = null, E = null, T = null, _ = t, b = l
                        }
                    } else !0 === g && (j(e.BLEND), g = !1)
                }

                function Z(t) {
                    A !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), A = t)
                }

                function J(t) {
                    0 !== t ? (W(e.CULL_FACE), t !== w && (1 === t ? e.cullFace(e.BACK) : 2 === t ? e.cullFace(e.FRONT) : e.cullFace(e.FRONT_AND_BACK))) : j(e.CULL_FACE), w = t
                }

                function Q(t, n, r) {
                    t ? (W(e.POLYGON_OFFSET_FILL), C === n && L === r || (e.polygonOffset(n, r), C = n, L = r)) : j(e.POLYGON_OFFSET_FILL)
                }
                return {
                    buffers: {
                        color: o,
                        depth: s,
                        stencil: u
                    },
                    enable: W,
                    disable: j,
                    bindFramebuffer: function (t, n) {
                        return f[t] !== n && (e.bindFramebuffer(t, n), f[t] = n, a && (t === e.DRAW_FRAMEBUFFER && (f[e.FRAMEBUFFER] = n), t === e.FRAMEBUFFER && (f[e.DRAW_FRAMEBUFFER] = n)), !0)
                    },
                    drawBuffers: function (r, i) {
                        var a = m,
                            o = !1;
                        if (r)
                            if (void 0 === (a = p.get(i)) && (a = [], p.set(i, a)), r.isWebGLMultipleRenderTargets) {
                                var s = r.texture;
                                if (a.length !== s.length || a[0] !== e.COLOR_ATTACHMENT0) {
                                    for (var l = 0, u = s.length; l < u; l++) a[l] = e.COLOR_ATTACHMENT0 + l;
                                    a.length = s.length, o = !0
                                }
                            } else a[0] !== e.COLOR_ATTACHMENT0 && (a[0] = e.COLOR_ATTACHMENT0, o = !0);
                        else a[0] !== e.BACK && (a[0] = e.BACK, o = !0);
                        o && (n.isWebGL2 ? e.drawBuffers(a) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(a))
                    },
                    useProgram: function (t) {
                        return v !== t && (e.useProgram(t), v = t, !0)
                    },
                    setBlending: K,
                    setMaterial: function (t, n) {
                        2 === t.side ? j(e.CULL_FACE) : W(e.CULL_FACE);
                        var r = 1 === t.side;
                        n && (r = !r), Z(r), 1 === t.blending && !1 === t.transparent ? K(0) : K(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), s.setFunc(t.depthFunc), s.setTest(t.depthTest), s.setMask(t.depthWrite), o.setMask(t.colorWrite);
                        var i = t.stencilWrite;
                        u.setTest(i), i && (u.setMask(t.stencilWriteMask), u.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), u.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), Q(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? W(e.SAMPLE_ALPHA_TO_COVERAGE) : j(e.SAMPLE_ALPHA_TO_COVERAGE)
                    },
                    setFlipSided: Z,
                    setCullFace: J,
                    setLineWidth: function (t) {
                        t !== R && (k && e.lineWidth(t), R = t)
                    },
                    setPolygonOffset: Q,
                    setScissorTest: function (t) {
                        t ? W(e.SCISSOR_TEST) : j(e.SCISSOR_TEST)
                    },
                    activeTexture: function (t) {
                        void 0 === t && (t = e.TEXTURE0 + P - 1), D !== t && (e.activeTexture(t), D = t)
                    },
                    bindTexture: function (t, n, r) {
                        void 0 === r && (r = null === D ? e.TEXTURE0 + P - 1 : D);
                        var i = O[r];
                        void 0 === i && (i = {
                            type: void 0,
                            texture: void 0
                        }, O[r] = i), i.type === t && i.texture === n || (D !== r && (e.activeTexture(r), D = r), e.bindTexture(t, n || V[t]), i.type = t, i.texture = n)
                    },
                    unbindTexture: function () {
                        var t = O[D];
                        void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null), t.type = void 0, t.texture = void 0)
                    },
                    compressedTexImage2D: function () {
                        try {
                            e.compressedTexImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexImage3D: function () {
                        try {
                            e.compressedTexImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage2D: function () {
                        try {
                            e.texImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texImage3D: function () {
                        try {
                            e.texImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    updateUBOMapping: function (t, n) {
                        var r = h.get(n);
                        void 0 === r && (r = new WeakMap, h.set(n, r));
                        var i = r.get(t);
                        void 0 === i && (i = e.getUniformBlockIndex(n, t.name), r.set(t, i))
                    },
                    uniformBlockBinding: function (t, n) {
                        var r = h.get(n).get(t);
                        c.get(n) !== r && (e.uniformBlockBinding(n, r, t.__bindingPointIndex), c.set(n, r))
                    },
                    texStorage2D: function () {
                        try {
                            e.texStorage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texStorage3D: function () {
                        try {
                            e.texStorage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage2D: function () {
                        try {
                            e.texSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    texSubImage3D: function () {
                        try {
                            e.texSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage2D: function () {
                        try {
                            e.compressedTexSubImage2D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    compressedTexSubImage3D: function () {
                        try {
                            e.compressedTexSubImage3D.apply(e, arguments)
                        } catch (e) {
                            console.error("THREE.WebGLState:", e)
                        }
                    },
                    scissor: function (t) {
                        !1 === z.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), z.copy(t))
                    },
                    viewport: function (t) {
                        !1 === H.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), H.copy(t))
                    },
                    reset: function () {
                        e.disable(e.BLEND), e.disable(e.CULL_FACE), e.disable(e.DEPTH_TEST), e.disable(e.POLYGON_OFFSET_FILL), e.disable(e.SCISSOR_TEST), e.disable(e.STENCIL_TEST), e.disable(e.SAMPLE_ALPHA_TO_COVERAGE), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ONE, e.ZERO), e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO), e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.depthMask(!0), e.depthFunc(e.LESS), e.clearDepth(1), e.stencilMask(4294967295), e.stencilFunc(e.ALWAYS, 0, 4294967295), e.stencilOp(e.KEEP, e.KEEP, e.KEEP), e.clearStencil(0), e.cullFace(e.BACK), e.frontFace(e.CCW), e.polygonOffset(0, 0), e.activeTexture(e.TEXTURE0), e.bindFramebuffer(e.FRAMEBUFFER, null), !0 === a && (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), e.bindFramebuffer(e.READ_FRAMEBUFFER, null)), e.useProgram(null), e.lineWidth(1), e.scissor(0, 0, e.canvas.width, e.canvas.height), e.viewport(0, 0, e.canvas.width, e.canvas.height), d = {}, D = null, O = {}, f = {}, p = new WeakMap, m = [], v = null, g = !1, _ = null, y = null, x = null, M = null, S = null, E = null, T = null, b = !1, A = null, w = null, R = null, C = null, L = null, z.set(0, 0, e.canvas.width, e.canvas.height), H.set(0, 0, e.canvas.width, e.canvas.height), o.reset(), s.reset(), u.reset()
                    }
                }
            }

            function Oo(e, t, n, r, i, a, o) {
                var s, u, c, h, d = i.isWebGL2,
                    f = i.maxTextures,
                    p = i.maxCubemapSize,
                    m = i.maxTextureSize,
                    v = i.maxSamples,
                    g = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null,
                    _ = "undefined" != typeof navigator && /OculusBrowser/g.test(navigator.userAgent),
                    y = new WeakMap,
                    x = new WeakMap,
                    M = !1;
                try {
                    M = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
                } catch (e) {}

                function S(e, t) {
                    return M ? new OffscreenCanvas(e, t) : Et("canvas")
                }

                function E(e, t, n, r) {
                    var i = 1;
                    if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)), i < 1 || !0 === t) {
                        if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                            var a = t ? mt : Math.floor,
                                o = a(i * e.width),
                                s = a(i * e.height);
                            void 0 === h && (h = S(o, s));
                            var l = n ? S(o, s) : h;
                            return l.width = o, l.height = s, l.getContext("2d").drawImage(e, 0, 0, o, s), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + s + ")."), l
                        }
                        return "data" in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."), e
                    }
                    return e
                }

                function T(e) {
                    return ft(e.width) && ft(e.height)
                }

                function b(e, t) {
                    return e.generateMipmaps && t && e.minFilter !== j && e.minFilter !== Y
                }

                function A(t) {
                    e.generateMipmap(t)
                }

                function w(n, r, i, a) {
                    var o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                    if (!1 === d) return r;
                    if (null !== n) {
                        if (void 0 !== e[n]) return e[n];
                        console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
                    }
                    var s = r;
                    return r === e.RED && (i === e.FLOAT && (s = e.R32F), i === e.HALF_FLOAT && (s = e.R16F), i === e.UNSIGNED_BYTE && (s = e.R8)), r === e.RED_INTEGER && (i === e.UNSIGNED_BYTE && (s = e.R8UI), i === e.UNSIGNED_SHORT && (s = e.R16UI), i === e.UNSIGNED_INT && (s = e.R32UI), i === e.BYTE && (s = e.R8I), i === e.SHORT && (s = e.R16I), i === e.INT && (s = e.R32I)), r === e.RG && (i === e.FLOAT && (s = e.RG32F), i === e.HALF_FLOAT && (s = e.RG16F), i === e.UNSIGNED_BYTE && (s = e.RG8)), r === e.RGBA && (i === e.FLOAT && (s = e.RGBA32F), i === e.HALF_FLOAT && (s = e.RGBA16F), i === e.UNSIGNED_BYTE && (s = a === Ke && !1 === o ? e.SRGB8_ALPHA8 : e.RGBA8), i === e.UNSIGNED_SHORT_4_4_4_4 && (s = e.RGBA4), i === e.UNSIGNED_SHORT_5_5_5_1 && (s = e.RGB5_A1)), s !== e.R16F && s !== e.R32F && s !== e.RG16F && s !== e.RG32F && s !== e.RGBA16F && s !== e.RGBA32F || t.get("EXT_color_buffer_float"), s
                }

                function R(e, t, n) {
                    return !0 === b(e, n) || e.isFramebufferTexture && e.minFilter !== j && e.minFilter !== Y ? Math.log2(Math.max(t.width, t.height)) + 1 : void 0 !== e.mipmaps && e.mipmaps.length > 0 ? e.mipmaps.length : e.isCompressedTexture && Array.isArray(e.image) ? t.mipmaps.length : 1
                }

                function C(t) {
                    return t === j || t === X || t === q ? e.NEAREST : e.LINEAR
                }

                function L(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", L),
                        function (e) {
                            var t = r.get(e);
                            if (void 0 === t.__webglInit) return;
                            var n = e.source,
                                i = x.get(n);
                            if (i) {
                                var a = i[t.__cacheKey];
                                a.usedTimes--, 0 === a.usedTimes && k(e), 0 === Object.keys(i).length && x.delete(n)
                            }
                            r.remove(e)
                        }(t), t.isVideoTexture && y.delete(t)
                }

                function P(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", P),
                        function (t) {
                            var n = t.texture,
                                i = r.get(t),
                                a = r.get(n);
                            void 0 !== a.__webglTexture && (e.deleteTexture(a.__webglTexture), o.memory.textures--);
                            t.depthTexture && t.depthTexture.dispose();
                            if (t.isWebGLCubeRenderTarget)
                                for (var s = 0; s < 6; s++) {
                                    if (Array.isArray(i.__webglFramebuffer[s]))
                                        for (var l = 0; l < i.__webglFramebuffer[s].length; l++) e.deleteFramebuffer(i.__webglFramebuffer[s][l]);
                                    else e.deleteFramebuffer(i.__webglFramebuffer[s]);
                                    i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[s])
                                } else {
                                    if (Array.isArray(i.__webglFramebuffer))
                                        for (var u = 0; u < i.__webglFramebuffer.length; u++) e.deleteFramebuffer(i.__webglFramebuffer[u]);
                                    else e.deleteFramebuffer(i.__webglFramebuffer);
                                    if (i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer), i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer), i.__webglColorRenderbuffer)
                                        for (var c = 0; c < i.__webglColorRenderbuffer.length; c++) i.__webglColorRenderbuffer[c] && e.deleteRenderbuffer(i.__webglColorRenderbuffer[c]);
                                    i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer)
                                }
                            if (t.isWebGLMultipleRenderTargets)
                                for (var h = 0, d = n.length; h < d; h++) {
                                    var f = r.get(n[h]);
                                    f.__webglTexture && (e.deleteTexture(f.__webglTexture), o.memory.textures--), r.remove(n[h])
                                }
                            r.remove(n), r.remove(t)
                        }(n)
                }

                function k(t) {
                    var n = r.get(t);
                    e.deleteTexture(n.__webglTexture);
                    var i = t.source;
                    delete x.get(i)[n.__cacheKey], o.memory.textures--
                }
                var I = 0;

                function U(t, i) {
                    var a = r.get(t);
                    if (t.isVideoTexture && function (e) {
                            var t = o.render.frame;
                            y.get(e) !== t && (y.set(e, t), e.update())
                        }(t), !1 === t.isRenderTargetTexture && t.version > 0 && a.__version !== t.version) {
                        var s = t.image;
                        if (null === s) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
                        else {
                            if (!1 !== s.complete) return void z(a, t, i);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.bindTexture(e.TEXTURE_2D, a.__webglTexture, e.TEXTURE0 + i)
                }
                var D = (l(s = {}, G, e.REPEAT), l(s, V, e.CLAMP_TO_EDGE), l(s, W, e.MIRRORED_REPEAT), s),
                    N = (l(u = {}, j, e.NEAREST), l(u, X, e.NEAREST_MIPMAP_NEAREST), l(u, q, e.NEAREST_MIPMAP_LINEAR), l(u, Y, e.LINEAR), l(u, K, e.LINEAR_MIPMAP_NEAREST), l(u, Z, e.LINEAR_MIPMAP_LINEAR), u),
                    O = (l(c = {}, 512, e.NEVER), l(c, 519, e.ALWAYS), l(c, 513, e.LESS), l(c, 515, e.LEQUAL), l(c, 514, e.EQUAL), l(c, 518, e.GEQUAL), l(c, 516, e.GREATER), l(c, 517, e.NOTEQUAL), c);

                function F(n, a, o) {
                    if (o ? (e.texParameteri(n, e.TEXTURE_WRAP_S, D[a.wrapS]), e.texParameteri(n, e.TEXTURE_WRAP_T, D[a.wrapT]), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, D[a.wrapR]), e.texParameteri(n, e.TEXTURE_MAG_FILTER, N[a.magFilter]), e.texParameteri(n, e.TEXTURE_MIN_FILTER, N[a.minFilter])) : (e.texParameteri(n, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(n, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY || e.texParameteri(n, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE), a.wrapS === V && a.wrapT === V || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), e.texParameteri(n, e.TEXTURE_MAG_FILTER, C(a.magFilter)), e.texParameteri(n, e.TEXTURE_MIN_FILTER, C(a.minFilter)), a.minFilter !== j && a.minFilter !== Y && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), a.compareFunction && (e.texParameteri(n, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE), e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, O[a.compareFunction])), !0 === t.has("EXT_texture_filter_anisotropic")) {
                        var s = t.get("EXT_texture_filter_anisotropic");
                        if (a.magFilter === j) return;
                        if (a.minFilter !== q && a.minFilter !== Z) return;
                        if (a.type === te && !1 === t.has("OES_texture_float_linear")) return;
                        if (!1 === d && a.type === ne && !1 === t.has("OES_texture_half_float_linear")) return;
                        (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (e.texParameterf(n, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function B(t, n) {
                    var r = !1;
                    void 0 === t.__webglInit && (t.__webglInit = !0, n.addEventListener("dispose", L));
                    var i = n.source,
                        a = x.get(i);
                    void 0 === a && (a = {}, x.set(i, a));
                    var s = function (e) {
                        var t = [];
                        return t.push(e.wrapS), t.push(e.wrapT), t.push(e.wrapR || 0), t.push(e.magFilter), t.push(e.minFilter), t.push(e.anisotropy), t.push(e.internalFormat), t.push(e.format), t.push(e.type), t.push(e.generateMipmaps), t.push(e.premultiplyAlpha), t.push(e.flipY), t.push(e.unpackAlignment), t.push(e.colorSpace), t.join()
                    }(n);
                    if (s !== t.__cacheKey) {
                        void 0 === a[s] && (a[s] = {
                            texture: e.createTexture(),
                            usedTimes: 0
                        }, o.memory.textures++, r = !0), a[s].usedTimes++;
                        var l = a[t.__cacheKey];
                        void 0 !== l && (a[t.__cacheKey].usedTimes--, 0 === l.usedTimes && k(n)), t.__cacheKey = s, t.__webglTexture = a[s].texture
                    }
                    return r
                }

                function z(t, i, o) {
                    var s = e.TEXTURE_2D;
                    (i.isDataArrayTexture || i.isCompressedArrayTexture) && (s = e.TEXTURE_2D_ARRAY), i.isData3DTexture && (s = e.TEXTURE_3D);
                    var l = B(t, i),
                        u = i.source;
                    n.bindTexture(s, t.__webglTexture, e.TEXTURE0 + o);
                    var c = r.get(u);
                    if (u.version !== c.__version || !0 === l) {
                        n.activeTexture(e.TEXTURE0 + o), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
                        var h, f = function (e) {
                                return !d && (e.wrapS !== V || e.wrapT !== V || e.minFilter !== j && e.minFilter !== Y)
                            }(i) && !1 === T(i.image),
                            p = E(i.image, f, !1, m),
                            v = T(p = ce(i, p)) || d,
                            g = a.convert(i.format, i.colorSpace),
                            _ = a.convert(i.type),
                            y = w(i.internalFormat, g, _, i.colorSpace);
                        F(s, i, v);
                        var x = i.mipmaps,
                            M = d && !0 !== i.isVideoTexture,
                            S = void 0 === c.__version || !0 === l,
                            C = R(i, p, v);
                        if (i.isDepthTexture) y = e.DEPTH_COMPONENT, d ? y = i.type === te ? e.DEPTH_COMPONENT32F : i.type === ee ? e.DEPTH_COMPONENT24 : i.type === ae ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT16 : i.type === te && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), i.format === se && y === e.DEPTH_COMPONENT && i.type !== Q && i.type !== ee && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), i.type = ee, _ = a.convert(i.type)), i.format === le && y === e.DEPTH_COMPONENT && (y = e.DEPTH_STENCIL, i.type !== ae && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), i.type = ae, _ = a.convert(i.type))), S && (M ? n.texStorage2D(e.TEXTURE_2D, 1, y, p.width, p.height) : n.texImage2D(e.TEXTURE_2D, 0, y, p.width, p.height, 0, g, _, null));
                        else if (i.isDataTexture)
                            if (x.length > 0 && v) {
                                M && S && n.texStorage2D(e.TEXTURE_2D, C, y, x[0].width, x[0].height);
                                for (var L = 0, P = x.length; L < P; L++) h = x[L], M ? n.texSubImage2D(e.TEXTURE_2D, L, 0, 0, h.width, h.height, g, _, h.data) : n.texImage2D(e.TEXTURE_2D, L, y, h.width, h.height, 0, g, _, h.data);
                                i.generateMipmaps = !1
                            } else M ? (S && n.texStorage2D(e.TEXTURE_2D, C, y, p.width, p.height), n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, p.width, p.height, g, _, p.data)) : n.texImage2D(e.TEXTURE_2D, 0, y, p.width, p.height, 0, g, _, p.data);
                        else if (i.isCompressedTexture)
                            if (i.isCompressedArrayTexture) {
                                M && S && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, y, x[0].width, x[0].height, p.depth);
                                for (var k = 0, I = x.length; k < I; k++) h = x[k], i.format !== oe ? null !== g ? M ? n.compressedTexSubImage3D(e.TEXTURE_2D_ARRAY, k, 0, 0, 0, h.width, h.height, p.depth, g, h.data, 0, 0) : n.compressedTexImage3D(e.TEXTURE_2D_ARRAY, k, y, h.width, h.height, p.depth, 0, h.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage3D(e.TEXTURE_2D_ARRAY, k, 0, 0, 0, h.width, h.height, p.depth, g, _, h.data) : n.texImage3D(e.TEXTURE_2D_ARRAY, k, y, h.width, h.height, p.depth, 0, g, _, h.data)
                            } else {
                                M && S && n.texStorage2D(e.TEXTURE_2D, C, y, x[0].width, x[0].height);
                                for (var U = 0, D = x.length; U < D; U++) h = x[U], i.format !== oe ? null !== g ? M ? n.compressedTexSubImage2D(e.TEXTURE_2D, U, 0, 0, h.width, h.height, g, h.data) : n.compressedTexImage2D(e.TEXTURE_2D, U, y, h.width, h.height, 0, h.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : M ? n.texSubImage2D(e.TEXTURE_2D, U, 0, 0, h.width, h.height, g, _, h.data) : n.texImage2D(e.TEXTURE_2D, U, y, h.width, h.height, 0, g, _, h.data)
                            }
                        else if (i.isDataArrayTexture) M ? (S && n.texStorage3D(e.TEXTURE_2D_ARRAY, C, y, p.width, p.height, p.depth), n.texSubImage3D(e.TEXTURE_2D_ARRAY, 0, 0, 0, 0, p.width, p.height, p.depth, g, _, p.data)) : n.texImage3D(e.TEXTURE_2D_ARRAY, 0, y, p.width, p.height, p.depth, 0, g, _, p.data);
                        else if (i.isData3DTexture) M ? (S && n.texStorage3D(e.TEXTURE_3D, C, y, p.width, p.height, p.depth), n.texSubImage3D(e.TEXTURE_3D, 0, 0, 0, 0, p.width, p.height, p.depth, g, _, p.data)) : n.texImage3D(e.TEXTURE_3D, 0, y, p.width, p.height, p.depth, 0, g, _, p.data);
                        else if (i.isFramebufferTexture) {
                            if (S)
                                if (M) n.texStorage2D(e.TEXTURE_2D, C, y, p.width, p.height);
                                else
                                    for (var N = p.width, O = p.height, z = 0; z < C; z++) n.texImage2D(e.TEXTURE_2D, z, y, N, O, 0, g, _, null), N >>= 1, O >>= 1
                        } else if (x.length > 0 && v) {
                            M && S && n.texStorage2D(e.TEXTURE_2D, C, y, x[0].width, x[0].height);
                            for (var H = 0, G = x.length; H < G; H++) h = x[H], M ? n.texSubImage2D(e.TEXTURE_2D, H, 0, 0, g, _, h) : n.texImage2D(e.TEXTURE_2D, H, y, g, _, h);
                            i.generateMipmaps = !1
                        } else M ? (S && n.texStorage2D(e.TEXTURE_2D, C, y, p.width, p.height), n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, g, _, p)) : n.texImage2D(e.TEXTURE_2D, 0, y, g, _, p);
                        b(i, v) && A(s), c.__version = u.version, i.onUpdate && i.onUpdate(i)
                    }
                    t.__version = i.version
                }

                function H(t, i, o, s, l, u) {
                    var c = a.convert(o.format, o.colorSpace),
                        h = a.convert(o.type),
                        d = w(o.internalFormat, c, h, o.colorSpace);
                    if (!r.get(i).__hasExternalTextures) {
                        var f = Math.max(1, i.width >> u),
                            p = Math.max(1, i.height >> u);
                        l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY ? n.texImage3D(l, u, d, f, p, i.depth, 0, c, h, null) : n.texImage2D(l, u, d, f, p, 0, c, h, null)
                    }
                    n.bindFramebuffer(e.FRAMEBUFFER, t), ue(i) ? g.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, s, l, r.get(o).__webglTexture, 0, ie(i)) : (l === e.TEXTURE_2D || l >= e.TEXTURE_CUBE_MAP_POSITIVE_X && l <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z) && e.framebufferTexture2D(e.FRAMEBUFFER, s, l, r.get(o).__webglTexture, u), n.bindFramebuffer(e.FRAMEBUFFER, null)
                }

                function $(t, n, r) {
                    if (e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer && !n.stencilBuffer) {
                        var i = e.DEPTH_COMPONENT16;
                        if (r || ue(n)) {
                            var o = n.depthTexture;
                            o && o.isDepthTexture && (o.type === te ? i = e.DEPTH_COMPONENT32F : o.type === ee && (i = e.DEPTH_COMPONENT24));
                            var s = ie(n);
                            ue(n) ? g.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, s, i, n.width, n.height) : e.renderbufferStorageMultisample(e.RENDERBUFFER, s, i, n.width, n.height)
                        } else e.renderbufferStorage(e.RENDERBUFFER, i, n.width, n.height);
                        e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.RENDERBUFFER, t)
                    } else if (n.depthBuffer && n.stencilBuffer) {
                        var l = ie(n);
                        r && !1 === ue(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, l, e.DEPTH24_STENCIL8, n.width, n.height) : ue(n) ? g.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, l, e.DEPTH24_STENCIL8, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, e.DEPTH_STENCIL, n.width, n.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.RENDERBUFFER, t)
                    } else
                        for (var u = !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture], c = 0; c < u.length; c++) {
                            var h = u[c],
                                d = a.convert(h.format, h.colorSpace),
                                f = a.convert(h.type),
                                p = w(h.internalFormat, d, f, h.colorSpace),
                                m = ie(n);
                            r && !1 === ue(n) ? e.renderbufferStorageMultisample(e.RENDERBUFFER, m, p, n.width, n.height) : ue(n) ? g.renderbufferStorageMultisampleEXT(e.RENDERBUFFER, m, p, n.width, n.height) : e.renderbufferStorage(e.RENDERBUFFER, p, n.width, n.height)
                        }
                    e.bindRenderbuffer(e.RENDERBUFFER, null)
                }

                function re(t) {
                    var i = r.get(t),
                        a = !0 === t.isWebGLCubeRenderTarget;
                    if (t.depthTexture && !i.__autoAllocateDepthBuffer) {
                        if (a) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function (t, i) {
                            if (i && i.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
                            if (n.bindFramebuffer(e.FRAMEBUFFER, t), !i.depthTexture || !i.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width, i.depthTexture.image.height = i.height, i.depthTexture.needsUpdate = !0), U(i.depthTexture, 0);
                            var a = r.get(i.depthTexture).__webglTexture,
                                o = ie(i);
                            if (i.depthTexture.format === se) ue(i) ? g.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0, o) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_ATTACHMENT, e.TEXTURE_2D, a, 0);
                            else {
                                if (i.depthTexture.format !== le) throw new Error("Unknown depthTexture format");
                                ue(i) ? g.framebufferTexture2DMultisampleEXT(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0, o) : e.framebufferTexture2D(e.FRAMEBUFFER, e.DEPTH_STENCIL_ATTACHMENT, e.TEXTURE_2D, a, 0)
                            }
                        }(i.__webglFramebuffer, t)
                    } else if (a) {
                        i.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer[o]), i.__webglDepthbuffer[o] = e.createRenderbuffer(), $(i.__webglDepthbuffer[o], t, !1)
                    } else n.bindFramebuffer(e.FRAMEBUFFER, i.__webglFramebuffer), i.__webglDepthbuffer = e.createRenderbuffer(), $(i.__webglDepthbuffer, t, !1);
                    n.bindFramebuffer(e.FRAMEBUFFER, null)
                }

                function ie(e) {
                    return Math.min(v, e.samples)
                }

                function ue(e) {
                    var n = r.get(e);
                    return d && e.samples > 0 && !0 === t.has("WEBGL_multisampled_render_to_texture") && !1 !== n.__useRenderToTexture
                }

                function ce(e, n) {
                    var r = e.colorSpace,
                        i = e.format,
                        a = e.type;
                    return !0 === e.isCompressedTexture || e.format === tt || r !== Ze && r !== Ye && (r === Ke ? !1 === d ? !0 === t.has("EXT_sRGB") && i === oe ? (e.format = tt, e.minFilter = Y, e.generateMipmaps = !1) : n = Ut.sRGBToLinear(n) : i === oe && a === J || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", r)), n
                }
                this.allocateTextureUnit = function () {
                    var e = I;
                    return e >= f && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + f), I += 1, e
                }, this.resetTextureUnits = function () {
                    I = 0
                }, this.setTexture2D = U, this.setTexture2DArray = function (t, i) {
                    var a = r.get(t);
                    t.version > 0 && a.__version !== t.version ? z(a, t, i) : n.bindTexture(e.TEXTURE_2D_ARRAY, a.__webglTexture, e.TEXTURE0 + i)
                }, this.setTexture3D = function (t, i) {
                    var a = r.get(t);
                    t.version > 0 && a.__version !== t.version ? z(a, t, i) : n.bindTexture(e.TEXTURE_3D, a.__webglTexture, e.TEXTURE0 + i)
                }, this.setTextureCube = function (t, i) {
                    var o = r.get(t);
                    t.version > 0 && o.__version !== t.version ? function (t, i, o) {
                        if (6 !== i.image.length) return;
                        var s = B(t, i),
                            l = i.source;
                        n.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + o);
                        var u = r.get(l);
                        if (l.version !== u.__version || !0 === s) {
                            n.activeTexture(e.TEXTURE0 + o), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, i.flipY), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha), e.pixelStorei(e.UNPACK_ALIGNMENT, i.unpackAlignment), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
                            for (var c = i.isCompressedTexture || i.image[0].isCompressedTexture, h = i.image[0] && i.image[0].isDataTexture, f = [], m = 0; m < 6; m++) f[m] = c || h ? h ? i.image[m].image : i.image[m] : E(i.image[m], !1, !0, p), f[m] = ce(i, f[m]);
                            var v, g = f[0],
                                _ = T(g) || d,
                                y = a.convert(i.format, i.colorSpace),
                                x = a.convert(i.type),
                                M = w(i.internalFormat, y, x, i.colorSpace),
                                S = d && !0 !== i.isVideoTexture,
                                C = void 0 === u.__version || !0 === s,
                                L = R(i, g, _);
                            if (F(e.TEXTURE_CUBE_MAP, i, _), c) {
                                S && C && n.texStorage2D(e.TEXTURE_CUBE_MAP, L, M, g.width, g.height);
                                for (var P = 0; P < 6; P++) {
                                    v = f[P].mipmaps;
                                    for (var k = 0; k < v.length; k++) {
                                        var I = v[k];
                                        i.format !== oe ? null !== y ? S ? n.compressedTexSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + P, k, 0, 0, I.width, I.height, y, I.data) : n.compressedTexImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + P, k, M, I.width, I.height, 0, I.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : S ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + P, k, 0, 0, I.width, I.height, y, x, I.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + P, k, M, I.width, I.height, 0, y, x, I.data)
                                    }
                                }
                            } else {
                                v = i.mipmaps, S && C && (v.length > 0 && L++, n.texStorage2D(e.TEXTURE_CUBE_MAP, L, M, f[0].width, f[0].height));
                                for (var U = 0; U < 6; U++)
                                    if (h) {
                                        S ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0, 0, 0, f[U].width, f[U].height, y, x, f[U].data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0, M, f[U].width, f[U].height, 0, y, x, f[U].data);
                                        for (var D = 0; D < v.length; D++) {
                                            var N = v[D].image[U].image;
                                            S ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, D + 1, 0, 0, N.width, N.height, y, x, N.data) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, D + 1, M, N.width, N.height, 0, y, x, N.data)
                                        }
                                    } else {
                                        S ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0, 0, 0, y, x, f[U]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, 0, M, y, x, f[U]);
                                        for (var O = 0; O < v.length; O++) {
                                            var z = v[O];
                                            S ? n.texSubImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, O + 1, 0, 0, y, x, z.image[U]) : n.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + U, O + 1, M, y, x, z.image[U])
                                        }
                                    }
                            }
                            b(i, _) && A(e.TEXTURE_CUBE_MAP), u.__version = l.version, i.onUpdate && i.onUpdate(i)
                        }
                        t.__version = i.version
                    }(o, t, i) : n.bindTexture(e.TEXTURE_CUBE_MAP, o.__webglTexture, e.TEXTURE0 + i)
                }, this.rebindTextures = function (t, n, i) {
                    var a = r.get(t);
                    void 0 !== n && H(a.__webglFramebuffer, t, t.texture, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, 0), void 0 !== i && re(t)
                }, this.setupRenderTarget = function (t) {
                    var s = t.texture,
                        l = r.get(t),
                        u = r.get(s);
                    t.addEventListener("dispose", P), !0 !== t.isWebGLMultipleRenderTargets && (void 0 === u.__webglTexture && (u.__webglTexture = e.createTexture()), u.__version = s.version, o.memory.textures++);
                    var c = !0 === t.isWebGLCubeRenderTarget,
                        h = !0 === t.isWebGLMultipleRenderTargets,
                        f = T(t) || d;
                    if (c) {
                        l.__webglFramebuffer = [];
                        for (var p = 0; p < 6; p++)
                            if (d && s.mipmaps && s.mipmaps.length > 0) {
                                l.__webglFramebuffer[p] = [];
                                for (var m = 0; m < s.mipmaps.length; m++) l.__webglFramebuffer[p][m] = e.createFramebuffer()
                            } else l.__webglFramebuffer[p] = e.createFramebuffer()
                    } else {
                        if (d && s.mipmaps && s.mipmaps.length > 0) {
                            l.__webglFramebuffer = [];
                            for (var v = 0; v < s.mipmaps.length; v++) l.__webglFramebuffer[v] = e.createFramebuffer()
                        } else l.__webglFramebuffer = e.createFramebuffer();
                        if (h)
                            if (i.drawBuffers)
                                for (var g = t.texture, _ = 0, y = g.length; _ < y; _++) {
                                    var x = r.get(g[_]);
                                    void 0 === x.__webglTexture && (x.__webglTexture = e.createTexture(), o.memory.textures++)
                                } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
                        if (d && t.samples > 0 && !1 === ue(t)) {
                            var M = h ? s : [s];
                            l.__webglMultisampledFramebuffer = e.createFramebuffer(), l.__webglColorRenderbuffer = [], n.bindFramebuffer(e.FRAMEBUFFER, l.__webglMultisampledFramebuffer);
                            for (var S = 0; S < M.length; S++) {
                                var E = M[S];
                                l.__webglColorRenderbuffer[S] = e.createRenderbuffer(), e.bindRenderbuffer(e.RENDERBUFFER, l.__webglColorRenderbuffer[S]);
                                var R = a.convert(E.format, E.colorSpace),
                                    C = a.convert(E.type),
                                    L = w(E.internalFormat, R, C, E.colorSpace, !0 === t.isXRRenderTarget),
                                    k = ie(t);
                                e.renderbufferStorageMultisample(e.RENDERBUFFER, k, L, t.width, t.height), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + S, e.RENDERBUFFER, l.__webglColorRenderbuffer[S])
                            }
                            e.bindRenderbuffer(e.RENDERBUFFER, null), t.depthBuffer && (l.__webglDepthRenderbuffer = e.createRenderbuffer(), $(l.__webglDepthRenderbuffer, t, !0)), n.bindFramebuffer(e.FRAMEBUFFER, null)
                        }
                    }
                    if (c) {
                        n.bindTexture(e.TEXTURE_CUBE_MAP, u.__webglTexture), F(e.TEXTURE_CUBE_MAP, s, f);
                        for (var I = 0; I < 6; I++)
                            if (d && s.mipmaps && s.mipmaps.length > 0)
                                for (var U = 0; U < s.mipmaps.length; U++) H(l.__webglFramebuffer[I][U], t, s, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + I, U);
                            else H(l.__webglFramebuffer[I], t, s, e.COLOR_ATTACHMENT0, e.TEXTURE_CUBE_MAP_POSITIVE_X + I, 0);
                        b(s, f) && A(e.TEXTURE_CUBE_MAP), n.unbindTexture()
                    } else if (h) {
                        for (var D = t.texture, N = 0, O = D.length; N < O; N++) {
                            var B = D[N],
                                z = r.get(B);
                            n.bindTexture(e.TEXTURE_2D, z.__webglTexture), F(e.TEXTURE_2D, B, f), H(l.__webglFramebuffer, t, B, e.COLOR_ATTACHMENT0 + N, e.TEXTURE_2D, 0), b(B, f) && A(e.TEXTURE_2D)
                        }
                        n.unbindTexture()
                    } else {
                        var G = e.TEXTURE_2D;
                        if ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) && (d ? G = t.isWebGL3DRenderTarget ? e.TEXTURE_3D : e.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), n.bindTexture(G, u.__webglTexture), F(G, s, f), d && s.mipmaps && s.mipmaps.length > 0)
                            for (var V = 0; V < s.mipmaps.length; V++) H(l.__webglFramebuffer[V], t, s, e.COLOR_ATTACHMENT0, G, V);
                        else H(l.__webglFramebuffer, t, s, e.COLOR_ATTACHMENT0, G, 0);
                        b(s, f) && A(G), n.unbindTexture()
                    }
                    t.depthBuffer && re(t)
                }, this.updateRenderTargetMipmap = function (t) {
                    for (var i = T(t) || d, a = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture], o = 0, s = a.length; o < s; o++) {
                        var l = a[o];
                        if (b(l, i)) {
                            var u = t.isWebGLCubeRenderTarget ? e.TEXTURE_CUBE_MAP : e.TEXTURE_2D,
                                c = r.get(l).__webglTexture;
                            n.bindTexture(u, c), A(u), n.unbindTexture()
                        }
                    }
                }, this.updateMultisampleRenderTarget = function (t) {
                    if (d && t.samples > 0 && !1 === ue(t)) {
                        var i = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
                            a = t.width,
                            o = t.height,
                            s = e.COLOR_BUFFER_BIT,
                            l = [],
                            u = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
                            c = r.get(t),
                            h = !0 === t.isWebGLMultipleRenderTargets;
                        if (h)
                            for (var f = 0; f < i.length; f++) n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + f, e.RENDERBUFFER, null), n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + f, e.TEXTURE_2D, null, 0);
                        n.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
                        for (var p = 0; p < i.length; p++) {
                            l.push(e.COLOR_ATTACHMENT0 + p), t.depthBuffer && l.push(u);
                            var m = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
                            if (!1 === m && (t.depthBuffer && (s |= e.DEPTH_BUFFER_BIT), t.stencilBuffer && (s |= e.STENCIL_BUFFER_BIT)), h && e.framebufferRenderbuffer(e.READ_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.RENDERBUFFER, c.__webglColorRenderbuffer[p]), !0 === m && (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [u]), e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [u])), h) {
                                var v = r.get(i[p]).__webglTexture;
                                e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, v, 0)
                            }
                            e.blitFramebuffer(0, 0, a, o, 0, 0, a, o, s, e.NEAREST), _ && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l)
                        }
                        if (n.bindFramebuffer(e.READ_FRAMEBUFFER, null), n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null), h)
                            for (var g = 0; g < i.length; g++) {
                                n.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer), e.framebufferRenderbuffer(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0 + g, e.RENDERBUFFER, c.__webglColorRenderbuffer[g]);
                                var y = r.get(i[g]).__webglTexture;
                                n.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer), e.framebufferTexture2D(e.DRAW_FRAMEBUFFER, e.COLOR_ATTACHMENT0 + g, e.TEXTURE_2D, y, 0)
                            }
                        n.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer)
                    }
                }, this.setupDepthRenderbuffer = re, this.setupFrameBufferTexture = H, this.useMultisampledRTT = ue
            }

            function Fo(e, t, n) {
                var r = n.isWebGL2;
                return {
                    convert: function (n) {
                        var i, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ye;
                        if (n === J) return e.UNSIGNED_BYTE;
                        if (n === re) return e.UNSIGNED_SHORT_4_4_4_4;
                        if (n === ie) return e.UNSIGNED_SHORT_5_5_5_1;
                        if (1010 === n) return e.BYTE;
                        if (1011 === n) return e.SHORT;
                        if (n === Q) return e.UNSIGNED_SHORT;
                        if (n === $) return e.INT;
                        if (n === ee) return e.UNSIGNED_INT;
                        if (n === te) return e.FLOAT;
                        if (n === ne) return r ? e.HALF_FLOAT : null !== (i = t.get("OES_texture_half_float")) ? i.HALF_FLOAT_OES : null;
                        if (1021 === n) return e.ALPHA;
                        if (n === oe) return e.RGBA;
                        if (1024 === n) return e.LUMINANCE;
                        if (1025 === n) return e.LUMINANCE_ALPHA;
                        if (n === se) return e.DEPTH_COMPONENT;
                        if (n === le) return e.DEPTH_STENCIL;
                        if (n === tt) return null !== (i = t.get("EXT_sRGB")) ? i.SRGB_ALPHA_EXT : null;
                        if (1028 === n) return e.RED;
                        if (n === ue) return e.RED_INTEGER;
                        if (1030 === n) return e.RG;
                        if (n === ce) return e.RG_INTEGER;
                        if (n === he) return e.RGBA_INTEGER;
                        if (n === de || n === fe || n === pe || n === me)
                            if (a === Ke) {
                                if (null === (i = t.get("WEBGL_compressed_texture_s3tc_srgb"))) return null;
                                if (n === de) return i.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                if (n === fe) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                if (n === pe) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                if (n === me) return i.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                            } else {
                                if (null === (i = t.get("WEBGL_compressed_texture_s3tc"))) return null;
                                if (n === de) return i.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                if (n === fe) return i.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                if (n === pe) return i.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                if (n === me) return i.COMPRESSED_RGBA_S3TC_DXT5_EXT
                            } if (n === ve || n === ge || n === _e || n === ye) {
                            if (null === (i = t.get("WEBGL_compressed_texture_pvrtc"))) return null;
                            if (n === ve) return i.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (n === ge) return i.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (n === _e) return i.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (n === ye) return i.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (36196 === n) return null !== (i = t.get("WEBGL_compressed_texture_etc1")) ? i.COMPRESSED_RGB_ETC1_WEBGL : null;
                        if (n === xe || n === Me) {
                            if (null === (i = t.get("WEBGL_compressed_texture_etc"))) return null;
                            if (n === xe) return a === Ke ? i.COMPRESSED_SRGB8_ETC2 : i.COMPRESSED_RGB8_ETC2;
                            if (n === Me) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : i.COMPRESSED_RGBA8_ETC2_EAC
                        }
                        if (n === Se || n === Ee || n === Te || n === be || n === Ae || n === we || n === Re || n === Ce || n === Le || n === Pe || n === ke || n === Ie || n === Ue || n === De) {
                            if (null === (i = t.get("WEBGL_compressed_texture_astc"))) return null;
                            if (n === Se) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : i.COMPRESSED_RGBA_ASTC_4x4_KHR;
                            if (n === Ee) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : i.COMPRESSED_RGBA_ASTC_5x4_KHR;
                            if (n === Te) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : i.COMPRESSED_RGBA_ASTC_5x5_KHR;
                            if (n === be) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : i.COMPRESSED_RGBA_ASTC_6x5_KHR;
                            if (n === Ae) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : i.COMPRESSED_RGBA_ASTC_6x6_KHR;
                            if (n === we) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : i.COMPRESSED_RGBA_ASTC_8x5_KHR;
                            if (n === Re) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : i.COMPRESSED_RGBA_ASTC_8x6_KHR;
                            if (n === Ce) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : i.COMPRESSED_RGBA_ASTC_8x8_KHR;
                            if (n === Le) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : i.COMPRESSED_RGBA_ASTC_10x5_KHR;
                            if (n === Pe) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : i.COMPRESSED_RGBA_ASTC_10x6_KHR;
                            if (n === ke) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : i.COMPRESSED_RGBA_ASTC_10x8_KHR;
                            if (n === Ie) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : i.COMPRESSED_RGBA_ASTC_10x10_KHR;
                            if (n === Ue) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : i.COMPRESSED_RGBA_ASTC_12x10_KHR;
                            if (n === De) return a === Ke ? i.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : i.COMPRESSED_RGBA_ASTC_12x12_KHR
                        }
                        if (n === Ne) {
                            if (null === (i = t.get("EXT_texture_compression_bptc"))) return null;
                            if (n === Ne) return a === Ke ? i.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : i.COMPRESSED_RGBA_BPTC_UNORM_EXT
                        }
                        if (36283 === n || n === Oe || n === Fe || n === Be) {
                            if (null === (i = t.get("EXT_texture_compression_rgtc"))) return null;
                            if (n === Ne) return i.COMPRESSED_RED_RGTC1_EXT;
                            if (n === Oe) return i.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                            if (n === Fe) return i.COMPRESSED_RED_GREEN_RGTC2_EXT;
                            if (n === Be) return i.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                        }
                        return n === ae ? r ? e.UNSIGNED_INT_24_8 : null !== (i = t.get("WEBGL_depth_texture")) ? i.UNSIGNED_INT_24_8_WEBGL : null : void 0 !== e[n] ? e[n] : null
                    }
                }
            }
            var Bo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                        return i(this, n), (e = t.call(this)).isArrayCamera = !0, e.cameras = r, e
                    }
                    return o(n)
                }(ni),
                zo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isGroup = !0, e.type = "Group", e
                    }
                    return o(n)
                }(Yn),
                Ho = {
                    type: "move"
                },
                Go = function () {
                    function e() {
                        i(this, e), this._targetRay = null, this._grip = null, this._hand = null
                    }
                    return o(e, [{
                        key: "getHandSpace",
                        value: function () {
                            return null === this._hand && (this._hand = new zo, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
                                pinching: !1
                            }), this._hand
                        }
                    }, {
                        key: "getTargetRaySpace",
                        value: function () {
                            return null === this._targetRay && (this._targetRay = new zo, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Xt, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Xt), this._targetRay
                        }
                    }, {
                        key: "getGripSpace",
                        value: function () {
                            return null === this._grip && (this._grip = new zo, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Xt, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Xt), this._grip
                        }
                    }, {
                        key: "dispatchEvent",
                        value: function (e) {
                            return null !== this._targetRay && this._targetRay.dispatchEvent(e), null !== this._grip && this._grip.dispatchEvent(e), null !== this._hand && this._hand.dispatchEvent(e), this
                        }
                    }, {
                        key: "connect",
                        value: function (e) {
                            if (e && e.hand) {
                                var t = this._hand;
                                if (t) {
                                    var n, r = p(e.hand.values());
                                    try {
                                        for (r.s(); !(n = r.n()).done;) {
                                            var i = n.value;
                                            this._getHandJoint(t, i)
                                        }
                                    } catch (e) {
                                        r.e(e)
                                    } finally {
                                        r.f()
                                    }
                                }
                            }
                            return this.dispatchEvent({
                                type: "connected",
                                data: e
                            }), this
                        }
                    }, {
                        key: "disconnect",
                        value: function (e) {
                            return this.dispatchEvent({
                                type: "disconnected",
                                data: e
                            }), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
                        }
                    }, {
                        key: "update",
                        value: function (e, t, n) {
                            var r = null,
                                i = null,
                                a = null,
                                o = this._targetRay,
                                s = this._grip,
                                l = this._hand;
                            if (e && "visible-blurred" !== t.session.visibilityState) {
                                if (l && e.hand) {
                                    a = !0;
                                    var u, c = p(e.hand.values());
                                    try {
                                        for (c.s(); !(u = c.n()).done;) {
                                            var h = u.value,
                                                d = t.getJointPose(h, n),
                                                f = this._getHandJoint(l, h);
                                            null !== d && (f.matrix.fromArray(d.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), f.matrixWorldNeedsUpdate = !0, f.jointRadius = d.radius), f.visible = null !== d
                                        }
                                    } catch (e) {
                                        c.e(e)
                                    } finally {
                                        c.f()
                                    }
                                    var m = l.joints["index-finger-tip"],
                                        v = l.joints["thumb-tip"],
                                        g = m.position.distanceTo(v.position);
                                    l.inputState.pinching && g > .025 ? (l.inputState.pinching = !1, this.dispatchEvent({
                                        type: "pinchend",
                                        handedness: e.handedness,
                                        target: this
                                    })) : !l.inputState.pinching && g <= .015 && (l.inputState.pinching = !0, this.dispatchEvent({
                                        type: "pinchstart",
                                        handedness: e.handedness,
                                        target: this
                                    }))
                                } else null !== s && e.gripSpace && null !== (i = t.getPose(e.gripSpace, n)) && (s.matrix.fromArray(i.transform.matrix), s.matrix.decompose(s.position, s.rotation, s.scale), s.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (s.hasLinearVelocity = !0, s.linearVelocity.copy(i.linearVelocity)) : s.hasLinearVelocity = !1, i.angularVelocity ? (s.hasAngularVelocity = !0, s.angularVelocity.copy(i.angularVelocity)) : s.hasAngularVelocity = !1);
                                null !== o && (null === (r = t.getPose(e.targetRaySpace, n)) && null !== i && (r = i), null !== r && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (o.hasLinearVelocity = !0, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = !1, r.angularVelocity ? (o.hasAngularVelocity = !0, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = !1, this.dispatchEvent(Ho)))
                            }
                            return null !== o && (o.visible = null !== r), null !== s && (s.visible = null !== i), null !== l && (l.visible = null !== a), this
                        }
                    }, {
                        key: "_getHandJoint",
                        value: function (e, t) {
                            if (void 0 === e.joints[t.jointName]) {
                                var n = new zo;
                                n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
                            }
                            return e.joints[t.jointName]
                        }
                    }]), e
                }(),
                Vo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o, s, l, u, c, h, d) {
                        var f;
                        if (i(this, n), (d = void 0 !== d ? d : se) !== se && d !== le) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                        return void 0 === a && d === se && (a = ee), void 0 === a && d === le && (a = ae), (f = t.call(this, null, o, s, l, u, c, d, a, h)).isDepthTexture = !0, f.image = {
                            width: e,
                            height: r
                        }, f.magFilter = void 0 !== u ? u : j, f.minFilter = void 0 !== c ? c : j, f.flipY = !1, f.generateMipmaps = !1, f.compareFunction = null, f
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.compareFunction = e.compareFunction, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            return null !== this.compareFunction && (t.compareFunction = this.compareFunction), t
                        }
                    }]), n
                }(Bt),
                Wo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        i(this, n), a = t.call(this);
                        var o = M(a),
                            s = null,
                            l = 1,
                            u = null,
                            c = "local-floor",
                            h = 1,
                            d = null,
                            p = null,
                            m = null,
                            v = null,
                            g = null,
                            _ = null,
                            y = r.getContextAttributes(),
                            x = null,
                            S = null,
                            E = [],
                            T = [],
                            b = new ni;
                        b.layers.enable(1), b.viewport = new zt;
                        var A = new ni;
                        A.layers.enable(2), A.viewport = new zt;
                        var R = [b, A],
                            C = new Bo;
                        C.layers.enable(1), C.layers.enable(2);
                        var L = null,
                            P = null;

                        function k(e) {
                            var t = T.indexOf(e.inputSource);
                            if (-1 !== t) {
                                var n = E[t];
                                void 0 !== n && (n.update(e.inputSource, e.frame, d || u), n.dispatchEvent({
                                    type: e.type,
                                    data: e.inputSource
                                }))
                            }
                        }

                        function I() {
                            s.removeEventListener("select", k), s.removeEventListener("selectstart", k), s.removeEventListener("selectend", k), s.removeEventListener("squeeze", k), s.removeEventListener("squeezestart", k), s.removeEventListener("squeezeend", k), s.removeEventListener("end", I), s.removeEventListener("inputsourceschange", U);
                            for (var t = 0; t < E.length; t++) {
                                var n = T[t];
                                null !== n && (T[t] = null, E[t].disconnect(n))
                            }
                            L = null, P = null, e.setRenderTarget(x), g = null, v = null, m = null, s = null, S = null, B.stop(), o.isPresenting = !1, o.dispatchEvent({
                                type: "sessionend"
                            })
                        }

                        function U(e) {
                            for (var t = 0; t < e.removed.length; t++) {
                                var n = e.removed[t],
                                    r = T.indexOf(n);
                                r >= 0 && (T[r] = null, E[r].disconnect(n))
                            }
                            for (var i = 0; i < e.added.length; i++) {
                                var a = e.added[i],
                                    o = T.indexOf(a);
                                if (-1 === o) {
                                    for (var s = 0; s < E.length; s++) {
                                        if (s >= T.length) {
                                            T.push(a), o = s;
                                            break
                                        }
                                        if (null === T[s]) {
                                            T[s] = a, o = s;
                                            break
                                        }
                                    }
                                    if (-1 === o) break
                                }
                                var l = E[o];
                                l && l.connect(a)
                            }
                        }
                        a.cameraAutoUpdate = !0, a.enabled = !1, a.isPresenting = !1, a.getController = function (e) {
                            var t = E[e];
                            return void 0 === t && (t = new Go, E[e] = t), t.getTargetRaySpace()
                        }, a.getControllerGrip = function (e) {
                            var t = E[e];
                            return void 0 === t && (t = new Go, E[e] = t), t.getGripSpace()
                        }, a.getHand = function (e) {
                            var t = E[e];
                            return void 0 === t && (t = new Go, E[e] = t), t.getHandSpace()
                        }, a.setFramebufferScaleFactor = function (e) {
                            l = e, !0 === o.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
                        }, a.setReferenceSpaceType = function (e) {
                            c = e, !0 === o.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
                        }, a.getReferenceSpace = function () {
                            return d || u
                        }, a.setReferenceSpace = function (e) {
                            d = e
                        }, a.getBaseLayer = function () {
                            return null !== v ? v : g
                        }, a.getBinding = function () {
                            return m
                        }, a.getFrame = function () {
                            return _
                        }, a.getSession = function () {
                            return s
                        }, a.setSession = function () {
                            var t = f(w().mark((function t(n) {
                                var i, a, f, p, _;
                                return w().wrap((function (t) {
                                    for (;;) switch (t.prev = t.next) {
                                        case 0:
                                            if (null === (s = n)) {
                                                t.next = 25;
                                                break
                                            }
                                            if (x = e.getRenderTarget(), s.addEventListener("select", k), s.addEventListener("selectstart", k), s.addEventListener("selectend", k), s.addEventListener("squeeze", k), s.addEventListener("squeezestart", k), s.addEventListener("squeezeend", k), s.addEventListener("end", I), s.addEventListener("inputsourceschange", U), !0 === y.xrCompatible) {
                                                t.next = 14;
                                                break
                                            }
                                            return t.next = 14, r.makeXRCompatible();
                                        case 14:
                                            return void 0 === s.renderState.layers || !1 === e.capabilities.isWebGL2 ? (i = {
                                                antialias: void 0 !== s.renderState.layers || y.antialias,
                                                alpha: !0,
                                                depth: y.depth,
                                                stencil: y.stencil,
                                                framebufferScaleFactor: l
                                            }, g = new XRWebGLLayer(s, r, i), s.updateRenderState({
                                                baseLayer: g
                                            }), S = new Gt(g.framebufferWidth, g.framebufferHeight, {
                                                format: oe,
                                                type: J,
                                                colorSpace: e.outputColorSpace,
                                                stencilBuffer: y.stencil
                                            })) : (a = null, f = null, p = null, y.depth && (p = y.stencil ? r.DEPTH24_STENCIL8 : r.DEPTH_COMPONENT24, a = y.stencil ? le : se, f = y.stencil ? ae : ee), _ = {
                                                colorFormat: r.RGBA8,
                                                depthFormat: p,
                                                scaleFactor: l
                                            }, m = new XRWebGLBinding(s, r), v = m.createProjectionLayer(_), s.updateRenderState({
                                                layers: [v]
                                            }), S = new Gt(v.textureWidth, v.textureHeight, {
                                                format: oe,
                                                type: J,
                                                depthTexture: new Vo(v.textureWidth, v.textureHeight, f, void 0, void 0, void 0, void 0, void 0, void 0, a),
                                                stencilBuffer: y.stencil,
                                                colorSpace: e.outputColorSpace,
                                                samples: y.antialias ? 4 : 0
                                            }), e.properties.get(S).__ignoreDepthValues = v.ignoreDepthValues), S.isXRRenderTarget = !0, this.setFoveation(h), d = null, t.next = 20, s.requestReferenceSpace(c);
                                        case 20:
                                            u = t.sent, B.setContext(s), B.start(), o.isPresenting = !0, o.dispatchEvent({
                                                type: "sessionstart"
                                            });
                                        case 25:
                                        case "end":
                                            return t.stop()
                                    }
                                }), t, this)
                            })));
                            return function (e) {
                                return t.apply(this, arguments)
                            }
                        }(), a.getEnvironmentBlendMode = function () {
                            if (null !== s) return s.environmentBlendMode
                        };
                        var D = new Xt,
                            N = new Xt;

                        function O(e, t) {
                            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix), e.matrixWorldInverse.copy(e.matrixWorld).invert()
                        }
                        a.updateCamera = function (e) {
                            if (null !== s) {
                                C.near = A.near = b.near = e.near, C.far = A.far = b.far = e.far, L === C.near && P === C.far || (s.updateRenderState({
                                    depthNear: C.near,
                                    depthFar: C.far
                                }), L = C.near, P = C.far);
                                var t = e.parent,
                                    n = C.cameras;
                                O(C, t);
                                for (var r = 0; r < n.length; r++) O(n[r], t);
                                2 === n.length ? function (e, t, n) {
                                        D.setFromMatrixPosition(t.matrixWorld), N.setFromMatrixPosition(n.matrixWorld);
                                        var r = D.distanceTo(N),
                                            i = t.projectionMatrix.elements,
                                            a = n.projectionMatrix.elements,
                                            o = i[14] / (i[10] - 1),
                                            s = i[14] / (i[10] + 1),
                                            l = (i[9] + 1) / i[5],
                                            u = (i[9] - 1) / i[5],
                                            c = (i[8] - 1) / i[0],
                                            h = (a[8] + 1) / a[0],
                                            d = o * c,
                                            f = o * h,
                                            p = r / (-c + h),
                                            m = p * -c;
                                        t.matrixWorld.decompose(e.position, e.quaternion, e.scale), e.translateX(m), e.translateZ(p), e.matrixWorld.compose(e.position, e.quaternion, e.scale), e.matrixWorldInverse.copy(e.matrixWorld).invert();
                                        var v = o + p,
                                            g = s + p,
                                            _ = d - m,
                                            y = f + (r - m),
                                            x = l * s / g * v,
                                            M = u * s / g * v;
                                        e.projectionMatrix.makePerspective(_, y, x, M, v, g), e.projectionMatrixInverse.copy(e.projectionMatrix).invert()
                                    }(C, b, A) : C.projectionMatrix.copy(b.projectionMatrix),
                                    function (e, t, n) {
                                        null === n ? e.matrix.copy(t.matrixWorld) : (e.matrix.copy(n.matrixWorld), e.matrix.invert(), e.matrix.multiply(t.matrixWorld));
                                        e.matrix.decompose(e.position, e.quaternion, e.scale), e.updateMatrixWorld(!0);
                                        for (var r = e.children, i = 0, a = r.length; i < a; i++) r[i].updateMatrixWorld(!0);
                                        e.projectionMatrix.copy(t.projectionMatrix), e.projectionMatrixInverse.copy(t.projectionMatrixInverse), e.isPerspectiveCamera && (e.fov = 2 * lt * Math.atan(1 / e.projectionMatrix.elements[5]), e.zoom = 1)
                                    }(e, C, t)
                            }
                        }, a.getCamera = function () {
                            return C
                        }, a.getFoveation = function () {
                            if (null !== v || null !== g) return h
                        }, a.setFoveation = function (e) {
                            h = e, null !== v && (v.fixedFoveation = e), null !== g && void 0 !== g.fixedFoveation && (g.fixedFoveation = e)
                        };
                        var F = null;
                        var B = new pi;
                        return B.setAnimationLoop((function (t, n) {
                            if (p = n.getViewerPose(d || u), _ = n, null !== p) {
                                var r = p.views;
                                null !== g && (e.setRenderTargetFramebuffer(S, g.framebuffer), e.setRenderTarget(S));
                                var i = !1;
                                r.length !== C.cameras.length && (C.cameras.length = 0, i = !0);
                                for (var a = 0; a < r.length; a++) {
                                    var s = r[a],
                                        l = null;
                                    if (null !== g) l = g.getViewport(s);
                                    else {
                                        var c = m.getViewSubImage(v, s);
                                        l = c.viewport, 0 === a && (e.setRenderTargetTextures(S, c.colorTexture, v.ignoreDepthValues ? void 0 : c.depthStencilTexture), e.setRenderTarget(S))
                                    }
                                    var h = R[a];
                                    void 0 === h && ((h = new ni).layers.enable(a), h.viewport = new zt, R[a] = h), h.matrix.fromArray(s.transform.matrix), h.matrix.decompose(h.position, h.quaternion, h.scale), h.projectionMatrix.fromArray(s.projectionMatrix), h.projectionMatrixInverse.copy(h.projectionMatrix).invert(), h.viewport.set(l.x, l.y, l.width, l.height), 0 === a && (C.matrix.copy(h.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), !0 === i && C.cameras.push(h)
                                }
                            }
                            for (var f = 0; f < E.length; f++) {
                                var y = T[f],
                                    x = E[f];
                                null !== y && void 0 !== x && x.update(y, n, d || u)
                            }
                            F && F(t, n), n.detectedPlanes && o.dispatchEvent({
                                type: "planesdetected",
                                data: n
                            }), _ = null
                        })), a.setAnimationLoop = function (e) {
                            F = e
                        }, a.dispose = function () {}, a
                    }
                    return o(n)
                }(it);

            function jo(e, t) {
                function n(e, t) {
                    !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix)
                }

                function r(r, i) {
                    r.opacity.value = i.opacity, i.color && r.diffuse.value.copy(i.color), i.emissive && r.emissive.value.copy(i.emissive).multiplyScalar(i.emissiveIntensity), i.map && (r.map.value = i.map, n(i.map, r.mapTransform)), i.alphaMap && (r.alphaMap.value = i.alphaMap, n(i.alphaMap, r.alphaMapTransform)), i.bumpMap && (r.bumpMap.value = i.bumpMap, n(i.bumpMap, r.bumpMapTransform), r.bumpScale.value = i.bumpScale, 1 === i.side && (r.bumpScale.value *= -1)), i.normalMap && (r.normalMap.value = i.normalMap, n(i.normalMap, r.normalMapTransform), r.normalScale.value.copy(i.normalScale), 1 === i.side && r.normalScale.value.negate()), i.displacementMap && (r.displacementMap.value = i.displacementMap, n(i.displacementMap, r.displacementMapTransform), r.displacementScale.value = i.displacementScale, r.displacementBias.value = i.displacementBias), i.emissiveMap && (r.emissiveMap.value = i.emissiveMap, n(i.emissiveMap, r.emissiveMapTransform)), i.specularMap && (r.specularMap.value = i.specularMap, n(i.specularMap, r.specularMapTransform)), i.alphaTest > 0 && (r.alphaTest.value = i.alphaTest);
                    var a = t.get(i).envMap;
                    if (a && (r.envMap.value = a, r.flipEnvMap.value = a.isCubeTexture && !1 === a.isRenderTargetTexture ? -1 : 1, r.reflectivity.value = i.reflectivity, r.ior.value = i.ior, r.refractionRatio.value = i.refractionRatio), i.lightMap) {
                        r.lightMap.value = i.lightMap;
                        var o = !0 === e._useLegacyLights ? Math.PI : 1;
                        r.lightMapIntensity.value = i.lightMapIntensity * o, n(i.lightMap, r.lightMapTransform)
                    }
                    i.aoMap && (r.aoMap.value = i.aoMap, r.aoMapIntensity.value = i.aoMapIntensity, n(i.aoMap, r.aoMapTransform))
                }
                return {
                    refreshFogUniforms: function (t, n) {
                        n.color.getRGB(t.fogColor.value, Qr(e)), n.isFog ? (t.fogNear.value = n.near, t.fogFar.value = n.far) : n.isFogExp2 && (t.fogDensity.value = n.density)
                    },
                    refreshMaterialUniforms: function (e, i, a, o, s) {
                        i.isMeshBasicMaterial || i.isMeshLambertMaterial ? r(e, i) : i.isMeshToonMaterial ? (r(e, i), function (e, t) {
                            t.gradientMap && (e.gradientMap.value = t.gradientMap)
                        }(e, i)) : i.isMeshPhongMaterial ? (r(e, i), function (e, t) {
                            e.specular.value.copy(t.specular), e.shininess.value = Math.max(t.shininess, 1e-4)
                        }(e, i)) : i.isMeshStandardMaterial ? (r(e, i), function (e, r) {
                            e.metalness.value = r.metalness, r.metalnessMap && (e.metalnessMap.value = r.metalnessMap, n(r.metalnessMap, e.metalnessMapTransform));
                            e.roughness.value = r.roughness, r.roughnessMap && (e.roughnessMap.value = r.roughnessMap, n(r.roughnessMap, e.roughnessMapTransform));
                            var i = t.get(r).envMap;
                            i && (e.envMapIntensity.value = r.envMapIntensity)
                        }(e, i), i.isMeshPhysicalMaterial && function (e, t, r) {
                            e.ior.value = t.ior, t.sheen > 0 && (e.sheenColor.value.copy(t.sheenColor).multiplyScalar(t.sheen), e.sheenRoughness.value = t.sheenRoughness, t.sheenColorMap && (e.sheenColorMap.value = t.sheenColorMap, n(t.sheenColorMap, e.sheenColorMapTransform)), t.sheenRoughnessMap && (e.sheenRoughnessMap.value = t.sheenRoughnessMap, n(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
                            t.clearcoat > 0 && (e.clearcoat.value = t.clearcoat, e.clearcoatRoughness.value = t.clearcoatRoughness, t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap, n(t.clearcoatMap, e.clearcoatMapTransform)), t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap, n(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)), t.clearcoatNormalMap && (e.clearcoatNormalMap.value = t.clearcoatNormalMap, n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform), e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale), 1 === t.side && e.clearcoatNormalScale.value.negate()));
                            t.iridescence > 0 && (e.iridescence.value = t.iridescence, e.iridescenceIOR.value = t.iridescenceIOR, e.iridescenceThicknessMinimum.value = t.iridescenceThicknessRange[0], e.iridescenceThicknessMaximum.value = t.iridescenceThicknessRange[1], t.iridescenceMap && (e.iridescenceMap.value = t.iridescenceMap, n(t.iridescenceMap, e.iridescenceMapTransform)), t.iridescenceThicknessMap && (e.iridescenceThicknessMap.value = t.iridescenceThicknessMap, n(t.iridescenceThicknessMap, e.iridescenceThicknessMapTransform)));
                            t.transmission > 0 && (e.transmission.value = t.transmission, e.transmissionSamplerMap.value = r.texture, e.transmissionSamplerSize.value.set(r.width, r.height), t.transmissionMap && (e.transmissionMap.value = t.transmissionMap, n(t.transmissionMap, e.transmissionMapTransform)), e.thickness.value = t.thickness, t.thicknessMap && (e.thicknessMap.value = t.thicknessMap, n(t.thicknessMap, e.thicknessMapTransform)), e.attenuationDistance.value = t.attenuationDistance, e.attenuationColor.value.copy(t.attenuationColor));
                            t.anisotropy > 0 && (e.anisotropyVector.value.set(t.anisotropy * Math.cos(t.anisotropyRotation), t.anisotropy * Math.sin(t.anisotropyRotation)), t.anisotropyMap && (e.anisotropyMap.value = t.anisotropyMap, n(t.anisotropyMap, e.anisotropyMapTransform)));
                            e.specularIntensity.value = t.specularIntensity, e.specularColor.value.copy(t.specularColor), t.specularColorMap && (e.specularColorMap.value = t.specularColorMap, n(t.specularColorMap, e.specularColorMapTransform));
                            t.specularIntensityMap && (e.specularIntensityMap.value = t.specularIntensityMap, n(t.specularIntensityMap, e.specularIntensityMapTransform))
                        }(e, i, s)) : i.isMeshMatcapMaterial ? (r(e, i), function (e, t) {
                            t.matcap && (e.matcap.value = t.matcap)
                        }(e, i)) : i.isMeshDepthMaterial ? r(e, i) : i.isMeshDistanceMaterial ? (r(e, i), function (e, n) {
                            var r = t.get(n).light;
                            e.referencePosition.value.setFromMatrixPosition(r.matrixWorld), e.nearDistance.value = r.shadow.camera.near, e.farDistance.value = r.shadow.camera.far
                        }(e, i)) : i.isMeshNormalMaterial ? r(e, i) : i.isLineBasicMaterial ? (function (e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, t.map && (e.map.value = t.map, n(t.map, e.mapTransform))
                        }(e, i), i.isLineDashedMaterial && function (e, t) {
                            e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                        }(e, i)) : i.isPointsMaterial ? function (e, t, r, i) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.size.value = t.size * r, e.scale.value = .5 * i, t.map && (e.map.value = t.map, n(t.map, e.uvTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, i, a, o) : i.isSpriteMaterial ? function (e, t) {
                            e.diffuse.value.copy(t.color), e.opacity.value = t.opacity, e.rotation.value = t.rotation, t.map && (e.map.value = t.map, n(t.map, e.mapTransform));
                            t.alphaMap && (e.alphaMap.value = t.alphaMap, n(t.alphaMap, e.alphaMapTransform));
                            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest)
                        }(e, i) : i.isShadowMaterial ? (e.color.value.copy(i.color), e.opacity.value = i.opacity) : i.isShaderMaterial && (i.uniformsNeedUpdate = !1)
                    }
                }
            }

            function Xo(e, t, n, r) {
                var i = {},
                    a = {},
                    o = [],
                    s = n.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;

                function l(e, t, n) {
                    var r = e.value;
                    if (void 0 === n[t]) {
                        if ("number" == typeof r) n[t] = r;
                        else {
                            for (var i = Array.isArray(r) ? r : [r], a = [], o = 0; o < i.length; o++) a.push(i[o].clone());
                            n[t] = a
                        }
                        return !0
                    }
                    if ("number" == typeof r) {
                        if (n[t] !== r) return n[t] = r, !0
                    } else
                        for (var s = Array.isArray(n[t]) ? n[t] : [n[t]], l = Array.isArray(r) ? r : [r], u = 0; u < s.length; u++) {
                            var c = s[u];
                            if (!1 === c.equals(l[u])) return c.copy(l[u]), !0
                        }
                    return !1
                }

                function u(e) {
                    var t = {
                        boundary: 0,
                        storage: 0
                    };
                    return "number" == typeof e ? (t.boundary = 4, t.storage = 4) : e.isVector2 ? (t.boundary = 8, t.storage = 8) : e.isVector3 || e.isColor ? (t.boundary = 16, t.storage = 12) : e.isVector4 ? (t.boundary = 16, t.storage = 16) : e.isMatrix3 ? (t.boundary = 48, t.storage = 48) : e.isMatrix4 ? (t.boundary = 64, t.storage = 64) : e.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", e), t
                }

                function c(t) {
                    var n = t.target;
                    n.removeEventListener("dispose", c);
                    var r = o.indexOf(n.__bindingPointIndex);
                    o.splice(r, 1), e.deleteBuffer(i[n.id]), delete i[n.id], delete a[n.id]
                }
                return {
                    bind: function (e, t) {
                        var n = t.program;
                        r.uniformBlockBinding(e, n)
                    },
                    update: function (n, h) {
                        var d = i[n.id];
                        void 0 === d && (! function (e) {
                            for (var t = e.uniforms, n = 0, r = 16, i = 0, a = 0, o = t.length; a < o; a++) {
                                for (var s = t[a], l = {
                                        boundary: 0,
                                        storage: 0
                                    }, c = Array.isArray(s.value) ? s.value : [s.value], h = 0, d = c.length; h < d; h++) {
                                    var f = u(c[h]);
                                    l.boundary += f.boundary, l.storage += f.storage
                                }
                                if (s.__data = new Float32Array(l.storage / Float32Array.BYTES_PER_ELEMENT), s.__offset = n, a > 0) 0 !== (i = n % r) && r - i - l.boundary < 0 && (n += r - i, s.__offset = n);
                                n += l.storage
                            }(i = n % r) > 0 && (n += r - i);
                            e.__size = n, e.__cache = {}
                        }(n), d = function (t) {
                            var n = function () {
                                for (var e = 0; e < s; e++)
                                    if (-1 === o.indexOf(e)) return o.push(e), e;
                                return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
                            }();
                            t.__bindingPointIndex = n;
                            var r = e.createBuffer(),
                                i = t.__size,
                                a = t.usage;
                            return e.bindBuffer(e.UNIFORM_BUFFER, r), e.bufferData(e.UNIFORM_BUFFER, i, a), e.bindBuffer(e.UNIFORM_BUFFER, null), e.bindBufferBase(e.UNIFORM_BUFFER, n, r), r
                        }(n), i[n.id] = d, n.addEventListener("dispose", c));
                        var f = h.program;
                        r.updateUBOMapping(n, f);
                        var p = t.render.frame;
                        a[n.id] !== p && (! function (t) {
                            var n = i[t.id],
                                r = t.uniforms,
                                a = t.__cache;
                            e.bindBuffer(e.UNIFORM_BUFFER, n);
                            for (var o = 0, s = r.length; o < s; o++) {
                                var c = r[o];
                                if (!0 === l(c, o, a)) {
                                    for (var h = c.__offset, d = Array.isArray(c.value) ? c.value : [c.value], f = 0, p = 0; p < d.length; p++) {
                                        var m = d[p],
                                            v = u(m);
                                        "number" == typeof m ? (c.__data[0] = m, e.bufferSubData(e.UNIFORM_BUFFER, h + f, c.__data)) : m.isMatrix3 ? (c.__data[0] = m.elements[0], c.__data[1] = m.elements[1], c.__data[2] = m.elements[2], c.__data[3] = m.elements[0], c.__data[4] = m.elements[3], c.__data[5] = m.elements[4], c.__data[6] = m.elements[5], c.__data[7] = m.elements[0], c.__data[8] = m.elements[6], c.__data[9] = m.elements[7], c.__data[10] = m.elements[8], c.__data[11] = m.elements[0]) : (m.toArray(c.__data, f), f += v.storage / Float32Array.BYTES_PER_ELEMENT)
                                    }
                                    e.bufferSubData(e.UNIFORM_BUFFER, h, c.__data)
                                }
                            }
                            e.bindBuffer(e.UNIFORM_BUFFER, null)
                        }(n), a[n.id] = p)
                    },
                    dispose: function () {
                        for (var t in i) e.deleteBuffer(i[t]);
                        o = [], i = {}, a = {}
                    }
                }
            }

            function qo() {
                var e = Et("canvas");
                return e.style.display = "block", e
            }
            var Yo = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                        i(this, e);
                        var n, r = t.canvas,
                            a = void 0 === r ? qo() : r,
                            o = t.context,
                            s = void 0 === o ? null : o,
                            l = t.depth,
                            u = void 0 === l || l,
                            c = t.stencil,
                            h = void 0 === c || c,
                            d = t.alpha,
                            f = void 0 !== d && d,
                            p = t.antialias,
                            m = void 0 !== p && p,
                            v = t.premultipliedAlpha,
                            g = void 0 === v || v,
                            _ = t.preserveDrawingBuffer,
                            y = void 0 !== _ && _,
                            x = t.powerPreference,
                            M = void 0 === x ? "default" : x,
                            S = t.failIfMajorPerformanceCaveat,
                            E = void 0 !== S && S;
                        this.isWebGLRenderer = !0, n = null !== s ? s.getContextAttributes().alpha : f;
                        var T = new Uint32Array(4),
                            b = new Int32Array(4),
                            A = null,
                            w = null,
                            C = [],
                            L = [];
                        this.domElement = a, this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputColorSpace = Ke, this._useLegacyLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
                        var P = this,
                            k = !1,
                            I = 0,
                            U = 0,
                            D = null,
                            N = -1,
                            O = null,
                            F = new zt,
                            B = new zt,
                            z = null,
                            H = new fr(0),
                            G = 0,
                            V = a.width,
                            W = a.height,
                            j = 1,
                            X = null,
                            q = null,
                            Y = new zt(0, 0, V, W),
                            K = new zt(0, 0, V, W),
                            $ = !1,
                            se = new fi,
                            le = !1,
                            de = !1,
                            fe = null,
                            pe = new En,
                            me = new yt,
                            ve = new Xt,
                            ge = {
                                background: null,
                                fog: null,
                                environment: null,
                                overrideMaterial: null,
                                isScene: !0
                            };

                        function _e() {
                            return null === D ? j : 1
                        }
                        var ye, xe, Me, Se, Ee, Te, be, Ae, we, Re, Ce, Le, Pe, ke, Ie, Ue, De, Ne, Oe, Fe, Be, ze, He, Ge, Ve = s;

                        function We(e, t) {
                            for (var n = 0; n < e.length; n++) {
                                var r = e[n],
                                    i = a.getContext(r, t);
                                if (null !== i) return i
                            }
                            return null
                        }
                        try {
                            var je = {
                                alpha: !0,
                                depth: u,
                                stencil: h,
                                antialias: m,
                                premultipliedAlpha: g,
                                preserveDrawingBuffer: y,
                                powerPreference: M,
                                failIfMajorPerformanceCaveat: E
                            };
                            if ("setAttribute" in a && a.setAttribute("data-engine", "three.js r".concat(R)), a.addEventListener("webglcontextlost", Je, !1), a.addEventListener("webglcontextrestored", Qe, !1), a.addEventListener("webglcontextcreationerror", $e, !1), null === Ve) {
                                var Xe = ["webgl2", "webgl", "experimental-webgl"];
                                if (!0 === P.isWebGL1Renderer && Xe.shift(), null === (Ve = We(Xe, je))) throw We(Xe) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
                            }
                            "undefined" != typeof WebGLRenderingContext && Ve instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), void 0 === Ve.getShaderPrecisionFormat && (Ve.getShaderPrecisionFormat = function () {
                                return {
                                    rangeMin: 1,
                                    rangeMax: 1,
                                    precision: 1
                                }
                            })
                        } catch (e) {
                            throw console.error("THREE.WebGLRenderer: " + e.message), e
                        }

                        function qe() {
                            ye = new Gi(Ve), xe = new Ti(Ve, ye, t), ye.init(xe), ze = new Fo(Ve, ye, xe), Me = new No(Ve, ye, xe), Se = new ji(Ve), Ee = new So, Te = new Oo(Ve, ye, Me, Ee, xe, ze, Se), be = new Ai(P), Ae = new Hi(P), we = new mi(Ve, xe), He = new Si(Ve, ye, we, xe), Re = new Vi(Ve, we, Se, He), Ce = new Ki(Ve, Re, we, Se), Oe = new Yi(Ve, xe, Te), Ue = new bi(Ee), Le = new Mo(P, be, Ae, ye, xe, He, Ue), Pe = new jo(P, Ee), ke = new Ao, Ie = new ko(ye, xe), Ne = new Mi(P, be, Ae, Me, Ce, n, g), De = new Do(P, Ce, xe), Ge = new Xo(Ve, Se, xe, Me), Fe = new Ei(Ve, ye, Se, xe), Be = new Wi(Ve, ye, Se, xe), Se.programs = Le.programs, P.capabilities = xe, P.extensions = ye, P.properties = Ee, P.renderLists = ke, P.shadowMap = De, P.state = Me, P.info = Se
                        }
                        qe();
                        var Ye = new Wo(P, Ve);

                        function Je(e) {
                            e.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), k = !0
                        }

                        function Qe() {
                            console.log("THREE.WebGLRenderer: Context Restored."), k = !1;
                            var e = Se.autoReset,
                                t = De.enabled,
                                n = De.autoUpdate,
                                r = De.needsUpdate,
                                i = De.type;
                            qe(), Se.autoReset = e, De.enabled = t, De.autoUpdate = n, De.needsUpdate = r, De.type = i
                        }

                        function $e(e) {
                            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", e.statusMessage)
                        }

                        function et(e) {
                            var t = e.target;
                            t.removeEventListener("dispose", et), tt(t)
                        }

                        function tt(e) {
                            nt(e), Ee.remove(e)
                        }

                        function nt(e) {
                            var t = Ee.get(e).programs;
                            void 0 !== t && (t.forEach((function (e) {
                                Le.releaseProgram(e)
                            })), e.isShaderMaterial && Le.releaseShaderCache(e))
                        }
                        this.xr = Ye, this.getContext = function () {
                            return Ve
                        }, this.getContextAttributes = function () {
                            return Ve.getContextAttributes()
                        }, this.forceContextLoss = function () {
                            var e = ye.get("WEBGL_lose_context");
                            e && e.loseContext()
                        }, this.forceContextRestore = function () {
                            var e = ye.get("WEBGL_lose_context");
                            e && e.restoreContext()
                        }, this.getPixelRatio = function () {
                            return j
                        }, this.setPixelRatio = function (e) {
                            void 0 !== e && (j = e, this.setSize(V, W, !1))
                        }, this.getSize = function (e) {
                            return e.set(V, W)
                        }, this.setSize = function (e, t) {
                            var n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                            Ye.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (V = e, W = t, a.width = Math.floor(e * j), a.height = Math.floor(t * j), !0 === n && (a.style.width = e + "px", a.style.height = t + "px"), this.setViewport(0, 0, e, t))
                        }, this.getDrawingBufferSize = function (e) {
                            return e.set(V * j, W * j).floor()
                        }, this.setDrawingBufferSize = function (e, t, n) {
                            V = e, W = t, j = n, a.width = Math.floor(e * n), a.height = Math.floor(t * n), this.setViewport(0, 0, e, t)
                        }, this.getCurrentViewport = function (e) {
                            return e.copy(F)
                        }, this.getViewport = function (e) {
                            return e.copy(Y)
                        }, this.setViewport = function (e, t, n, r) {
                            e.isVector4 ? Y.set(e.x, e.y, e.z, e.w) : Y.set(e, t, n, r), Me.viewport(F.copy(Y).multiplyScalar(j).floor())
                        }, this.getScissor = function (e) {
                            return e.copy(K)
                        }, this.setScissor = function (e, t, n, r) {
                            e.isVector4 ? K.set(e.x, e.y, e.z, e.w) : K.set(e, t, n, r), Me.scissor(B.copy(K).multiplyScalar(j).floor())
                        }, this.getScissorTest = function () {
                            return $
                        }, this.setScissorTest = function (e) {
                            Me.setScissorTest($ = e)
                        }, this.setOpaqueSort = function (e) {
                            X = e
                        }, this.setTransparentSort = function (e) {
                            q = e
                        }, this.getClearColor = function (e) {
                            return e.copy(Ne.getClearColor())
                        }, this.setClearColor = function () {
                            Ne.setClearColor.apply(Ne, arguments)
                        }, this.getClearAlpha = function () {
                            return Ne.getClearAlpha()
                        }, this.setClearAlpha = function () {
                            Ne.setClearAlpha.apply(Ne, arguments)
                        }, this.clear = function () {
                            var e = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                r = 0;
                            if (e) {
                                var i = !1;
                                if (null !== D) {
                                    var a = D.texture.format;
                                    i = a === he || a === ce || a === ue
                                }
                                if (i) {
                                    var o = D.texture.type,
                                        s = o === J || o === ee || o === Q || o === ae || o === re || o === ie,
                                        l = Ne.getClearColor(),
                                        u = Ne.getClearAlpha(),
                                        c = l.r,
                                        h = l.g,
                                        d = l.b;
                                    s ? (T[0] = c, T[1] = h, T[2] = d, T[3] = u, Ve.clearBufferuiv(Ve.COLOR, 0, T)) : (b[0] = c, b[1] = h, b[2] = d, b[3] = u, Ve.clearBufferiv(Ve.COLOR, 0, b))
                                } else r |= Ve.COLOR_BUFFER_BIT
                            }
                            t && (r |= Ve.DEPTH_BUFFER_BIT), n && (r |= Ve.STENCIL_BUFFER_BIT), Ve.clear(r)
                        }, this.clearColor = function () {
                            this.clear(!0, !1, !1)
                        }, this.clearDepth = function () {
                            this.clear(!1, !0, !1)
                        }, this.clearStencil = function () {
                            this.clear(!1, !1, !0)
                        }, this.dispose = function () {
                            a.removeEventListener("webglcontextlost", Je, !1), a.removeEventListener("webglcontextrestored", Qe, !1), a.removeEventListener("webglcontextcreationerror", $e, !1), ke.dispose(), Ie.dispose(), Ee.dispose(), be.dispose(), Ae.dispose(), Ce.dispose(), He.dispose(), Ge.dispose(), Le.dispose(), Ye.dispose(), Ye.removeEventListener("sessionstart", at), Ye.removeEventListener("sessionend", ot), fe && (fe.dispose(), fe = null), st.stop()
                        }, this.renderBufferDirect = function (e, t, n, r, i, a) {
                            null === t && (t = ge);
                            var o = i.isMesh && i.matrixWorld.determinant() < 0,
                                s = vt(e, t, n, r, i);
                            Me.setMaterial(r, o);
                            var l = n.index,
                                u = 1;
                            if (!0 === r.wireframe) {
                                if (void 0 === (l = Re.getWireframeAttribute(n))) return;
                                u = 2
                            }
                            var c = n.drawRange,
                                h = n.attributes.position,
                                d = c.start * u,
                                f = (c.start + c.count) * u;
                            null !== a && (d = Math.max(d, a.start * u), f = Math.min(f, (a.start + a.count) * u)), null !== l ? (d = Math.max(d, 0), f = Math.min(f, l.count)) : null != h && (d = Math.max(d, 0), f = Math.min(f, h.count));
                            var p = f - d;
                            if (!(p < 0 || p === 1 / 0)) {
                                var m;
                                He.setup(i, r, s, n, l);
                                var v = Fe;
                                if (null !== l && (m = we.get(l), (v = Be).setIndex(m)), i.isMesh) !0 === r.wireframe ? (Me.setLineWidth(r.wireframeLinewidth * _e()), v.setMode(Ve.LINES)) : v.setMode(Ve.TRIANGLES);
                                else if (i.isLine) {
                                    var g = r.linewidth;
                                    void 0 === g && (g = 1), Me.setLineWidth(g * _e()), i.isLineSegments ? v.setMode(Ve.LINES) : i.isLineLoop ? v.setMode(Ve.LINE_LOOP) : v.setMode(Ve.LINE_STRIP)
                                } else i.isPoints ? v.setMode(Ve.POINTS) : i.isSprite && v.setMode(Ve.TRIANGLES);
                                if (i.isInstancedMesh) v.renderInstances(d, p, i.count);
                                else if (n.isInstancedBufferGeometry) {
                                    var _ = void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                                        y = Math.min(n.instanceCount, _);
                                    v.renderInstances(d, p, y)
                                } else v.render(d, p)
                            }
                        }, this.compile = function (e, t) {
                            function n(e, t, n) {
                                !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass ? (e.side = 1, e.needsUpdate = !0, ft(e, t, n), e.side = 0, e.needsUpdate = !0, ft(e, t, n), e.side = 2) : ft(e, t, n)
                            }(w = Ie.get(e)).init(), L.push(w), e.traverseVisible((function (e) {
                                e.isLight && e.layers.test(t.layers) && (w.pushLight(e), e.castShadow && w.pushShadow(e))
                            })), w.setupLights(P._useLegacyLights), e.traverse((function (t) {
                                var r = t.material;
                                if (r)
                                    if (Array.isArray(r))
                                        for (var i = 0; i < r.length; i++) {
                                            n(r[i], e, t)
                                        } else n(r, e, t)
                            })), L.pop(), w = null
                        };
                        var rt = null;

                        function it(e) {
                            rt && rt(e)
                        }

                        function at() {
                            st.stop()
                        }

                        function ot() {
                            st.start()
                        }
                        var st = new pi;

                        function lt(e, t, n, r) {
                            if (!1 !== e.visible) {
                                if (e.layers.test(t.layers))
                                    if (e.isGroup) n = e.renderOrder;
                                    else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
                                else if (e.isLight) w.pushLight(e), e.castShadow && w.pushShadow(e);
                                else if (e.isSprite) {
                                    if (!e.frustumCulled || se.intersectsSprite(e)) {
                                        r && ve.setFromMatrixPosition(e.matrixWorld).applyMatrix4(pe);
                                        var i = Ce.update(e),
                                            a = e.material;
                                        a.visible && A.push(e, i, a, n, ve.z, null)
                                    }
                                } else if ((e.isMesh || e.isLine || e.isPoints) && (!e.frustumCulled || se.intersectsObject(e))) {
                                    var o = Ce.update(e),
                                        s = e.material;
                                    if (r && (void 0 !== e.boundingSphere ? (null === e.boundingSphere && e.computeBoundingSphere(), ve.copy(e.boundingSphere.center)) : (null === o.boundingSphere && o.computeBoundingSphere(), ve.copy(o.boundingSphere.center)), ve.applyMatrix4(e.matrixWorld).applyMatrix4(pe)), Array.isArray(s))
                                        for (var l = o.groups, u = 0, c = l.length; u < c; u++) {
                                            var h = l[u],
                                                d = s[h.materialIndex];
                                            d && d.visible && A.push(e, o, d, n, ve.z, h)
                                        } else s.visible && A.push(e, o, s, n, ve.z, null)
                                }
                                for (var f = e.children, p = 0, m = f.length; p < m; p++) lt(f[p], t, n, r)
                            }
                        }

                        function ut(e, t, n, r) {
                            var i = e.opaque,
                                a = e.transmissive,
                                o = e.transparent;
                            w.setupLightsView(n), !0 === le && Ue.setGlobalState(P.clippingPlanes, n), a.length > 0 && ct(i, a, t, n), r && Me.viewport(F.copy(r)), i.length > 0 && ht(i, t, n), a.length > 0 && ht(a, t, n), o.length > 0 && ht(o, t, n), Me.buffers.depth.setTest(!0), Me.buffers.depth.setMask(!0), Me.buffers.color.setMask(!0), Me.setPolygonOffset(!1)
                        }

                        function ct(e, t, n, r) {
                            var i = xe.isWebGL2;
                            null === fe && (fe = new Gt(1, 1, {
                                generateMipmaps: !0,
                                type: ye.has("EXT_color_buffer_half_float") ? ne : J,
                                minFilter: Z,
                                samples: i ? 4 : 0
                            })), P.getDrawingBufferSize(me), i ? fe.setSize(me.x, me.y) : fe.setSize(mt(me.x), mt(me.y));
                            var a = P.getRenderTarget();
                            P.setRenderTarget(fe), P.getClearColor(H), (G = P.getClearAlpha()) < 1 && P.setClearColor(16777215, .5), P.clear();
                            var o = P.toneMapping;
                            P.toneMapping = 0, ht(e, n, r), Te.updateMultisampleRenderTarget(fe), Te.updateRenderTargetMipmap(fe);
                            for (var s = !1, l = 0, u = t.length; l < u; l++) {
                                var c = t[l],
                                    h = c.object,
                                    d = c.geometry,
                                    f = c.material,
                                    p = c.group;
                                if (2 === f.side && h.layers.test(r.layers)) {
                                    var m = f.side;
                                    f.side = 1, f.needsUpdate = !0, dt(h, n, r, d, f, p), f.side = m, f.needsUpdate = !0, s = !0
                                }
                            }!0 === s && (Te.updateMultisampleRenderTarget(fe), Te.updateRenderTargetMipmap(fe)), P.setRenderTarget(a), P.setClearColor(H, G), P.toneMapping = o
                        }

                        function ht(e, t, n) {
                            for (var r = !0 === t.isScene ? t.overrideMaterial : null, i = 0, a = e.length; i < a; i++) {
                                var o = e[i],
                                    s = o.object,
                                    l = o.geometry,
                                    u = null === r ? o.material : r,
                                    c = o.group;
                                s.layers.test(n.layers) && dt(s, t, n, l, u, c)
                            }
                        }

                        function dt(e, t, n, r, i, a) {
                            e.onBeforeRender(P, t, n, r, i, a), e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), e.normalMatrix.getNormalMatrix(e.modelViewMatrix), i.onBeforeRender(P, t, n, r, e, a), !0 === i.transparent && 2 === i.side && !1 === i.forceSinglePass ? (i.side = 1, i.needsUpdate = !0, P.renderBufferDirect(n, t, r, i, e, a), i.side = 0, i.needsUpdate = !0, P.renderBufferDirect(n, t, r, i, e, a), i.side = 2) : P.renderBufferDirect(n, t, r, i, e, a), e.onAfterRender(P, t, n, r, i, a)
                        }

                        function ft(e, t, n) {
                            !0 !== t.isScene && (t = ge);
                            var r = Ee.get(e),
                                i = w.state.lights,
                                a = w.state.shadowsArray,
                                o = i.state.version,
                                s = Le.getParameters(e, i.state, a, t, n),
                                l = Le.getProgramCacheKey(s),
                                u = r.programs;
                            r.environment = e.isMeshStandardMaterial ? t.environment : null, r.fog = t.fog, r.envMap = (e.isMeshStandardMaterial ? Ae : be).get(e.envMap || r.environment), void 0 === u && (e.addEventListener("dispose", et), u = new Map, r.programs = u);
                            var c = u.get(l);
                            if (void 0 !== c) {
                                if (r.currentProgram === c && r.lightsStateVersion === o) return pt(e, s), c
                            } else s.uniforms = Le.getUniforms(e), e.onBuild(n, s, P), e.onBeforeCompile(s, P), c = Le.acquireProgram(s, l), u.set(l, c), r.uniforms = s.uniforms;
                            var h = r.uniforms;
                            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = Ue.uniform), pt(e, s), r.needsLights = _t(e), r.lightsStateVersion = o, r.needsLights && (h.ambientLightColor.value = i.state.ambient, h.lightProbe.value = i.state.probe, h.directionalLights.value = i.state.directional, h.directionalLightShadows.value = i.state.directionalShadow, h.spotLights.value = i.state.spot, h.spotLightShadows.value = i.state.spotShadow, h.rectAreaLights.value = i.state.rectArea, h.ltc_1.value = i.state.rectAreaLTC1, h.ltc_2.value = i.state.rectAreaLTC2, h.pointLights.value = i.state.point, h.pointLightShadows.value = i.state.pointShadow, h.hemisphereLights.value = i.state.hemi, h.directionalShadowMap.value = i.state.directionalShadowMap, h.directionalShadowMatrix.value = i.state.directionalShadowMatrix, h.spotShadowMap.value = i.state.spotShadowMap, h.spotLightMatrix.value = i.state.spotLightMatrix, h.spotLightMap.value = i.state.spotLightMap, h.pointShadowMap.value = i.state.pointShadowMap, h.pointShadowMatrix.value = i.state.pointShadowMatrix);
                            var d = c.getUniforms(),
                                f = $a.seqWithValue(d.seq, h);
                            return r.currentProgram = c, r.uniformsList = f, c
                        }

                        function pt(e, t) {
                            var n = Ee.get(e);
                            n.outputColorSpace = t.outputColorSpace, n.instancing = t.instancing, n.instancingColor = t.instancingColor, n.skinning = t.skinning, n.morphTargets = t.morphTargets, n.morphNormals = t.morphNormals, n.morphColors = t.morphColors, n.morphTargetsCount = t.morphTargetsCount, n.numClippingPlanes = t.numClippingPlanes, n.numIntersection = t.numClipIntersection, n.vertexAlphas = t.vertexAlphas, n.vertexTangents = t.vertexTangents, n.toneMapping = t.toneMapping
                        }

                        function vt(e, t, n, r, i) {
                            !0 !== t.isScene && (t = ge), Te.resetTextureUnits();
                            var a = t.fog,
                                o = r.isMeshStandardMaterial ? t.environment : null,
                                s = null === D ? P.outputColorSpace : !0 === D.isXRRenderTarget ? D.texture.colorSpace : Ze,
                                l = (r.isMeshStandardMaterial ? Ae : be).get(r.envMap || o),
                                u = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
                                c = !!n.attributes.tangent && (!!r.normalMap || r.anisotropy > 0),
                                h = !!n.morphAttributes.position,
                                d = !!n.morphAttributes.normal,
                                f = !!n.morphAttributes.color,
                                p = 0;
                            r.toneMapped && (null !== D && !0 !== D.isXRRenderTarget || (p = P.toneMapping));
                            var m = n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color,
                                v = void 0 !== m ? m.length : 0,
                                g = Ee.get(r),
                                _ = w.state.lights;
                            if (!0 === le && (!0 === de || e !== O)) {
                                var y = e === O && r.id === N;
                                Ue.setState(r, e, y)
                            }
                            var x = !1;
                            r.version === g.__version ? g.needsLights && g.lightsStateVersion !== _.state.version || g.outputColorSpace !== s || i.isInstancedMesh && !1 === g.instancing ? x = !0 : i.isInstancedMesh || !0 !== g.instancing ? i.isSkinnedMesh && !1 === g.skinning ? x = !0 : i.isSkinnedMesh || !0 !== g.skinning ? i.isInstancedMesh && !0 === g.instancingColor && null === i.instanceColor || i.isInstancedMesh && !1 === g.instancingColor && null !== i.instanceColor || g.envMap !== l || !0 === r.fog && g.fog !== a ? x = !0 : void 0 === g.numClippingPlanes || g.numClippingPlanes === Ue.numPlanes && g.numIntersection === Ue.numIntersection ? (g.vertexAlphas !== u || g.vertexTangents !== c || g.morphTargets !== h || g.morphNormals !== d || g.morphColors !== f || g.toneMapping !== p || !0 === xe.isWebGL2 && g.morphTargetsCount !== v) && (x = !0) : x = !0 : x = !0 : x = !0 : (x = !0, g.__version = r.version);
                            var M = g.currentProgram;
                            !0 === x && (M = ft(r, t, i));
                            var S = !1,
                                E = !1,
                                T = !1,
                                b = M.getUniforms(),
                                A = g.uniforms;
                            if (Me.useProgram(M.program) && (S = !0, E = !0, T = !0), r.id !== N && (N = r.id, E = !0), S || O !== e) {
                                if (b.setValue(Ve, "projectionMatrix", e.projectionMatrix), xe.logarithmicDepthBuffer && b.setValue(Ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)), O !== e && (O = e, E = !0, T = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
                                    var R = b.map.cameraPosition;
                                    void 0 !== R && R.setValue(Ve, ve.setFromMatrixPosition(e.matrixWorld))
                                }(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && b.setValue(Ve, "isOrthographic", !0 === e.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || i.isSkinnedMesh) && b.setValue(Ve, "viewMatrix", e.matrixWorldInverse)
                            }
                            if (i.isSkinnedMesh) {
                                b.setOptional(Ve, i, "bindMatrix"), b.setOptional(Ve, i, "bindMatrixInverse");
                                var C = i.skeleton;
                                C && (xe.floatVertexTextures ? (null === C.boneTexture && C.computeBoneTexture(), b.setValue(Ve, "boneTexture", C.boneTexture, Te), b.setValue(Ve, "boneTextureSize", C.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))
                            }
                            var L = n.morphAttributes;
                            if ((void 0 !== L.position || void 0 !== L.normal || void 0 !== L.color && !0 === xe.isWebGL2) && Oe.update(i, n, M), (E || g.receiveShadow !== i.receiveShadow) && (g.receiveShadow = i.receiveShadow, b.setValue(Ve, "receiveShadow", i.receiveShadow)), r.isMeshGouraudMaterial && null !== r.envMap && (A.envMap.value = l, A.flipEnvMap.value = l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1), E && (b.setValue(Ve, "toneMappingExposure", P.toneMappingExposure), g.needsLights && gt(A, T), a && !0 === r.fog && Pe.refreshFogUniforms(A, a), Pe.refreshMaterialUniforms(A, r, j, W, fe), $a.upload(Ve, g.uniformsList, A, Te)), r.isShaderMaterial && !0 === r.uniformsNeedUpdate && ($a.upload(Ve, g.uniformsList, A, Te), r.uniformsNeedUpdate = !1), r.isSpriteMaterial && b.setValue(Ve, "center", i.center), b.setValue(Ve, "modelViewMatrix", i.modelViewMatrix), b.setValue(Ve, "normalMatrix", i.normalMatrix), b.setValue(Ve, "modelMatrix", i.matrixWorld), r.isShaderMaterial || r.isRawShaderMaterial)
                                for (var k = r.uniformsGroups, I = 0, U = k.length; I < U; I++)
                                    if (xe.isWebGL2) {
                                        var F = k[I];
                                        Ge.update(F, M), Ge.bind(F, M)
                                    } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
                            return M
                        }

                        function gt(e, t) {
                            e.ambientLightColor.needsUpdate = t, e.lightProbe.needsUpdate = t, e.directionalLights.needsUpdate = t, e.directionalLightShadows.needsUpdate = t, e.pointLights.needsUpdate = t, e.pointLightShadows.needsUpdate = t, e.spotLights.needsUpdate = t, e.spotLightShadows.needsUpdate = t, e.rectAreaLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                        }

                        function _t(e) {
                            return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
                        }
                        st.setAnimationLoop(it), "undefined" != typeof self && st.setContext(self), this.setAnimationLoop = function (e) {
                            rt = e, Ye.setAnimationLoop(e), null === e ? st.stop() : st.start()
                        }, Ye.addEventListener("sessionstart", at), Ye.addEventListener("sessionend", ot), this.render = function (e, t) {
                            if (void 0 === t || !0 === t.isCamera) {
                                if (!0 !== k) {
                                    !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(), null === t.parent && !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(), !0 === Ye.enabled && !0 === Ye.isPresenting && (!0 === Ye.cameraAutoUpdate && Ye.updateCamera(t), t = Ye.getCamera()), !0 === e.isScene && e.onBeforeRender(P, e, t, D), (w = Ie.get(e, L.length)).init(), L.push(w), pe.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), se.setFromProjectionMatrix(pe), de = this.localClippingEnabled, le = Ue.init(this.clippingPlanes, de), (A = ke.get(e, C.length)).init(), C.push(A), lt(e, t, 0, P.sortObjects), A.finish(), !0 === P.sortObjects && A.sort(X, q), this.info.render.frame++, !0 === le && Ue.beginShadows();
                                    var n = w.state.shadowsArray;
                                    if (De.render(n, e, t), !0 === le && Ue.endShadows(), !0 === this.info.autoReset && this.info.reset(), Ne.render(A, e), w.setupLights(P._useLegacyLights), t.isArrayCamera)
                                        for (var r = t.cameras, i = 0, a = r.length; i < a; i++) {
                                            var o = r[i];
                                            ut(A, e, o, o.viewport)
                                        } else ut(A, e, t);
                                    null !== D && (Te.updateMultisampleRenderTarget(D), Te.updateRenderTargetMipmap(D)), !0 === e.isScene && e.onAfterRender(P, e, t), He.resetDefaultState(), N = -1, O = null, L.pop(), w = L.length > 0 ? L[L.length - 1] : null, C.pop(), A = C.length > 0 ? C[C.length - 1] : null
                                }
                            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                        }, this.getActiveCubeFace = function () {
                            return I
                        }, this.getActiveMipmapLevel = function () {
                            return U
                        }, this.getRenderTarget = function () {
                            return D
                        }, this.setRenderTargetTextures = function (e, t, n) {
                            Ee.get(e.texture).__webglTexture = t, Ee.get(e.depthTexture).__webglTexture = n;
                            var r = Ee.get(e);
                            r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || !0 === ye.has("WEBGL_multisampled_render_to_texture") && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), r.__useRenderToTexture = !1))
                        }, this.setRenderTargetFramebuffer = function (e, t) {
                            var n = Ee.get(e);
                            n.__webglFramebuffer = t, n.__useDefaultFramebuffer = void 0 === t
                        }, this.setRenderTarget = function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                            D = e, I = t, U = n;
                            var r = !0,
                                i = null,
                                a = !1,
                                o = !1;
                            if (e) {
                                var s = Ee.get(e);
                                void 0 !== s.__useDefaultFramebuffer ? (Me.bindFramebuffer(Ve.FRAMEBUFFER, null), r = !1) : void 0 === s.__webglFramebuffer ? Te.setupRenderTarget(e) : s.__hasExternalTextures && Te.rebindTextures(e, Ee.get(e.texture).__webglTexture, Ee.get(e.depthTexture).__webglTexture);
                                var l = e.texture;
                                (l.isData3DTexture || l.isDataArrayTexture || l.isCompressedArrayTexture) && (o = !0);
                                var u = Ee.get(e).__webglFramebuffer;
                                e.isWebGLCubeRenderTarget ? (i = Array.isArray(u[t]) ? u[t][n] : u[t], a = !0) : i = xe.isWebGL2 && e.samples > 0 && !1 === Te.useMultisampledRTT(e) ? Ee.get(e).__webglMultisampledFramebuffer : Array.isArray(u) ? u[n] : u, F.copy(e.viewport), B.copy(e.scissor), z = e.scissorTest
                            } else F.copy(Y).multiplyScalar(j).floor(), B.copy(K).multiplyScalar(j).floor(), z = $;
                            var c = Me.bindFramebuffer(Ve.FRAMEBUFFER, i);
                            if (c && xe.drawBuffers && r && Me.drawBuffers(e, i), Me.viewport(F), Me.scissor(B), Me.setScissorTest(z), a) {
                                var h = Ee.get(e.texture);
                                Ve.framebufferTexture2D(Ve.FRAMEBUFFER, Ve.COLOR_ATTACHMENT0, Ve.TEXTURE_CUBE_MAP_POSITIVE_X + t, h.__webglTexture, n)
                            } else if (o) {
                                var d = Ee.get(e.texture),
                                    f = t || 0;
                                Ve.framebufferTextureLayer(Ve.FRAMEBUFFER, Ve.COLOR_ATTACHMENT0, d.__webglTexture, n || 0, f)
                            }
                            N = -1
                        }, this.readRenderTargetPixels = function (e, t, n, r, i, a, o) {
                            if (e && e.isWebGLRenderTarget) {
                                var s = Ee.get(e).__webglFramebuffer;
                                if (e.isWebGLCubeRenderTarget && void 0 !== o && (s = s[o]), s) {
                                    Me.bindFramebuffer(Ve.FRAMEBUFFER, s);
                                    try {
                                        var l = e.texture,
                                            u = l.format,
                                            c = l.type;
                                        if (u !== oe && ze.convert(u) !== Ve.getParameter(Ve.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                        var h = c === ne && (ye.has("EXT_color_buffer_half_float") || xe.isWebGL2 && ye.has("EXT_color_buffer_float"));
                                        if (!(c === J || ze.convert(c) === Ve.getParameter(Ve.IMPLEMENTATION_COLOR_READ_TYPE) || c === te && (xe.isWebGL2 || ye.has("OES_texture_float") || ye.has("WEBGL_color_buffer_float")) || h)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                        t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && Ve.readPixels(t, n, r, i, ze.convert(u), ze.convert(c), a)
                                    } finally {
                                        var d = null !== D ? Ee.get(D).__webglFramebuffer : null;
                                        Me.bindFramebuffer(Ve.FRAMEBUFFER, d)
                                    }
                                }
                            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                        }, this.copyFramebufferToTexture = function (e, t) {
                            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                r = Math.pow(2, -n),
                                i = Math.floor(t.image.width * r),
                                a = Math.floor(t.image.height * r);
                            Te.setTexture2D(t, 0), Ve.copyTexSubImage2D(Ve.TEXTURE_2D, n, 0, 0, e.x, e.y, i, a), Me.unbindTexture()
                        }, this.copyTextureToTexture = function (e, t, n) {
                            var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                i = t.image.width,
                                a = t.image.height,
                                o = ze.convert(n.format),
                                s = ze.convert(n.type);
                            Te.setTexture2D(n, 0), Ve.pixelStorei(Ve.UNPACK_FLIP_Y_WEBGL, n.flipY), Ve.pixelStorei(Ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha), Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, n.unpackAlignment), t.isDataTexture ? Ve.texSubImage2D(Ve.TEXTURE_2D, r, e.x, e.y, i, a, o, s, t.image.data) : t.isCompressedTexture ? Ve.compressedTexSubImage2D(Ve.TEXTURE_2D, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, o, t.mipmaps[0].data) : Ve.texSubImage2D(Ve.TEXTURE_2D, r, e.x, e.y, o, s, t.image), 0 === r && n.generateMipmaps && Ve.generateMipmap(Ve.TEXTURE_2D), Me.unbindTexture()
                        }, this.copyTextureToTexture3D = function (e, t, n, r) {
                            var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
                            if (P.isWebGL1Renderer) console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
                            else {
                                var a, o = e.max.x - e.min.x + 1,
                                    s = e.max.y - e.min.y + 1,
                                    l = e.max.z - e.min.z + 1,
                                    u = ze.convert(r.format),
                                    c = ze.convert(r.type);
                                if (r.isData3DTexture) Te.setTexture3D(r, 0), a = Ve.TEXTURE_3D;
                                else {
                                    if (!r.isDataArrayTexture) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                                    Te.setTexture2DArray(r, 0), a = Ve.TEXTURE_2D_ARRAY
                                }
                                Ve.pixelStorei(Ve.UNPACK_FLIP_Y_WEBGL, r.flipY), Ve.pixelStorei(Ve.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha), Ve.pixelStorei(Ve.UNPACK_ALIGNMENT, r.unpackAlignment);
                                var h = Ve.getParameter(Ve.UNPACK_ROW_LENGTH),
                                    d = Ve.getParameter(Ve.UNPACK_IMAGE_HEIGHT),
                                    f = Ve.getParameter(Ve.UNPACK_SKIP_PIXELS),
                                    p = Ve.getParameter(Ve.UNPACK_SKIP_ROWS),
                                    m = Ve.getParameter(Ve.UNPACK_SKIP_IMAGES),
                                    v = n.isCompressedTexture ? n.mipmaps[0] : n.image;
                                Ve.pixelStorei(Ve.UNPACK_ROW_LENGTH, v.width), Ve.pixelStorei(Ve.UNPACK_IMAGE_HEIGHT, v.height), Ve.pixelStorei(Ve.UNPACK_SKIP_PIXELS, e.min.x), Ve.pixelStorei(Ve.UNPACK_SKIP_ROWS, e.min.y), Ve.pixelStorei(Ve.UNPACK_SKIP_IMAGES, e.min.z), n.isDataTexture || n.isData3DTexture ? Ve.texSubImage3D(a, i, t.x, t.y, t.z, o, s, l, u, c, v.data) : n.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Ve.compressedTexSubImage3D(a, i, t.x, t.y, t.z, o, s, l, u, v.data)) : Ve.texSubImage3D(a, i, t.x, t.y, t.z, o, s, l, u, c, v), Ve.pixelStorei(Ve.UNPACK_ROW_LENGTH, h), Ve.pixelStorei(Ve.UNPACK_IMAGE_HEIGHT, d), Ve.pixelStorei(Ve.UNPACK_SKIP_PIXELS, f), Ve.pixelStorei(Ve.UNPACK_SKIP_ROWS, p), Ve.pixelStorei(Ve.UNPACK_SKIP_IMAGES, m), 0 === i && r.generateMipmaps && Ve.generateMipmap(a), Me.unbindTexture()
                            }
                        }, this.initTexture = function (e) {
                            e.isCubeTexture ? Te.setTextureCube(e, 0) : e.isData3DTexture ? Te.setTexture3D(e, 0) : e.isDataArrayTexture || e.isCompressedArrayTexture ? Te.setTexture2DArray(e, 0) : Te.setTexture2D(e, 0), Me.unbindTexture()
                        }, this.resetState = function () {
                            I = 0, U = 0, D = null, Me.reset(), He.reset()
                        }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: this
                        }))
                    }
                    return o(e, [{
                        key: "coordinateSystem",
                        get: function () {
                            return nt
                        }
                    }, {
                        key: "physicallyCorrectLights",
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), !this.useLegacyLights
                        },
                        set: function (e) {
                            console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."), this.useLegacyLights = !e
                        }
                    }, {
                        key: "outputEncoding",
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Ke ? qe : 3e3
                        },
                        set: function (e) {
                            console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === qe ? Ke : Ze
                        }
                    }, {
                        key: "useLegacyLights",
                        get: function () {
                            return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights
                        },
                        set: function (e) {
                            console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e
                        }
                    }]), e
                }(),
                Ko = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        return i(this, n), t.apply(this, arguments)
                    }
                    return o(n)
                }(Yo);
            Ko.prototype.isWebGL1Renderer = !0;
            var Zo = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isScene = !0, e.type = "Scene", e.background = null, e.environment = null, e.fog = null, e.backgroundBlurriness = 0, e.backgroundIntensity = 1, e.overrideMaterial = null, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                            detail: M(e)
                        })), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), null !== e.background && (this.background = e.background.clone()), null !== e.environment && (this.environment = e.environment.clone()), null !== e.fog && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            return null !== this.fog && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), 1 !== this.backgroundIntensity && (t.object.backgroundIntensity = this.backgroundIntensity), t
                        }
                    }]), n
                }(Yn),
                Jo = function () {
                    function e(t, n) {
                        i(this, e), this.isInterleavedBuffer = !0, this.array = t, this.stride = n, this.count = void 0 !== t ? t.length / n : 0, this.usage = $e, this.updateRange = {
                            offset: 0,
                            count: -1
                        }, this.version = 0, this.uuid = ut()
                    }
                    return o(e, [{
                        key: "onUploadCallback",
                        value: function () {}
                    }, {
                        key: "needsUpdate",
                        set: function (e) {
                            !0 === e && this.version++
                        }
                    }, {
                        key: "setUsage",
                        value: function (e) {
                            return this.usage = e, this
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
                        }
                    }, {
                        key: "copyAt",
                        value: function (e, t, n) {
                            e *= this.stride, n *= t.stride;
                            for (var r = 0, i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
                            return this
                        }
                    }, {
                        key: "set",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                            return this.array.set(e, t), this
                        }
                    }, {
                        key: "clone",
                        value: function (e) {
                            void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ut()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
                            var t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
                                n = new this.constructor(t, this.stride);
                            return n.setUsage(this.usage), n
                        }
                    }, {
                        key: "onUpload",
                        value: function (e) {
                            return this.onUploadCallback = e, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = ut()), void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
                                uuid: this.uuid,
                                buffer: this.array.buffer._uuid,
                                type: this.array.constructor.name,
                                stride: this.stride
                            }
                        }
                    }]), e
                }(),
                Qo = new Xt,
                $o = function () {
                    function e(t, n, r) {
                        var a = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
                        i(this, e), this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = n, this.offset = r, this.normalized = a
                    }
                    return o(e, [{
                        key: "count",
                        get: function () {
                            return this.data.count
                        }
                    }, {
                        key: "array",
                        get: function () {
                            return this.data.array
                        }
                    }, {
                        key: "needsUpdate",
                        set: function (e) {
                            this.data.needsUpdate = e
                        }
                    }, {
                        key: "applyMatrix4",
                        value: function (e) {
                            for (var t = 0, n = this.data.count; t < n; t++) Qo.fromBufferAttribute(this, t), Qo.applyMatrix4(e), this.setXYZ(t, Qo.x, Qo.y, Qo.z);
                            return this
                        }
                    }, {
                        key: "applyNormalMatrix",
                        value: function (e) {
                            for (var t = 0, n = this.count; t < n; t++) Qo.fromBufferAttribute(this, t), Qo.applyNormalMatrix(e), this.setXYZ(t, Qo.x, Qo.y, Qo.z);
                            return this
                        }
                    }, {
                        key: "transformDirection",
                        value: function (e) {
                            for (var t = 0, n = this.count; t < n; t++) Qo.fromBufferAttribute(this, t), Qo.transformDirection(e), this.setXYZ(t, Qo.x, Qo.y, Qo.z);
                            return this
                        }
                    }, {
                        key: "setX",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
                        }
                    }, {
                        key: "setY",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
                        }
                    }, {
                        key: "setZ",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
                        }
                    }, {
                        key: "setW",
                        value: function (e, t) {
                            return this.normalized && (t = gt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
                        }
                    }, {
                        key: "getX",
                        value: function (e) {
                            var t = this.data.array[e * this.data.stride + this.offset];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "getY",
                        value: function (e) {
                            var t = this.data.array[e * this.data.stride + this.offset + 1];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "getZ",
                        value: function (e) {
                            var t = this.data.array[e * this.data.stride + this.offset + 2];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "getW",
                        value: function (e) {
                            var t = this.data.array[e * this.data.stride + this.offset + 3];
                            return this.normalized && (t = vt(t, this.array)), t
                        }
                    }, {
                        key: "setXY",
                        value: function (e, t, n) {
                            return e = e * this.data.stride + this.offset, this.normalized && (t = gt(t, this.array), n = gt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
                        }
                    }, {
                        key: "setXYZ",
                        value: function (e, t, n, r) {
                            return e = e * this.data.stride + this.offset, this.normalized && (t = gt(t, this.array), n = gt(n, this.array), r = gt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this
                        }
                    }, {
                        key: "setXYZW",
                        value: function (e, t, n, r, i) {
                            return e = e * this.data.stride + this.offset, this.normalized && (t = gt(t, this.array), n = gt(n, this.array), r = gt(r, this.array), i = gt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = r, this.data.array[e + 3] = i, this
                        }
                    }, {
                        key: "clone",
                        value: function (t) {
                            if (void 0 === t) {
                                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
                                for (var n = [], r = 0; r < this.count; r++)
                                    for (var i = r * this.data.stride + this.offset, a = 0; a < this.itemSize; a++) n.push(this.data.array[i + a]);
                                return new _r(new this.array.constructor(n), this.itemSize, this.normalized)
                            }
                            return void 0 === t.interleavedBuffers && (t.interleavedBuffers = {}), void 0 === t.interleavedBuffers[this.data.uuid] && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new e(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            if (void 0 === e) {
                                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
                                for (var t = [], n = 0; n < this.count; n++)
                                    for (var r = n * this.data.stride + this.offset, i = 0; i < this.itemSize; i++) t.push(this.data.array[r + i]);
                                return {
                                    itemSize: this.itemSize,
                                    type: this.array.constructor.name,
                                    array: t,
                                    normalized: this.normalized
                                }
                            }
                            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}), void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                        }
                    }]), e
                }();
            var es = new Xt,
                ts = new zt,
                ns = new zt,
                rs = new Xt,
                is = new En,
                as = new Xt,
                os = new pn,
                ss = new En,
                ls = new Sn,
                us = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e, r)).isSkinnedMesh = !0, a.type = "SkinnedMesh", a.bindMode = "attached", a.bindMatrix = new En, a.bindMatrixInverse = new En, a.boundingBox = null, a.boundingSphere = null, a
                    }
                    return o(n, [{
                        key: "computeBoundingBox",
                        value: function () {
                            var e = this.geometry;
                            null === this.boundingBox && (this.boundingBox = new Kt), this.boundingBox.makeEmpty();
                            for (var t = e.getAttribute("position"), n = 0; n < t.count; n++) as.fromBufferAttribute(t, n), this.applyBoneTransform(n, as), this.boundingBox.expandByPoint(as)
                        }
                    }, {
                        key: "computeBoundingSphere",
                        value: function () {
                            var e = this.geometry;
                            null === this.boundingSphere && (this.boundingSphere = new pn), this.boundingSphere.makeEmpty();
                            for (var t = e.getAttribute("position"), n = 0; n < t.count; n++) as.fromBufferAttribute(t, n), this.applyBoneTransform(n, as), this.boundingSphere.expandByPoint(as)
                        }
                    }, {
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            var n = this.material,
                                r = this.matrixWorld;
                            void 0 !== n && (null === this.boundingSphere && this.computeBoundingSphere(), os.copy(this.boundingSphere), os.applyMatrix4(r), !1 !== e.ray.intersectsSphere(os) && (ss.copy(r).invert(), ls.copy(e.ray).applyMatrix4(ss), null !== this.boundingBox && !1 === ls.intersectsBox(this.boundingBox) || this._computeIntersections(e, t, ls)))
                        }
                    }, {
                        key: "getVertexPosition",
                        value: function (e, t) {
                            return g(y(n.prototype), "getVertexPosition", this).call(this, e, t), this.applyBoneTransform(e, t), t
                        }
                    }, {
                        key: "bind",
                        value: function (e, t) {
                            this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
                        }
                    }, {
                        key: "pose",
                        value: function () {
                            this.skeleton.pose()
                        }
                    }, {
                        key: "normalizeSkinWeights",
                        value: function () {
                            for (var e = new zt, t = this.geometry.attributes.skinWeight, n = 0, r = t.count; n < r; n++) {
                                e.fromBufferAttribute(t, n);
                                var i = 1 / e.manhattanLength();
                                i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
                            }
                        }
                    }, {
                        key: "updateMatrixWorld",
                        value: function (e) {
                            g(y(n.prototype), "updateMatrixWorld", this).call(this, e), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                        }
                    }, {
                        key: "applyBoneTransform",
                        value: function (e, t) {
                            var n = this.skeleton,
                                r = this.geometry;
                            ts.fromBufferAttribute(r.attributes.skinIndex, e), ns.fromBufferAttribute(r.attributes.skinWeight, e), es.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
                            for (var i = 0; i < 4; i++) {
                                var a = ns.getComponent(i);
                                if (0 !== a) {
                                    var o = ts.getComponent(i);
                                    is.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]), t.addScaledVector(rs.copy(es).applyMatrix4(is), a)
                                }
                            }
                            return t.applyMatrix4(this.bindMatrixInverse)
                        }
                    }, {
                        key: "boneTransform",
                        value: function (e, t) {
                            return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."), this.applyBoneTransform(e, t)
                        }
                    }]), n
                }(qr),
                cs = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this)).isBone = !0, e.type = "Bone", e
                    }
                    return o(n)
                }(Yn),
                hs = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                            s = arguments.length > 3 ? arguments[3] : void 0,
                            l = arguments.length > 4 ? arguments[4] : void 0,
                            u = arguments.length > 5 ? arguments[5] : void 0,
                            c = arguments.length > 6 ? arguments[6] : void 0,
                            h = arguments.length > 7 ? arguments[7] : void 0,
                            d = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : j,
                            f = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : j,
                            p = arguments.length > 10 ? arguments[10] : void 0,
                            m = arguments.length > 11 ? arguments[11] : void 0;
                        return i(this, n), (e = t.call(this, null, u, c, h, d, f, s, l, p, m)).isDataTexture = !0, e.image = {
                            data: r,
                            width: a,
                            height: o
                        }, e.generateMipmaps = !1, e.flipY = !1, e.unpackAlignment = 1, e
                    }
                    return o(n)
                }(Bt),
                ds = new En,
                fs = new En,
                ps = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
                        i(this, e), this.uuid = ut(), this.bones = t.slice(0), this.boneInverses = n, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.init()
                    }
                    return o(e, [{
                        key: "init",
                        value: function () {
                            var e = this.bones,
                                t = this.boneInverses;
                            if (this.boneMatrices = new Float32Array(16 * e.length), 0 === t.length) this.calculateInverses();
                            else if (e.length !== t.length) {
                                console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
                                for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new En)
                            }
                        }
                    }, {
                        key: "calculateInverses",
                        value: function () {
                            this.boneInverses.length = 0;
                            for (var e = 0, t = this.bones.length; e < t; e++) {
                                var n = new En;
                                this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
                            }
                        }
                    }, {
                        key: "pose",
                        value: function () {
                            for (var e = 0, t = this.bones.length; e < t; e++) {
                                var n = this.bones[e];
                                n && n.matrixWorld.copy(this.boneInverses[e]).invert()
                            }
                            for (var r = 0, i = this.bones.length; r < i; r++) {
                                var a = this.bones[r];
                                a && (a.parent && a.parent.isBone ? (a.matrix.copy(a.parent.matrixWorld).invert(), a.matrix.multiply(a.matrixWorld)) : a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale))
                            }
                        }
                    }, {
                        key: "update",
                        value: function () {
                            for (var e = this.bones, t = this.boneInverses, n = this.boneMatrices, r = this.boneTexture, i = 0, a = e.length; i < a; i++) {
                                var o = e[i] ? e[i].matrixWorld : fs;
                                ds.multiplyMatrices(o, t[i]), ds.toArray(n, 16 * i)
                            }
                            null !== r && (r.needsUpdate = !0)
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return new e(this.bones, this.boneInverses)
                        }
                    }, {
                        key: "computeBoneTexture",
                        value: function () {
                            var e = Math.sqrt(4 * this.bones.length);
                            e = pt(e), e = Math.max(e, 4);
                            var t = new Float32Array(e * e * 4);
                            t.set(this.boneMatrices);
                            var n = new hs(t, e, e, oe, te);
                            return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this.boneTextureSize = e, this
                        }
                    }, {
                        key: "getBoneByName",
                        value: function (e) {
                            for (var t = 0, n = this.bones.length; t < n; t++) {
                                var r = this.bones[t];
                                if (r.name === e) return r
                            }
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
                        }
                    }, {
                        key: "fromJSON",
                        value: function (e, t) {
                            this.uuid = e.uuid;
                            for (var n = 0, r = e.bones.length; n < r; n++) {
                                var i = e.bones[n],
                                    a = t[i];
                                void 0 === a && (console.warn("THREE.Skeleton: No bone found with UUID:", i), a = new cs), this.bones.push(a), this.boneInverses.push((new En).fromArray(e.boneInverses[n]))
                            }
                            return this.init(), this
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = {
                                metadata: {
                                    version: 4.6,
                                    type: "Skeleton",
                                    generator: "Skeleton.toJSON"
                                },
                                bones: [],
                                boneInverses: []
                            };
                            e.uuid = this.uuid;
                            for (var t = this.bones, n = this.boneInverses, r = 0, i = t.length; r < i; r++) {
                                var a = t[r];
                                e.bones.push(a.uuid);
                                var o = n[r];
                                e.boneInverses.push(o.toArray())
                            }
                            return e
                        }
                    }]), e
                }(),
                ms = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        var o, s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1;
                        return i(this, n), (o = t.call(this, e, r, a)).isInstancedBufferAttribute = !0, o.meshPerAttribute = s, o
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = g(y(n.prototype), "toJSON", this).call(this);
                            return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
                        }
                    }]), n
                }(_r),
                vs = new En,
                gs = new En,
                _s = [],
                ys = new Kt,
                xs = new En,
                Ms = new qr,
                Ss = new pn,
                Es = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a) {
                        var o;
                        i(this, n), (o = t.call(this, e, r)).isInstancedMesh = !0, o.instanceMatrix = new ms(new Float32Array(16 * a), 16), o.instanceColor = null, o.count = a, o.boundingBox = null, o.boundingSphere = null;
                        for (var s = 0; s < a; s++) o.setMatrixAt(s, xs);
                        return o
                    }
                    return o(n, [{
                        key: "computeBoundingBox",
                        value: function () {
                            var e = this.geometry,
                                t = this.count;
                            null === this.boundingBox && (this.boundingBox = new Kt), null === e.boundingBox && e.computeBoundingBox(), this.boundingBox.makeEmpty();
                            for (var n = 0; n < t; n++) this.getMatrixAt(n, vs), ys.copy(e.boundingBox).applyMatrix4(vs), this.boundingBox.union(ys)
                        }
                    }, {
                        key: "computeBoundingSphere",
                        value: function () {
                            var e = this.geometry,
                                t = this.count;
                            null === this.boundingSphere && (this.boundingSphere = new pn), null === e.boundingSphere && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
                            for (var n = 0; n < t; n++) this.getMatrixAt(n, vs), Ss.copy(e.boundingSphere).applyMatrix4(vs), this.boundingSphere.union(Ss)
                        }
                    }, {
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.instanceMatrix.copy(e.instanceMatrix), null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                        }
                    }, {
                        key: "getColorAt",
                        value: function (e, t) {
                            t.fromArray(this.instanceColor.array, 3 * e)
                        }
                    }, {
                        key: "getMatrixAt",
                        value: function (e, t) {
                            t.fromArray(this.instanceMatrix.array, 16 * e)
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            var n = this.matrixWorld,
                                r = this.count;
                            if (Ms.geometry = this.geometry, Ms.material = this.material, void 0 !== Ms.material && (null === this.boundingSphere && this.computeBoundingSphere(), Ss.copy(this.boundingSphere), Ss.applyMatrix4(n), !1 !== e.ray.intersectsSphere(Ss)))
                                for (var i = 0; i < r; i++) {
                                    this.getMatrixAt(i, vs), gs.multiplyMatrices(n, vs), Ms.matrixWorld = gs, Ms.raycast(e, _s);
                                    for (var a = 0, o = _s.length; a < o; a++) {
                                        var s = _s[a];
                                        s.instanceId = i, s.object = this, t.push(s)
                                    }
                                    _s.length = 0
                                }
                        }
                    }, {
                        key: "setColorAt",
                        value: function (e, t) {
                            null === this.instanceColor && (this.instanceColor = new ms(new Float32Array(3 * this.instanceMatrix.count), 3)), t.toArray(this.instanceColor.array, 3 * e)
                        }
                    }, {
                        key: "setMatrixAt",
                        value: function (e, t) {
                            t.toArray(this.instanceMatrix.array, 16 * e)
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function () {}
                    }, {
                        key: "dispose",
                        value: function () {
                            this.dispatchEvent({
                                type: "dispose"
                            })
                        }
                    }]), n
                }(qr),
                Ts = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isLineBasicMaterial = !0, r.type = "LineBasicMaterial", r.color = new fr(16777215), r.map = null, r.linewidth = 1, r.linecap = "round", r.linejoin = "round", r.fog = !0, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
                        }
                    }]), n
                }(lr),
                bs = new Xt,
                As = new Xt,
                ws = new En,
                Rs = new Sn,
                Cs = new pn,
                Ls = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Cr,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ts;
                        return i(this, n), (e = t.call(this)).isLine = !0, e.type = "Line", e.geometry = r, e.material = a, e.updateMorphTargets(), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "computeLineDistances",
                        value: function () {
                            var e = this.geometry;
                            if (null === e.index) {
                                for (var t = e.attributes.position, n = [0], r = 1, i = t.count; r < i; r++) bs.fromBufferAttribute(t, r - 1), As.fromBufferAttribute(t, r), n[r] = n[r - 1], n[r] += bs.distanceTo(As);
                                e.setAttribute("lineDistance", new Mr(n, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            var n = this.geometry,
                                r = this.matrixWorld,
                                i = e.params.Line.threshold,
                                a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(), Cs.copy(n.boundingSphere), Cs.applyMatrix4(r), Cs.radius += i, !1 !== e.ray.intersectsSphere(Cs)) {
                                ws.copy(r).invert(), Rs.copy(e.ray).applyMatrix4(ws);
                                var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                    s = o * o,
                                    l = new Xt,
                                    u = new Xt,
                                    c = new Xt,
                                    h = new Xt,
                                    d = this.isLineSegments ? 2 : 1,
                                    f = n.index,
                                    p = n.attributes.position;
                                if (null !== f)
                                    for (var m = Math.max(0, a.start), v = Math.min(f.count, a.start + a.count) - 1; m < v; m += d) {
                                        var g = f.getX(m),
                                            _ = f.getX(m + 1);
                                        if (l.fromBufferAttribute(p, g), u.fromBufferAttribute(p, _), !(Rs.distanceSqToSegment(l, u, h, c) > s)) {
                                            h.applyMatrix4(this.matrixWorld);
                                            var y = e.ray.origin.distanceTo(h);
                                            y < e.near || y > e.far || t.push({
                                                distance: y,
                                                point: c.clone().applyMatrix4(this.matrixWorld),
                                                index: m,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    } else
                                        for (var x = Math.max(0, a.start), M = Math.min(p.count, a.start + a.count) - 1; x < M; x += d) {
                                            if (l.fromBufferAttribute(p, x), u.fromBufferAttribute(p, x + 1), !(Rs.distanceSqToSegment(l, u, h, c) > s)) {
                                                h.applyMatrix4(this.matrixWorld);
                                                var S = e.ray.origin.distanceTo(h);
                                                S < e.near || S > e.far || t.push({
                                                    distance: S,
                                                    point: c.clone().applyMatrix4(this.matrixWorld),
                                                    index: x,
                                                    face: null,
                                                    faceIndex: null,
                                                    object: this
                                                })
                                            }
                                        }
                            }
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function () {
                            var e = this.geometry.morphAttributes,
                                t = Object.keys(e);
                            if (t.length > 0) {
                                var n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        var a = n[r].name || String(r);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                                    }
                                }
                            }
                        }
                    }]), n
                }(Yn),
                Ps = new Xt,
                ks = new Xt,
                Is = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e, r)).isLineSegments = !0, a.type = "LineSegments", a
                    }
                    return o(n, [{
                        key: "computeLineDistances",
                        value: function () {
                            var e = this.geometry;
                            if (null === e.index) {
                                for (var t = e.attributes.position, n = [], r = 0, i = t.count; r < i; r += 2) Ps.fromBufferAttribute(t, r), ks.fromBufferAttribute(t, r + 1), n[r] = 0 === r ? 0 : n[r - 1], n[r + 1] = n[r] + Ps.distanceTo(ks);
                                e.setAttribute("lineDistance", new Mr(n, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                            return this
                        }
                    }]), n
                }(Ls),
                Us = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e, r)).isLineLoop = !0, a.type = "LineLoop", a
                    }
                    return o(n)
                }(Ls),
                Ds = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isPointsMaterial = !0, r.type = "PointsMaterial", r.color = new fr(16777215), r.map = null, r.alphaMap = null, r.size = 1, r.sizeAttenuation = !0, r.fog = !0, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
                        }
                    }]), n
                }(lr),
                Ns = new En,
                Os = new Sn,
                Fs = new pn,
                Bs = new Xt,
                zs = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Cr,
                            a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Ds;
                        return i(this, n), (e = t.call(this)).isPoints = !0, e.type = "Points", e.geometry = r, e.material = a, e.updateMorphTargets(), e
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.material = e.material, this.geometry = e.geometry, this
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            var n = this.geometry,
                                r = this.matrixWorld,
                                i = e.params.Points.threshold,
                                a = n.drawRange;
                            if (null === n.boundingSphere && n.computeBoundingSphere(), Fs.copy(n.boundingSphere), Fs.applyMatrix4(r), Fs.radius += i, !1 !== e.ray.intersectsSphere(Fs)) {
                                Ns.copy(r).invert(), Os.copy(e.ray).applyMatrix4(Ns);
                                var o = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                    s = o * o,
                                    l = n.index,
                                    u = n.attributes.position;
                                if (null !== l)
                                    for (var c = Math.max(0, a.start), h = Math.min(l.count, a.start + a.count); c < h; c++) {
                                        var d = l.getX(c);
                                        Bs.fromBufferAttribute(u, d), Hs(Bs, d, s, r, e, t, this)
                                    } else
                                        for (var f = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count); f < p; f++) Bs.fromBufferAttribute(u, f), Hs(Bs, f, s, r, e, t, this)
                            }
                        }
                    }, {
                        key: "updateMorphTargets",
                        value: function () {
                            var e = this.geometry.morphAttributes,
                                t = Object.keys(e);
                            if (t.length > 0) {
                                var n = e[t[0]];
                                if (void 0 !== n) {
                                    this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        var a = n[r].name || String(r);
                                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r
                                    }
                                }
                            }
                        }
                    }]), n
                }(Yn);

            function Hs(e, t, n, r, i, a, o) {
                var s = Os.distanceSqToPoint(e);
                if (s < n) {
                    var l = new Xt;
                    Os.closestPointToPoint(e, l), l.applyMatrix4(r);
                    var u = i.ray.origin.distanceTo(l);
                    if (u < i.near || u > i.far) return;
                    a.push({
                        distance: u,
                        distanceToRay: Math.sqrt(s),
                        point: l,
                        index: t,
                        face: null,
                        object: o
                    })
                }
            }
            var Gs = function () {
                function e() {
                    i(this, e), this.type = "Curve", this.arcLengthDivisions = 200
                }
                return o(e, [{
                    key: "getPoint",
                    value: function () {
                        return console.warn("THREE.Curve: .getPoint() not implemented."), null
                    }
                }, {
                    key: "getPointAt",
                    value: function (e, t) {
                        var n = this.getUtoTmapping(e);
                        return this.getPoint(n, t)
                    }
                }, {
                    key: "getPoints",
                    value: function () {
                        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPoint(n / e));
                        return t
                    }
                }, {
                    key: "getSpacedPoints",
                    value: function () {
                        for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 5, t = [], n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
                        return t
                    }
                }, {
                    key: "getLength",
                    value: function () {
                        var e = this.getLengths();
                        return e[e.length - 1]
                    }
                }, {
                    key: "getLengths",
                    value: function () {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.arcLengthDivisions;
                        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                        this.needsUpdate = !1;
                        var t, n = [],
                            r = this.getPoint(0),
                            i = 0;
                        n.push(0);
                        for (var a = 1; a <= e; a++) i += (t = this.getPoint(a / e)).distanceTo(r), n.push(i), r = t;
                        return this.cacheArcLengths = n, n
                    }
                }, {
                    key: "updateArcLengths",
                    value: function () {
                        this.needsUpdate = !0, this.getLengths()
                    }
                }, {
                    key: "getUtoTmapping",
                    value: function (e, t) {
                        var n, r = this.getLengths(),
                            i = 0,
                            a = r.length;
                        n = t || e * r[a - 1];
                        for (var o, s = 0, l = a - 1; s <= l;)
                            if ((o = r[i = Math.floor(s + (l - s) / 2)] - n) < 0) s = i + 1;
                            else {
                                if (!(o > 0)) {
                                    l = i;
                                    break
                                }
                                l = i - 1
                            } if (r[i = l] === n) return i / (a - 1);
                        var u = r[i];
                        return (i + (n - u) / (r[i + 1] - u)) / (a - 1)
                    }
                }, {
                    key: "getTangent",
                    value: function (e, t) {
                        var n = 1e-4,
                            r = e - n,
                            i = e + n;
                        r < 0 && (r = 0), i > 1 && (i = 1);
                        var a = this.getPoint(r),
                            o = this.getPoint(i),
                            s = t || (a.isVector2 ? new yt : new Xt);
                        return s.copy(o).sub(a).normalize(), s
                    }
                }, {
                    key: "getTangentAt",
                    value: function (e, t) {
                        var n = this.getUtoTmapping(e);
                        return this.getTangent(n, t)
                    }
                }, {
                    key: "computeFrenetFrames",
                    value: function (e, t) {
                        for (var n = new Xt, r = [], i = [], a = [], o = new Xt, s = new En, l = 0; l <= e; l++) {
                            var u = l / e;
                            r[l] = this.getTangentAt(u, new Xt)
                        }
                        i[0] = new Xt, a[0] = new Xt;
                        var c = Number.MAX_VALUE,
                            h = Math.abs(r[0].x),
                            d = Math.abs(r[0].y),
                            f = Math.abs(r[0].z);
                        h <= c && (c = h, n.set(1, 0, 0)), d <= c && (c = d, n.set(0, 1, 0)), f <= c && n.set(0, 0, 1), o.crossVectors(r[0], n).normalize(), i[0].crossVectors(r[0], o), a[0].crossVectors(r[0], i[0]);
                        for (var p = 1; p <= e; p++) {
                            if (i[p] = i[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
                                o.normalize();
                                var m = Math.acos(ct(r[p - 1].dot(r[p]), -1, 1));
                                i[p].applyMatrix4(s.makeRotationAxis(o, m))
                            }
                            a[p].crossVectors(r[p], i[p])
                        }
                        if (!0 === t) {
                            var v = Math.acos(ct(i[0].dot(i[e]), -1, 1));
                            v /= e, r[0].dot(o.crossVectors(i[0], i[e])) > 0 && (v = -v);
                            for (var g = 1; g <= e; g++) i[g].applyMatrix4(s.makeRotationAxis(r[g], v * g)), a[g].crossVectors(r[g], i[g])
                        }
                        return {
                            tangents: r,
                            normals: i,
                            binormals: a
                        }
                    }
                }, {
                    key: "clone",
                    value: function () {
                        return (new this.constructor).copy(this)
                    }
                }, {
                    key: "copy",
                    value: function (e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions, this
                    }
                }, {
                    key: "toJSON",
                    value: function () {
                        var e = {
                            metadata: {
                                version: 4.6,
                                type: "Curve",
                                generator: "Curve.toJSON"
                            }
                        };
                        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
                    }
                }, {
                    key: "fromJSON",
                    value: function (e) {
                        return this.arcLengthDivisions = e.arcLengthDivisions, this
                    }
                }]), e
            }();

            function Vs() {
                var e = 0,
                    t = 0,
                    n = 0,
                    r = 0;

                function i(i, a, o, s) {
                    e = i, t = o, n = -3 * i + 3 * a - 2 * o - s, r = 2 * i - 2 * a + o + s
                }
                return {
                    initCatmullRom: function (e, t, n, r, a) {
                        i(t, n, a * (n - e), a * (r - t))
                    },
                    initNonuniformCatmullRom: function (e, t, n, r, a, o, s) {
                        var l = (t - e) / a - (n - e) / (a + o) + (n - t) / o,
                            u = (n - t) / o - (r - t) / (o + s) + (r - n) / s;
                        i(t, n, l *= o, u *= o)
                    },
                    calc: function (i) {
                        var a = i * i;
                        return e + t * i + n * a + r * (a * i)
                    }
                }
            }
            var Ws = new Xt,
                js = new Vs,
                Xs = new Vs,
                qs = new Vs,
                Ys = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e, r = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                            a = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                            o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "centripetal",
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                        return i(this, n), (e = t.call(this)).isCatmullRomCurve3 = !0, e.type = "CatmullRomCurve3", e.points = r, e.closed = a, e.curveType = o, e.tension = s, e
                    }
                    return o(n, [{
                        key: "getPoint",
                        value: function (e) {
                            var t, n, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Xt,
                                i = r,
                                a = this.points,
                                o = a.length,
                                s = (o - (this.closed ? 0 : 1)) * e,
                                l = Math.floor(s),
                                u = s - l;
                            this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / o) + 1) * o : 0 === u && l === o - 1 && (l = o - 2, u = 1), this.closed || l > 0 ? t = a[(l - 1) % o] : (Ws.subVectors(a[0], a[1]).add(a[0]), t = Ws);
                            var c = a[l % o],
                                h = a[(l + 1) % o];
                            if (this.closed || l + 2 < o ? n = a[(l + 2) % o] : (Ws.subVectors(a[o - 1], a[o - 2]).add(a[o - 1]), n = Ws), "centripetal" === this.curveType || "chordal" === this.curveType) {
                                var d = "chordal" === this.curveType ? .5 : .25,
                                    f = Math.pow(t.distanceToSquared(c), d),
                                    p = Math.pow(c.distanceToSquared(h), d),
                                    m = Math.pow(h.distanceToSquared(n), d);
                                p < 1e-4 && (p = 1), f < 1e-4 && (f = p), m < 1e-4 && (m = p), js.initNonuniformCatmullRom(t.x, c.x, h.x, n.x, f, p, m), Xs.initNonuniformCatmullRom(t.y, c.y, h.y, n.y, f, p, m), qs.initNonuniformCatmullRom(t.z, c.z, h.z, n.z, f, p, m)
                            } else "catmullrom" === this.curveType && (js.initCatmullRom(t.x, c.x, h.x, n.x, this.tension), Xs.initCatmullRom(t.y, c.y, h.y, n.y, this.tension), qs.initCatmullRom(t.z, c.z, h.z, n.z, this.tension));
                            return i.set(js.calc(u), Xs.calc(u), qs.calc(u)), i
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            g(y(n.prototype), "copy", this).call(this, e), this.points = [];
                            for (var t = 0, r = e.points.length; t < r; t++) {
                                var i = e.points[t];
                                this.points.push(i.clone())
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = g(y(n.prototype), "toJSON", this).call(this);
                            e.points = [];
                            for (var t = 0, r = this.points.length; t < r; t++) {
                                var i = this.points[t];
                                e.points.push(i.toArray())
                            }
                            return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
                        }
                    }, {
                        key: "fromJSON",
                        value: function (e) {
                            g(y(n.prototype), "fromJSON", this).call(this, e), this.points = [];
                            for (var t = 0, r = e.points.length; t < r; t++) {
                                var i = e.points[t];
                                this.points.push((new Xt).fromArray(i))
                            }
                            return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
                        }
                    }]), n
                }(Gs);
            var Ks = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isMeshStandardMaterial = !0, r.defines = {
                            STANDARD: ""
                        }, r.type = "MeshStandardMaterial", r.color = new fr(16777215), r.roughness = 1, r.metalness = 0, r.map = null, r.lightMap = null, r.lightMapIntensity = 1, r.aoMap = null, r.aoMapIntensity = 1, r.emissive = new fr(0), r.emissiveIntensity = 1, r.emissiveMap = null, r.bumpMap = null, r.bumpScale = 1, r.normalMap = null, r.normalMapType = 0, r.normalScale = new yt(1, 1), r.displacementMap = null, r.displacementScale = 1, r.displacementBias = 0, r.roughnessMap = null, r.metalnessMap = null, r.alphaMap = null, r.envMap = null, r.envMapIntensity = 1, r.wireframe = !1, r.wireframeLinewidth = 1, r.wireframeLinecap = "round", r.wireframeLinejoin = "round", r.flatShading = !1, r.fog = !0, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.defines = {
                                STANDARD: ""
                            }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
                        }
                    }]), n
                }(lr),
                Zs = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this)).isMeshPhysicalMaterial = !0, r.defines = {
                            STANDARD: "",
                            PHYSICAL: ""
                        }, r.type = "MeshPhysicalMaterial", r.anisotropyRotation = 0, r.anisotropyMap = null, r.clearcoatMap = null, r.clearcoatRoughness = 0, r.clearcoatRoughnessMap = null, r.clearcoatNormalScale = new yt(1, 1), r.clearcoatNormalMap = null, r.ior = 1.5, Object.defineProperty(M(r), "reflectivity", {
                            get: function () {
                                return ct(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
                            },
                            set: function (e) {
                                this.ior = (1 + .4 * e) / (1 - .4 * e)
                            }
                        }), r.iridescenceMap = null, r.iridescenceIOR = 1.3, r.iridescenceThicknessRange = [100, 400], r.iridescenceThicknessMap = null, r.sheenColor = new fr(0), r.sheenColorMap = null, r.sheenRoughness = 1, r.sheenRoughnessMap = null, r.transmissionMap = null, r.thickness = 0, r.thicknessMap = null, r.attenuationDistance = 1 / 0, r.attenuationColor = new fr(1, 1, 1), r.specularIntensity = 1, r.specularIntensityMap = null, r.specularColor = new fr(1, 1, 1), r.specularColorMap = null, r._anisotropy = 0, r._clearcoat = 0, r._iridescence = 0, r._sheen = 0, r._transmission = 0, r.setValues(e), r
                    }
                    return o(n, [{
                        key: "anisotropy",
                        get: function () {
                            return this._anisotropy
                        },
                        set: function (e) {
                            this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
                        }
                    }, {
                        key: "clearcoat",
                        get: function () {
                            return this._clearcoat
                        },
                        set: function (e) {
                            this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
                        }
                    }, {
                        key: "iridescence",
                        get: function () {
                            return this._iridescence
                        },
                        set: function (e) {
                            this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
                        }
                    }, {
                        key: "sheen",
                        get: function () {
                            return this._sheen
                        },
                        set: function (e) {
                            this._sheen > 0 != e > 0 && this.version++, this._sheen = e
                        }
                    }, {
                        key: "transmission",
                        get: function () {
                            return this._transmission
                        },
                        set: function (e) {
                            this._transmission > 0 != e > 0 && this.version++, this._transmission = e
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.defines = {
                                STANDARD: "",
                                PHYSICAL: ""
                            }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = h(e.iridescenceThicknessRange), this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
                        }
                    }]), n
                }(Ks);

            function Js(e, t, n) {
                return $s(e) ? new e.constructor(e.subarray(t, void 0 !== n ? n : e.length)) : e.slice(t, n)
            }

            function Qs(e, t, n) {
                return !e || !n && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
            }

            function $s(e) {
                return ArrayBuffer.isView(e) && !(e instanceof DataView)
            }

            function el(e) {
                for (var t = e.length, n = new Array(t), r = 0; r !== t; ++r) n[r] = r;
                return n.sort((function (t, n) {
                    return e[t] - e[n]
                })), n
            }

            function tl(e, t, n) {
                for (var r = e.length, i = new e.constructor(r), a = 0, o = 0; o !== r; ++a)
                    for (var s = n[a] * t, l = 0; l !== t; ++l) i[o++] = e[s + l];
                return i
            }

            function nl(e, t, n, r) {
                for (var i = 1, a = e[0]; void 0 !== a && void 0 === a[r];) a = e[i++];
                if (void 0 !== a) {
                    var o = a[r];
                    if (void 0 !== o)
                        if (Array.isArray(o))
                            do {
                                void 0 !== (o = a[r]) && (t.push(a.time), n.push.apply(n, o)), a = e[i++]
                            } while (void 0 !== a);
                        else if (void 0 !== o.toArray)
                        do {
                            void 0 !== (o = a[r]) && (t.push(a.time), o.toArray(n, n.length)), a = e[i++]
                        } while (void 0 !== a);
                    else
                        do {
                            void 0 !== (o = a[r]) && (t.push(a.time), n.push(o)), a = e[i++]
                        } while (void 0 !== a)
                }
            }
            var rl = function () {
                    function e(t, n, r, a) {
                        i(this, e), this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== a ? a : new n.constructor(r), this.sampleValues = n, this.valueSize = r, this.settings = null, this.DefaultSettings_ = {}
                    }
                    return o(e, [{
                        key: "evaluate",
                        value: function (e) {
                            var t = this.parameterPositions,
                                n = this._cachedIndex,
                                r = t[n],
                                i = t[n - 1];
                            e: {
                                t: {
                                    var a;n: {
                                        r: if (!(e < r)) {
                                            for (var o = n + 2;;) {
                                                if (void 0 === r) {
                                                    if (e < i) break r;
                                                    return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                                                }
                                                if (n === o) break;
                                                if (i = r, e < (r = t[++n])) break t
                                            }
                                            a = t.length;
                                            break n
                                        }if (e >= i) break e;
                                        var s = t[1];e < s && (n = 2, i = s);
                                        for (var l = n - 2;;) {
                                            if (void 0 === i) return this._cachedIndex = 0, this.copySampleValue_(0);
                                            if (n === l) break;
                                            if (r = i, e >= (i = t[--n - 1])) break t
                                        }
                                        a = n,
                                        n = 0
                                    }
                                    for (; n < a;) {
                                        var u = n + a >>> 1;
                                        e < t[u] ? a = u : n = u + 1
                                    }
                                    if (r = t[n], void 0 === (i = t[n - 1])) return this._cachedIndex = 0,
                                    this.copySampleValue_(0);
                                    if (void 0 === r) return n = t.length,
                                    this._cachedIndex = n,
                                    this.copySampleValue_(n - 1)
                                }
                                this._cachedIndex = n,
                                this.intervalChanged_(n, i, r)
                            }
                            return this.interpolate_(n, i, e, r)
                        }
                    }, {
                        key: "getSettings_",
                        value: function () {
                            return this.settings || this.DefaultSettings_
                        }
                    }, {
                        key: "copySampleValue_",
                        value: function (e) {
                            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r, a = 0; a !== r; ++a) t[a] = n[i + a];
                            return t
                        }
                    }, {
                        key: "interpolate_",
                        value: function () {
                            throw new Error("call to abstract method")
                        }
                    }, {
                        key: "intervalChanged_",
                        value: function () {}
                    }]), e
                }(),
                il = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o) {
                        var s;
                        return i(this, n), (s = t.call(this, e, r, a, o))._weightPrev = -0, s._offsetPrev = -0, s._weightNext = -0, s._offsetNext = -0, s.DefaultSettings_ = {
                            endingStart: Ve,
                            endingEnd: Ve
                        }, s
                    }
                    return o(n, [{
                        key: "intervalChanged_",
                        value: function (e, t, n) {
                            var r = this.parameterPositions,
                                i = e - 2,
                                a = e + 1,
                                o = r[i],
                                s = r[a];
                            if (void 0 === o) switch (this.getSettings_().endingStart) {
                                case We:
                                    i = e, o = 2 * t - n;
                                    break;
                                case je:
                                    o = t + r[i = r.length - 2] - r[i + 1];
                                    break;
                                default:
                                    i = e, o = n
                            }
                            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                                case We:
                                    a = e, s = 2 * n - t;
                                    break;
                                case je:
                                    a = 1, s = n + r[1] - r[0];
                                    break;
                                default:
                                    a = e - 1, s = t
                            }
                            var l = .5 * (n - t),
                                u = this.valueSize;
                            this._weightPrev = l / (t - o), this._weightNext = l / (s - n), this._offsetPrev = i * u, this._offsetNext = a * u
                        }
                    }, {
                        key: "interpolate_",
                        value: function (e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, d = this._weightNext, f = (n - t) / (r - t), p = f * f, m = p * f, v = -h * m + 2 * h * p - h * f, g = (1 + h) * m + (-1.5 - 2 * h) * p + (-.5 + h) * f + 1, _ = (-1 - d) * m + (1.5 + d) * p + .5 * f, y = d * m - d * p, x = 0; x !== o; ++x) i[x] = v * a[u + x] + g * a[l + x] + _ * a[s + x] + y * a[c + x];
                            return i
                        }
                    }]), n
                }(rl),
                al = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o) {
                        return i(this, n), t.call(this, e, r, a, o)
                    }
                    return o(n, [{
                        key: "interpolate_",
                        value: function (e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = e * o, l = s - o, u = (n - t) / (r - t), c = 1 - u, h = 0; h !== o; ++h) i[h] = a[l + h] * c + a[s + h] * u;
                            return i
                        }
                    }]), n
                }(rl),
                ol = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o) {
                        return i(this, n), t.call(this, e, r, a, o)
                    }
                    return o(n, [{
                        key: "interpolate_",
                        value: function (e) {
                            return this.copySampleValue_(e - 1)
                        }
                    }]), n
                }(rl),
                sl = function () {
                    function e(t, n, r, a) {
                        if (i(this, e), void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                        if (void 0 === n || 0 === n.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                        this.name = t, this.times = Qs(n, this.TimeBufferType), this.values = Qs(r, this.ValueBufferType), this.setInterpolation(a || this.DefaultInterpolation)
                    }
                    return o(e, [{
                        key: "InterpolantFactoryMethodDiscrete",
                        value: function (e) {
                            return new ol(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "InterpolantFactoryMethodLinear",
                        value: function (e) {
                            return new al(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "InterpolantFactoryMethodSmooth",
                        value: function (e) {
                            return new il(this.times, this.values, this.getValueSize(), e)
                        }
                    }, {
                        key: "setInterpolation",
                        value: function (e) {
                            var t;
                            switch (e) {
                                case ze:
                                    t = this.InterpolantFactoryMethodDiscrete;
                                    break;
                                case He:
                                    t = this.InterpolantFactoryMethodLinear;
                                    break;
                                case Ge:
                                    t = this.InterpolantFactoryMethodSmooth
                            }
                            if (void 0 === t) {
                                var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                                if (void 0 === this.createInterpolant) {
                                    if (e === this.DefaultInterpolation) throw new Error(n);
                                    this.setInterpolation(this.DefaultInterpolation)
                                }
                                return console.warn("THREE.KeyframeTrack:", n), this
                            }
                            return this.createInterpolant = t, this
                        }
                    }, {
                        key: "getInterpolation",
                        value: function () {
                            switch (this.createInterpolant) {
                                case this.InterpolantFactoryMethodDiscrete:
                                    return ze;
                                case this.InterpolantFactoryMethodLinear:
                                    return He;
                                case this.InterpolantFactoryMethodSmooth:
                                    return Ge
                            }
                        }
                    }, {
                        key: "getValueSize",
                        value: function () {
                            return this.values.length / this.times.length
                        }
                    }, {
                        key: "shift",
                        value: function (e) {
                            if (0 !== e)
                                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] += e;
                            return this
                        }
                    }, {
                        key: "scale",
                        value: function (e) {
                            if (1 !== e)
                                for (var t = this.times, n = 0, r = t.length; n !== r; ++n) t[n] *= e;
                            return this
                        }
                    }, {
                        key: "trim",
                        value: function (e, t) {
                            for (var n = this.times, r = n.length, i = 0, a = r - 1; i !== r && n[i] < e;) ++i;
                            for (; - 1 !== a && n[a] > t;) --a;
                            if (++a, 0 !== i || a !== r) {
                                i >= a && (i = (a = Math.max(a, 1)) - 1);
                                var o = this.getValueSize();
                                this.times = Js(n, i, a), this.values = Js(this.values, i * o, a * o)
                            }
                            return this
                        }
                    }, {
                        key: "validate",
                        value: function () {
                            var e = !0,
                                t = this.getValueSize();
                            t - Math.floor(t) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
                            var n = this.times,
                                r = this.values,
                                i = n.length;
                            0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
                            for (var a = null, o = 0; o !== i; o++) {
                                var s = n[o];
                                if ("number" == typeof s && isNaN(s)) {
                                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, s), e = !1;
                                    break
                                }
                                if (null !== a && a > s) {
                                    console.error("THREE.KeyframeTrack: Out of order keys.", this, o, s, a), e = !1;
                                    break
                                }
                                a = s
                            }
                            if (void 0 !== r && $s(r))
                                for (var l = 0, u = r.length; l !== u; ++l) {
                                    var c = r[l];
                                    if (isNaN(c)) {
                                        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, c), e = !1;
                                        break
                                    }
                                }
                            return e
                        }
                    }, {
                        key: "optimize",
                        value: function () {
                            for (var e = Js(this.times), t = Js(this.values), n = this.getValueSize(), r = this.getInterpolation() === Ge, i = e.length - 1, a = 1, o = 1; o < i; ++o) {
                                var s = !1,
                                    l = e[o];
                                if (l !== e[o + 1] && (1 !== o || l !== e[0]))
                                    if (r) s = !0;
                                    else
                                        for (var u = o * n, c = u - n, h = u + n, d = 0; d !== n; ++d) {
                                            var f = t[u + d];
                                            if (f !== t[c + d] || f !== t[h + d]) {
                                                s = !0;
                                                break
                                            }
                                        }
                                if (s) {
                                    if (o !== a) {
                                        e[a] = e[o];
                                        for (var p = o * n, m = a * n, v = 0; v !== n; ++v) t[m + v] = t[p + v]
                                    }++a
                                }
                            }
                            if (i > 0) {
                                e[a] = e[i];
                                for (var g = i * n, _ = a * n, y = 0; y !== n; ++y) t[_ + y] = t[g + y];
                                ++a
                            }
                            return a !== e.length ? (this.times = Js(e, 0, a), this.values = Js(t, 0, a * n)) : (this.times = e, this.values = t), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            var e = Js(this.times, 0),
                                t = Js(this.values, 0),
                                n = new(0, this.constructor)(this.name, e, t);
                            return n.createInterpolant = this.createInterpolant, n
                        }
                    }], [{
                        key: "toJSON",
                        value: function (e) {
                            var t, n = e.constructor;
                            if (n.toJSON !== this.toJSON) t = n.toJSON(e);
                            else {
                                t = {
                                    name: e.name,
                                    times: Qs(e.times, Array),
                                    values: Qs(e.values, Array)
                                };
                                var r = e.getInterpolation();
                                r !== e.DefaultInterpolation && (t.interpolation = r)
                            }
                            return t.type = e.ValueTypeName, t
                        }
                    }]), e
                }();
            sl.prototype.TimeBufferType = Float32Array, sl.prototype.ValueBufferType = Float32Array, sl.prototype.DefaultInterpolation = He;
            var ll = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    return i(this, n), t.apply(this, arguments)
                }
                return o(n)
            }(sl);
            ll.prototype.ValueTypeName = "bool", ll.prototype.ValueBufferType = Array, ll.prototype.DefaultInterpolation = ze, ll.prototype.InterpolantFactoryMethodLinear = void 0, ll.prototype.InterpolantFactoryMethodSmooth = void 0;
            var ul = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    return i(this, n), t.apply(this, arguments)
                }
                return o(n)
            }(sl);
            ul.prototype.ValueTypeName = "color";
            var cl = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    return i(this, n), t.apply(this, arguments)
                }
                return o(n)
            }(sl);
            cl.prototype.ValueTypeName = "number";
            var hl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o) {
                        return i(this, n), t.call(this, e, r, a, o)
                    }
                    return o(n, [{
                        key: "interpolate_",
                        value: function (e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = (n - t) / (r - t), l = e * o, u = l + o; l !== u; l += 4) jt.slerpFlat(i, 0, a, l - o, a, l, s);
                            return i
                        }
                    }]), n
                }(rl),
                dl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        return i(this, n), t.apply(this, arguments)
                    }
                    return o(n, [{
                        key: "InterpolantFactoryMethodLinear",
                        value: function (e) {
                            return new hl(this.times, this.values, this.getValueSize(), e)
                        }
                    }]), n
                }(sl);
            dl.prototype.ValueTypeName = "quaternion", dl.prototype.DefaultInterpolation = He, dl.prototype.InterpolantFactoryMethodSmooth = void 0;
            var fl = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    return i(this, n), t.apply(this, arguments)
                }
                return o(n)
            }(sl);
            fl.prototype.ValueTypeName = "string", fl.prototype.ValueBufferType = Array, fl.prototype.DefaultInterpolation = ze, fl.prototype.InterpolantFactoryMethodLinear = void 0, fl.prototype.InterpolantFactoryMethodSmooth = void 0;
            var pl = function (e) {
                E(n, e);
                var t = b(n);

                function n() {
                    return i(this, n), t.apply(this, arguments)
                }
                return o(n)
            }(sl);
            pl.prototype.ValueTypeName = "vector";
            var ml = function () {
                function e(t) {
                    var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : -1,
                        r = arguments.length > 2 ? arguments[2] : void 0,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Xe;
                    i(this, e), this.name = t, this.tracks = r, this.duration = n, this.blendMode = a, this.uuid = ut(), this.duration < 0 && this.resetDuration()
                }
                return o(e, [{
                    key: "resetDuration",
                    value: function () {
                        for (var e = 0, t = 0, n = this.tracks.length; t !== n; ++t) {
                            var r = this.tracks[t];
                            e = Math.max(e, r.times[r.times.length - 1])
                        }
                        return this.duration = e, this
                    }
                }, {
                    key: "trim",
                    value: function () {
                        for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                        return this
                    }
                }, {
                    key: "validate",
                    value: function () {
                        for (var e = !0, t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
                        return e
                    }
                }, {
                    key: "optimize",
                    value: function () {
                        for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                        return this
                    }
                }, {
                    key: "clone",
                    value: function () {
                        for (var e = [], t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
                        return new this.constructor(this.name, this.duration, e, this.blendMode)
                    }
                }, {
                    key: "toJSON",
                    value: function () {
                        return this.constructor.toJSON(this)
                    }
                }], [{
                    key: "parse",
                    value: function (e) {
                        for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, a = n.length; i !== a; ++i) t.push(vl(n[i]).scale(r));
                        var o = new this(e.name, e.duration, t, e.blendMode);
                        return o.uuid = e.uuid, o
                    }
                }, {
                    key: "toJSON",
                    value: function (e) {
                        for (var t = [], n = e.tracks, r = {
                                name: e.name,
                                duration: e.duration,
                                tracks: t,
                                uuid: e.uuid,
                                blendMode: e.blendMode
                            }, i = 0, a = n.length; i !== a; ++i) t.push(sl.toJSON(n[i]));
                        return r
                    }
                }, {
                    key: "CreateFromMorphTargetSequence",
                    value: function (e, t, n, r) {
                        for (var i = t.length, a = [], o = 0; o < i; o++) {
                            var s = [],
                                l = [];
                            s.push((o + i - 1) % i, o, (o + 1) % i), l.push(0, 1, 0);
                            var u = el(s);
                            s = tl(s, 1, u), l = tl(l, 1, u), r || 0 !== s[0] || (s.push(i), l.push(l[0])), a.push(new cl(".morphTargetInfluences[" + t[o].name + "]", s, l).scale(1 / n))
                        }
                        return new this(e, -1, a)
                    }
                }, {
                    key: "findByName",
                    value: function (e, t) {
                        var n = e;
                        if (!Array.isArray(e)) {
                            var r = e;
                            n = r.geometry && r.geometry.animations || r.animations
                        }
                        for (var i = 0; i < n.length; i++)
                            if (n[i].name === t) return n[i];
                        return null
                    }
                }, {
                    key: "CreateClipsFromMorphTargetSequences",
                    value: function (e, t, n) {
                        for (var r = {}, i = /^([\w-]*?)([\d]+)$/, a = 0, o = e.length; a < o; a++) {
                            var s = e[a],
                                l = s.name.match(i);
                            if (l && l.length > 1) {
                                var u = l[1],
                                    c = r[u];
                                c || (r[u] = c = []), c.push(s)
                            }
                        }
                        var h = [];
                        for (var d in r) h.push(this.CreateFromMorphTargetSequence(d, r[d], t, n));
                        return h
                    }
                }, {
                    key: "parseAnimation",
                    value: function (e, t) {
                        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                        for (var n = function (e, t, n, r, i) {
                                if (0 !== n.length) {
                                    var a = [],
                                        o = [];
                                    nl(n, a, o, r), 0 !== a.length && i.push(new e(t, a, o))
                                }
                            }, r = [], i = e.name || "default", a = e.fps || 30, o = e.blendMode, s = e.length || -1, l = e.hierarchy || [], u = 0; u < l.length; u++) {
                            var c = l[u].keys;
                            if (c && 0 !== c.length)
                                if (c[0].morphTargets) {
                                    var h = {},
                                        d = void 0;
                                    for (d = 0; d < c.length; d++)
                                        if (c[d].morphTargets)
                                            for (var f = 0; f < c[d].morphTargets.length; f++) h[c[d].morphTargets[f]] = -1;
                                    for (var p in h) {
                                        for (var m = [], v = [], g = 0; g !== c[d].morphTargets.length; ++g) {
                                            var _ = c[d];
                                            m.push(_.time), v.push(_.morphTarget === p ? 1 : 0)
                                        }
                                        r.push(new cl(".morphTargetInfluence[" + p + "]", m, v))
                                    }
                                    s = h.length * a
                                } else {
                                    var y = ".bones[" + t[u].name + "]";
                                    n(pl, y + ".position", c, "pos", r), n(dl, y + ".quaternion", c, "rot", r), n(pl, y + ".scale", c, "scl", r)
                                }
                        }
                        return 0 === r.length ? null : new this(i, s, r, o)
                    }
                }]), e
            }();

            function vl(e) {
                if (void 0 === e.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var t = function (e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return cl;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return pl;
                        case "color":
                            return ul;
                        case "quaternion":
                            return dl;
                        case "bool":
                        case "boolean":
                            return ll;
                        case "string":
                            return fl
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e)
                }(e.type);
                if (void 0 === e.times) {
                    var n = [],
                        r = [];
                    nl(e.keys, n, r, "value"), e.times = n, e.values = r
                }
                return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
            }
            var gl = {
                    enabled: !1,
                    files: {},
                    add: function (e, t) {
                        !1 !== this.enabled && (this.files[e] = t)
                    },
                    get: function (e) {
                        if (!1 !== this.enabled) return this.files[e]
                    },
                    remove: function (e) {
                        delete this.files[e]
                    },
                    clear: function () {
                        this.files = {}
                    }
                },
                _l = o((function e(t, n, r) {
                    i(this, e);
                    var a = this,
                        o = !1,
                        s = 0,
                        l = 0,
                        u = void 0,
                        c = [];
                    this.onStart = void 0, this.onLoad = t, this.onProgress = n, this.onError = r, this.itemStart = function (e) {
                        l++, !1 === o && void 0 !== a.onStart && a.onStart(e, s, l), o = !0
                    }, this.itemEnd = function (e) {
                        s++, void 0 !== a.onProgress && a.onProgress(e, s, l), s === l && (o = !1, void 0 !== a.onLoad && a.onLoad())
                    }, this.itemError = function (e) {
                        void 0 !== a.onError && a.onError(e)
                    }, this.resolveURL = function (e) {
                        return u ? u(e) : e
                    }, this.setURLModifier = function (e) {
                        return u = e, this
                    }, this.addHandler = function (e, t) {
                        return c.push(e, t), this
                    }, this.removeHandler = function (e) {
                        var t = c.indexOf(e);
                        return -1 !== t && c.splice(t, 2), this
                    }, this.getHandler = function (e) {
                        for (var t = 0, n = c.length; t < n; t += 2) {
                            var r = c[t],
                                i = c[t + 1];
                            if (r.global && (r.lastIndex = 0), r.test(e)) return i
                        }
                        return null
                    }
                })),
                yl = new _l,
                xl = function () {
                    function e(t) {
                        i(this, e), this.manager = void 0 !== t ? t : yl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
                    }
                    return o(e, [{
                        key: "load",
                        value: function () {}
                    }, {
                        key: "loadAsync",
                        value: function (e, t) {
                            var n = this;
                            return new Promise((function (r, i) {
                                n.load(e, r, t, i)
                            }))
                        }
                    }, {
                        key: "parse",
                        value: function () {}
                    }, {
                        key: "setCrossOrigin",
                        value: function (e) {
                            return this.crossOrigin = e, this
                        }
                    }, {
                        key: "setWithCredentials",
                        value: function (e) {
                            return this.withCredentials = e, this
                        }
                    }, {
                        key: "setPath",
                        value: function (e) {
                            return this.path = e, this
                        }
                    }, {
                        key: "setResourcePath",
                        value: function (e) {
                            return this.resourcePath = e, this
                        }
                    }, {
                        key: "setRequestHeader",
                        value: function (e) {
                            return this.requestHeader = e, this
                        }
                    }]), e
                }();
            xl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
            var Ml = {},
                Sl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e)).response = r, a
                    }
                    return o(n)
                }(c(Error)),
                El = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        return i(this, n), t.call(this, e)
                    }
                    return o(n, [{
                        key: "load",
                        value: function (e, t, n, r) {
                            var i = this;
                            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                            var a = gl.get(e);
                            if (void 0 !== a) return this.manager.itemStart(e), setTimeout((function () {
                                t && t(a), i.manager.itemEnd(e)
                            }), 0), a;
                            if (void 0 === Ml[e]) {
                                Ml[e] = [], Ml[e].push({
                                    onLoad: t,
                                    onProgress: n,
                                    onError: r
                                });
                                var o = new Request(e, {
                                        headers: new Headers(this.requestHeader),
                                        credentials: this.withCredentials ? "include" : "same-origin"
                                    }),
                                    s = this.mimeType,
                                    l = this.responseType;
                                fetch(o).then((function (t) {
                                    if (200 === t.status || 0 === t.status) {
                                        if (0 === t.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === t.body || void 0 === t.body.getReader) return t;
                                        var n = Ml[e],
                                            r = t.body.getReader(),
                                            i = t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
                                            a = i ? parseInt(i) : 0,
                                            o = 0 !== a,
                                            s = 0,
                                            l = new ReadableStream({
                                                start: function (e) {
                                                    ! function t() {
                                                        r.read().then((function (r) {
                                                            var i = r.done,
                                                                l = r.value;
                                                            if (i) e.close();
                                                            else {
                                                                s += l.byteLength;
                                                                for (var u = new ProgressEvent("progress", {
                                                                        lengthComputable: o,
                                                                        loaded: s,
                                                                        total: a
                                                                    }), c = 0, h = n.length; c < h; c++) {
                                                                    var d = n[c];
                                                                    d.onProgress && d.onProgress(u)
                                                                }
                                                                e.enqueue(l), t()
                                                            }
                                                        }))
                                                    }()
                                                }
                                            });
                                        return new Response(l)
                                    }
                                    throw new Sl('fetch for "'.concat(t.url, '" responded with ').concat(t.status, ": ").concat(t.statusText), t)
                                })).then((function (e) {
                                    switch (l) {
                                        case "arraybuffer":
                                            return e.arrayBuffer();
                                        case "blob":
                                            return e.blob();
                                        case "document":
                                            return e.text().then((function (e) {
                                                return (new DOMParser).parseFromString(e, s)
                                            }));
                                        case "json":
                                            return e.json();
                                        default:
                                            if (void 0 === s) return e.text();
                                            var t = /charset="?([^;"\s]*)"?/i.exec(s),
                                                n = t && t[1] ? t[1].toLowerCase() : void 0,
                                                r = new TextDecoder(n);
                                            return e.arrayBuffer().then((function (e) {
                                                return r.decode(e)
                                            }))
                                    }
                                })).then((function (t) {
                                    gl.add(e, t);
                                    var n = Ml[e];
                                    delete Ml[e];
                                    for (var r = 0, i = n.length; r < i; r++) {
                                        var a = n[r];
                                        a.onLoad && a.onLoad(t)
                                    }
                                })).catch((function (t) {
                                    var n = Ml[e];
                                    if (void 0 === n) throw i.manager.itemError(e), t;
                                    delete Ml[e];
                                    for (var r = 0, a = n.length; r < a; r++) {
                                        var o = n[r];
                                        o.onError && o.onError(t)
                                    }
                                    i.manager.itemError(e)
                                })).finally((function () {
                                    i.manager.itemEnd(e)
                                })), this.manager.itemStart(e)
                            } else Ml[e].push({
                                onLoad: t,
                                onProgress: n,
                                onError: r
                            })
                        }
                    }, {
                        key: "setResponseType",
                        value: function (e) {
                            return this.responseType = e, this
                        }
                    }, {
                        key: "setMimeType",
                        value: function (e) {
                            return this.mimeType = e, this
                        }
                    }]), n
                }(xl),
                Tl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        return i(this, n), t.call(this, e)
                    }
                    return o(n, [{
                        key: "load",
                        value: function (e, t, n, r) {
                            void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                            var i = this,
                                a = gl.get(e);
                            if (void 0 !== a) return i.manager.itemStart(e), setTimeout((function () {
                                t && t(a), i.manager.itemEnd(e)
                            }), 0), a;
                            var o = Et("img");

                            function s() {
                                u(), gl.add(e, this), t && t(this), i.manager.itemEnd(e)
                            }

                            function l(t) {
                                u(), r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                            }

                            function u() {
                                o.removeEventListener("load", s, !1), o.removeEventListener("error", l, !1)
                            }
                            return o.addEventListener("load", s, !1), o.addEventListener("error", l, !1), "data:" !== e.slice(0, 5) && void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin), i.manager.itemStart(e), o.src = e, o
                        }
                    }]), n
                }(xl),
                bl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        return i(this, n), t.call(this, e)
                    }
                    return o(n, [{
                        key: "load",
                        value: function (e, t, n, r) {
                            var i = new Bt,
                                a = new Tl(this.manager);
                            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, (function (e) {
                                i.image = e, i.needsUpdate = !0, void 0 !== t && t(i)
                            }), n, r), i
                        }
                    }]), n
                }(xl),
                Al = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r, a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
                        return i(this, n), (r = t.call(this)).isLight = !0, r.type = "Light", r.color = new fr(e), r.intensity = a, r
                    }
                    return o(n, [{
                        key: "dispose",
                        value: function () {}
                    }, {
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.color.copy(e.color), this.intensity = e.intensity, this
                        }
                    }, {
                        key: "toJSON",
                        value: function (e) {
                            var t = g(y(n.prototype), "toJSON", this).call(this, e);
                            return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
                        }
                    }]), n
                }(Yn),
                wl = new En,
                Rl = new Xt,
                Cl = new Xt,
                Ll = function () {
                    function e(t) {
                        i(this, e), this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new yt(512, 512), this.map = null, this.mapPass = null, this.matrix = new En, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new fi, this._frameExtents = new yt(1, 1), this._viewportCount = 1, this._viewports = [new zt(0, 0, 1, 1)]
                    }
                    return o(e, [{
                        key: "getViewportCount",
                        value: function () {
                            return this._viewportCount
                        }
                    }, {
                        key: "getFrustum",
                        value: function () {
                            return this._frustum
                        }
                    }, {
                        key: "updateMatrices",
                        value: function (e) {
                            var t = this.camera,
                                n = this.matrix;
                            Rl.setFromMatrixPosition(e.matrixWorld), t.position.copy(Rl), Cl.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Cl), t.updateMatrixWorld(), wl.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(wl), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(wl)
                        }
                    }, {
                        key: "getViewport",
                        value: function (e) {
                            return this._viewports[e]
                        }
                    }, {
                        key: "getFrameExtents",
                        value: function () {
                            return this._frameExtents
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                        }
                    }, {
                        key: "clone",
                        value: function () {
                            return (new this.constructor).copy(this)
                        }
                    }, {
                        key: "toJSON",
                        value: function () {
                            var e = {};
                            return 0 !== this.bias && (e.bias = this.bias), 0 !== this.normalBias && (e.normalBias = this.normalBias), 1 !== this.radius && (e.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
                        }
                    }]), e
                }(),
                Pl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this, new ni(50, 1, .5, 500))).isSpotLightShadow = !0, e.focus = 1, e
                    }
                    return o(n, [{
                        key: "updateMatrices",
                        value: function (e) {
                            var t = this.camera,
                                r = 2 * lt * e.angle * this.focus,
                                i = this.mapSize.width / this.mapSize.height,
                                a = e.distance || t.far;
                            r === t.fov && i === t.aspect && a === t.far || (t.fov = r, t.aspect = i, t.far = a, t.updateProjectionMatrix()), g(y(n.prototype), "updateMatrices", this).call(this, e)
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.focus = e.focus, this
                        }
                    }]), n
                }(Ll),
                kl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Math.PI / 3,
                            l = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                            u = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 2;
                        return i(this, n), (a = t.call(this, e, r)).isSpotLight = !0, a.type = "SpotLight", a.position.copy(Yn.DEFAULT_UP), a.updateMatrix(), a.target = new Yn, a.distance = o, a.angle = s, a.penumbra = l, a.decay = u, a.map = null, a.shadow = new Pl, a
                    }
                    return o(n, [{
                        key: "power",
                        get: function () {
                            return this.intensity * Math.PI
                        },
                        set: function (e) {
                            this.intensity = e / Math.PI
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.shadow.dispose()
                        }
                    }, {
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                        }
                    }]), n
                }(Al),
                Il = new En,
                Ul = new Xt,
                Dl = new Xt,
                Nl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this, new ni(90, 1, .5, 500))).isPointLightShadow = !0, e._frameExtents = new yt(4, 2), e._viewportCount = 6, e._viewports = [new zt(2, 1, 1, 1), new zt(0, 1, 1, 1), new zt(3, 1, 1, 1), new zt(1, 1, 1, 1), new zt(3, 0, 1, 1), new zt(1, 0, 1, 1)], e._cubeDirections = [new Xt(1, 0, 0), new Xt(-1, 0, 0), new Xt(0, 0, 1), new Xt(0, 0, -1), new Xt(0, 1, 0), new Xt(0, -1, 0)], e._cubeUps = [new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 1, 0), new Xt(0, 0, 1), new Xt(0, 0, -1)], e
                    }
                    return o(n, [{
                        key: "updateMatrices",
                        value: function (e) {
                            var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                n = this.camera,
                                r = this.matrix,
                                i = e.distance || n.far;
                            i !== n.far && (n.far = i, n.updateProjectionMatrix()), Ul.setFromMatrixPosition(e.matrixWorld), n.position.copy(Ul), Dl.copy(n.position), Dl.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Dl), n.updateMatrixWorld(), r.makeTranslation(-Ul.x, -Ul.y, -Ul.z), Il.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Il)
                        }
                    }]), n
                }(Ll),
                Ol = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                            s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 2;
                        return i(this, n), (a = t.call(this, e, r)).isPointLight = !0, a.type = "PointLight", a.distance = o, a.decay = s, a.shadow = new Nl, a
                    }
                    return o(n, [{
                        key: "power",
                        get: function () {
                            return 4 * this.intensity * Math.PI
                        },
                        set: function (e) {
                            this.intensity = e / (4 * Math.PI)
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            this.shadow.dispose()
                        }
                    }, {
                        key: "copy",
                        value: function (e, t) {
                            return g(y(n.prototype), "copy", this).call(this, e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
                        }
                    }]), n
                }(Al),
                Fl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        var e;
                        return i(this, n), (e = t.call(this, new wi(-5, 5, 5, -5, .5, 500))).isDirectionalLightShadow = !0, e
                    }
                    return o(n)
                }(Ll),
                Bl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e, r)).isDirectionalLight = !0, a.type = "DirectionalLight", a.position.copy(Yn.DEFAULT_UP), a.updateMatrix(), a.target = new Yn, a.shadow = new Fl, a
                    }
                    return o(n, [{
                        key: "dispose",
                        value: function () {
                            this.shadow.dispose()
                        }
                    }, {
                        key: "copy",
                        value: function (e) {
                            return g(y(n.prototype), "copy", this).call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
                        }
                    }]), n
                }(Al),
                zl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a;
                        return i(this, n), (a = t.call(this, e, r)).isAmbientLight = !0, a.type = "AmbientLight", a
                    }
                    return o(n)
                }(Al),
                Hl = function () {
                    function e() {
                        i(this, e)
                    }
                    return o(e, null, [{
                        key: "decodeText",
                        value: function (e) {
                            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(e);
                            for (var t = "", n = 0, r = e.length; n < r; n++) t += String.fromCharCode(e[n]);
                            try {
                                return decodeURIComponent(escape(t))
                            } catch (e) {
                                return t
                            }
                        }
                    }, {
                        key: "extractUrlBase",
                        value: function (e) {
                            var t = e.lastIndexOf("/");
                            return -1 === t ? "./" : e.slice(0, t + 1)
                        }
                    }, {
                        key: "resolveURL",
                        value: function (e, t) {
                            return "string" != typeof e || "" === e ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
                        }
                    }]), e
                }(),
                Gl = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this, e)).isImageBitmapLoader = !0, "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), r.options = {
                            premultiplyAlpha: "none"
                        }, r
                    }
                    return o(n, [{
                        key: "setOptions",
                        value: function (e) {
                            return this.options = e, this
                        }
                    }, {
                        key: "load",
                        value: function (e, t, n, r) {
                            void 0 === e && (e = ""), void 0 !== this.path && (e = this.path + e), e = this.manager.resolveURL(e);
                            var i = this,
                                a = gl.get(e);
                            if (void 0 !== a) return i.manager.itemStart(e), setTimeout((function () {
                                t && t(a), i.manager.itemEnd(e)
                            }), 0), a;
                            var o = {};
                            o.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", o.headers = this.requestHeader, fetch(e, o).then((function (e) {
                                return e.blob()
                            })).then((function (e) {
                                return createImageBitmap(e, Object.assign(i.options, {
                                    colorSpaceConversion: "none"
                                }))
                            })).then((function (n) {
                                gl.add(e, n), t && t(n), i.manager.itemEnd(e)
                            })).catch((function (t) {
                                r && r(t), i.manager.itemError(e), i.manager.itemEnd(e)
                            })), i.manager.itemStart(e)
                        }
                    }]), n
                }(xl);
            var Vl = "\\[\\]\\.:\\/",
                Wl = new RegExp("[" + Vl + "]", "g"),
                jl = "[^" + Vl + "]",
                Xl = "[^" + Vl.replace("\\.", "") + "]",
                ql = new RegExp("^" + /((?:WC+[\/:])*)/.source.replace("WC", jl) + /(WCOD+)?/.source.replace("WCOD", Xl) + /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", jl) + /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", jl) + "$"),
                Yl = ["material", "materials", "bones", "map"],
                Kl = function () {
                    function e(t, n, r) {
                        i(this, e);
                        var a = r || Zl.parseTrackName(n);
                        this._targetGroup = t, this._bindings = t.subscribe_(n, a)
                    }
                    return o(e, [{
                        key: "getValue",
                        value: function (e, t) {
                            this.bind();
                            var n = this._targetGroup.nCachedObjects_,
                                r = this._bindings[n];
                            void 0 !== r && r.getValue(e, t)
                        }
                    }, {
                        key: "setValue",
                        value: function (e, t) {
                            for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(e, t)
                        }
                    }, {
                        key: "bind",
                        value: function () {
                            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
                        }
                    }, {
                        key: "unbind",
                        value: function () {
                            for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
                        }
                    }]), e
                }(),
                Zl = function () {
                    function e(t, n, r) {
                        i(this, e), this.path = n, this.parsedPath = r || e.parseTrackName(n), this.node = e.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                    }
                    return o(e, [{
                        key: "_getValue_unavailable",
                        value: function () {}
                    }, {
                        key: "_setValue_unavailable",
                        value: function () {}
                    }, {
                        key: "_getValue_direct",
                        value: function (e, t) {
                            e[t] = this.targetObject[this.propertyName]
                        }
                    }, {
                        key: "_getValue_array",
                        value: function (e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) e[t++] = n[r]
                        }
                    }, {
                        key: "_getValue_arrayElement",
                        value: function (e, t) {
                            e[t] = this.resolvedProperty[this.propertyIndex]
                        }
                    }, {
                        key: "_getValue_toArray",
                        value: function (e, t) {
                            this.resolvedProperty.toArray(e, t)
                        }
                    }, {
                        key: "_setValue_direct",
                        value: function (e, t) {
                            this.targetObject[this.propertyName] = e[t]
                        }
                    }, {
                        key: "_setValue_direct_setNeedsUpdate",
                        value: function (e, t) {
                            this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_direct_setMatrixWorldNeedsUpdate",
                        value: function (e, t) {
                            this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_array",
                        value: function (e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++]
                        }
                    }, {
                        key: "_setValue_array_setNeedsUpdate",
                        value: function (e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                            this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_array_setMatrixWorldNeedsUpdate",
                        value: function (e, t) {
                            for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = e[t++];
                            this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_arrayElement",
                        value: function (e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t]
                        }
                    }, {
                        key: "_setValue_arrayElement_setNeedsUpdate",
                        value: function (e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
                        value: function (e, t) {
                            this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_setValue_fromArray",
                        value: function (e, t) {
                            this.resolvedProperty.fromArray(e, t)
                        }
                    }, {
                        key: "_setValue_fromArray_setNeedsUpdate",
                        value: function (e, t) {
                            this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                        }
                    }, {
                        key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
                        value: function (e, t) {
                            this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                        }
                    }, {
                        key: "_getValue_unbound",
                        value: function (e, t) {
                            this.bind(), this.getValue(e, t)
                        }
                    }, {
                        key: "_setValue_unbound",
                        value: function (e, t) {
                            this.bind(), this.setValue(e, t)
                        }
                    }, {
                        key: "bind",
                        value: function () {
                            var t = this.node,
                                n = this.parsedPath,
                                r = n.objectName,
                                i = n.propertyName,
                                a = n.propertyIndex;
                            if (t || (t = e.findNode(this.rootNode, n.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                                if (r) {
                                    var o = n.objectIndex;
                                    switch (r) {
                                        case "materials":
                                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                            t = t.material.materials;
                                            break;
                                        case "bones":
                                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                            t = t.skeleton.bones;
                                            for (var s = 0; s < t.length; s++)
                                                if (t[s].name === o) {
                                                    o = s;
                                                    break
                                                } break;
                                        case "map":
                                            if ("map" in t) {
                                                t = t.map;
                                                break
                                            }
                                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                            if (!t.material.map) return void console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                                            t = t.material.map;
                                            break;
                                        default:
                                            if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                            t = t[r]
                                    }
                                    if (void 0 !== o) {
                                        if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                        t = t[o]
                                    }
                                }
                                var l = t[i];
                                if (void 0 !== l) {
                                    var u = this.Versioning.None;
                                    this.targetObject = t, void 0 !== t.needsUpdate ? u = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (u = this.Versioning.MatrixWorldNeedsUpdate);
                                    var c = this.BindingType.Direct;
                                    if (void 0 !== a) {
                                        if ("morphTargetInfluences" === i) {
                                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                            if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                            void 0 !== t.morphTargetDictionary[a] && (a = t.morphTargetDictionary[a])
                                        }
                                        c = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = a
                                    } else void 0 !== l.fromArray && void 0 !== l.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (c = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = i;
                                    this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][u]
                                } else {
                                    var h = n.nodeName;
                                    console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + i + " but it wasn't found.", t)
                                }
                            } else console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".")
                        }
                    }, {
                        key: "unbind",
                        value: function () {
                            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                        }
                    }], [{
                        key: "create",
                        value: function (t, n, r) {
                            return t && t.isAnimationObjectGroup ? new e.Composite(t, n, r) : new e(t, n, r)
                        }
                    }, {
                        key: "sanitizeNodeName",
                        value: function (e) {
                            return e.replace(/\s/g, "_").replace(Wl, "")
                        }
                    }, {
                        key: "parseTrackName",
                        value: function (e) {
                            var t = ql.exec(e);
                            if (null === t) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
                            var n = {
                                    nodeName: t[2],
                                    objectName: t[3],
                                    objectIndex: t[4],
                                    propertyName: t[5],
                                    propertyIndex: t[6]
                                },
                                r = n.nodeName && n.nodeName.lastIndexOf(".");
                            if (void 0 !== r && -1 !== r) {
                                var i = n.nodeName.substring(r + 1); - 1 !== Yl.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                            }
                            if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
                            return n
                        }
                    }, {
                        key: "findNode",
                        value: function (e, t) {
                            if (void 0 === t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                            if (e.skeleton) {
                                var n = e.skeleton.getBoneByName(t);
                                if (void 0 !== n) return n
                            }
                            if (e.children) {
                                var r = function e(n) {
                                    for (var r = 0; r < n.length; r++) {
                                        var i = n[r];
                                        if (i.name === t || i.uuid === t) return i;
                                        var a = e(i.children);
                                        if (a) return a
                                    }
                                    return null
                                }(e.children);
                                if (r) return r
                            }
                            return null
                        }
                    }]), e
                }();
            Zl.Composite = Kl, Zl.prototype.BindingType = {
                Direct: 0,
                EntireArray: 1,
                ArrayElement: 2,
                HasFromToArray: 3
            }, Zl.prototype.Versioning = {
                None: 0,
                NeedsUpdate: 1,
                MatrixWorldNeedsUpdate: 2
            }, Zl.prototype.GetterByBindingType = [Zl.prototype._getValue_direct, Zl.prototype._getValue_array, Zl.prototype._getValue_arrayElement, Zl.prototype._getValue_toArray], Zl.prototype.SetterByBindingTypeAndVersioning = [
                [Zl.prototype._setValue_direct, Zl.prototype._setValue_direct_setNeedsUpdate, Zl.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
                [Zl.prototype._setValue_array, Zl.prototype._setValue_array_setNeedsUpdate, Zl.prototype._setValue_array_setMatrixWorldNeedsUpdate],
                [Zl.prototype._setValue_arrayElement, Zl.prototype._setValue_arrayElement_setNeedsUpdate, Zl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
                [Zl.prototype._setValue_fromArray, Zl.prototype._setValue_fromArray_setNeedsUpdate, Zl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
            ];
            new Float32Array(1);
            var Jl = function () {
                function e(t, n) {
                    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                        a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1 / 0;
                    i(this, e), this.ray = new Sn(t, n), this.near = r, this.far = a, this.camera = null, this.layers = new Un, this.params = {
                        Mesh: {},
                        Line: {
                            threshold: 1
                        },
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }
                }
                return o(e, [{
                    key: "set",
                    value: function (e, t) {
                        this.ray.set(e, t)
                    }
                }, {
                    key: "setFromCamera",
                    value: function (e, t) {
                        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
                    }
                }, {
                    key: "intersectObject",
                    value: function (e) {
                        var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                        return $l(e, this, n, t), n.sort(Ql), n
                    }
                }, {
                    key: "intersectObjects",
                    value: function (e) {
                        for (var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [], r = 0, i = e.length; r < i; r++) $l(e[r], this, n, t);
                        return n.sort(Ql), n
                    }
                }]), e
            }();

            function Ql(e, t) {
                return e.distance - t.distance
            }

            function $l(e, t, n, r) {
                if (e.layers.test(t.layers) && e.raycast(t, n), !0 === r)
                    for (var i = e.children, a = 0, o = i.length; a < o; a++) $l(i[a], t, n, !0)
            }
            var eu = function () {
                function e() {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                        n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
                    return i(this, e), this.radius = t, this.phi = n, this.theta = r, this
                }
                return o(e, [{
                    key: "set",
                    value: function (e, t, n) {
                        return this.radius = e, this.phi = t, this.theta = n, this
                    }
                }, {
                    key: "copy",
                    value: function (e) {
                        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
                    }
                }, {
                    key: "makeSafe",
                    value: function () {
                        var e = 1e-6;
                        return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)), this
                    }
                }, {
                    key: "setFromVector3",
                    value: function (e) {
                        return this.setFromCartesianCoords(e.x, e.y, e.z)
                    }
                }, {
                    key: "setFromCartesianCoords",
                    value: function (e, t, n) {
                        return this.radius = Math.sqrt(e * e + t * t + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(ct(t / this.radius, -1, 1))), this
                    }
                }, {
                    key: "clone",
                    value: function () {
                        return (new this.constructor).copy(this)
                    }
                }]), e
            }();
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
                detail: {
                    revision: R
                }
            })), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = R);
            var tu, nu, ru, iu = {
                    type: "change"
                },
                au = {
                    type: "start"
                },
                ou = {
                    type: "end"
                },
                su = new Sn,
                lu = new ci,
                uu = Math.cos(70 * _t.DEG2RAD),
                cu = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r) {
                        var a, o, s, l, u, c, h, d;
                        i(this, n), (a = t.call(this)).object = e, a.domElement = r, a.domElement.style.touchAction = "none", a.enabled = !0, a.target = new Xt, a.minDistance = 0, a.maxDistance = 1 / 0, a.minZoom = 0, a.maxZoom = 1 / 0, a.minPolarAngle = 0, a.maxPolarAngle = Math.PI, a.minAzimuthAngle = -1 / 0, a.maxAzimuthAngle = 1 / 0, a.enableDamping = !1, a.dampingFactor = .05, a.enableZoom = !0, a.zoomSpeed = 1, a.enableRotate = !0, a.rotateSpeed = 1, a.enablePan = !0, a.panSpeed = 1, a.screenSpacePanning = !0, a.keyPanSpeed = 7, a.zoomToCursor = !1, a.autoRotate = !1, a.autoRotateSpeed = 2, a.keys = {
                            LEFT: "ArrowLeft",
                            UP: "ArrowUp",
                            RIGHT: "ArrowRight",
                            BOTTOM: "ArrowDown"
                        }, a.mouseButtons = {
                            LEFT: C,
                            MIDDLE: L,
                            RIGHT: P
                        }, a.touches = {
                            ONE: k,
                            TWO: U
                        }, a.target0 = a.target.clone(), a.position0 = a.object.position.clone(), a.zoom0 = a.object.zoom, a._domElementKeyEvents = null, a.getPolarAngle = function () {
                            return g.phi
                        }, a.getAzimuthalAngle = function () {
                            return g.theta
                        }, a.getDistance = function () {
                            return this.object.position.distanceTo(this.target)
                        }, a.listenToKeyEvents = function (e) {
                            e.addEventListener("keydown", de), this._domElementKeyEvents = e
                        }, a.stopListenToKeyEvents = function () {
                            this._domElementKeyEvents.removeEventListener("keydown", de), this._domElementKeyEvents = null
                        }, a.saveState = function () {
                            f.target0.copy(f.target), f.position0.copy(f.object.position), f.zoom0 = f.object.zoom
                        }, a.reset = function () {
                            f.target.copy(f.target0), f.object.position.copy(f.position0), f.object.zoom = f.zoom0, f.object.updateProjectionMatrix(), f.dispatchEvent(iu), f.update(), m = p.NONE
                        }, a.update = (o = new Xt, s = (new jt).setFromUnitVectors(e.up, new Xt(0, 1, 0)), l = s.clone().invert(), u = new Xt, c = new jt, h = new Xt, d = 2 * Math.PI, function () {
                            var t = f.object.position;
                            o.copy(t).sub(f.target), o.applyQuaternion(s), g.setFromVector3(o), f.autoRotate && m === p.NONE && W(2 * Math.PI / 60 / 60 * f.autoRotateSpeed), f.enableDamping ? (g.theta += _.theta * f.dampingFactor, g.phi += _.phi * f.dampingFactor) : (g.theta += _.theta, g.phi += _.phi);
                            var n = f.minAzimuthAngle,
                                r = f.maxAzimuthAngle;
                            isFinite(n) && isFinite(r) && (n < -Math.PI ? n += d : n > Math.PI && (n -= d), r < -Math.PI ? r += d : r > Math.PI && (r -= d), g.theta = n <= r ? Math.max(n, Math.min(r, g.theta)) : g.theta > (n + r) / 2 ? Math.max(n, g.theta) : Math.min(r, g.theta)), g.phi = Math.max(f.minPolarAngle, Math.min(f.maxPolarAngle, g.phi)), g.makeSafe(), !0 === f.enableDamping ? f.target.addScaledVector(x, f.dampingFactor) : f.target.add(x), f.zoomToCursor && z || f.object.isOrthographicCamera ? g.radius = $(g.radius) : g.radius = $(g.radius * y), o.setFromSpherical(g), o.applyQuaternion(l), t.copy(f.target).add(o), f.object.lookAt(f.target), !0 === f.enableDamping ? (_.theta *= 1 - f.dampingFactor, _.phi *= 1 - f.dampingFactor, x.multiplyScalar(1 - f.dampingFactor)) : (_.set(0, 0, 0), x.set(0, 0, 0));
                            var i = !1;
                            if (f.zoomToCursor && z) {
                                var a = null;
                                if (f.object.isPerspectiveCamera) {
                                    var M = o.length(),
                                        S = M - (a = $(M * y));
                                    f.object.position.addScaledVector(F, S), f.object.updateMatrixWorld()
                                } else if (f.object.isOrthographicCamera) {
                                    var E = new Xt(B.x, B.y, 0);
                                    E.unproject(f.object), f.object.zoom = Math.max(f.minZoom, Math.min(f.maxZoom, f.object.zoom / y)), f.object.updateProjectionMatrix(), i = !0;
                                    var T = new Xt(B.x, B.y, 0);
                                    T.unproject(f.object), f.object.position.sub(T).add(E), f.object.updateMatrixWorld(), a = o.length()
                                } else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), f.zoomToCursor = !1;
                                null !== a && (this.screenSpacePanning ? f.target.set(0, 0, -1).transformDirection(f.object.matrix).multiplyScalar(a).add(f.object.position) : (su.origin.copy(f.object.position), su.direction.set(0, 0, -1).transformDirection(f.object.matrix), Math.abs(f.object.up.dot(su.direction)) < uu ? e.lookAt(f.target) : (lu.setFromNormalAndCoplanarPoint(f.object.up, f.target), su.intersectPlane(lu, f.target))))
                            } else f.object.isOrthographicCamera && (f.object.zoom = Math.max(f.minZoom, Math.min(f.maxZoom, f.object.zoom / y)), f.object.updateProjectionMatrix(), i = !0);
                            return y = 1, z = !1, !!(i || u.distanceToSquared(f.object.position) > v || 8 * (1 - c.dot(f.object.quaternion)) > v || h.distanceToSquared(f.target) > 0) && (f.dispatchEvent(iu), u.copy(f.object.position), c.copy(f.object.quaternion), h.copy(f.target), i = !1, !0)
                        }), a.dispose = function () {
                            f.domElement.removeEventListener("contextmenu", fe), f.domElement.removeEventListener("pointerdown", le), f.domElement.removeEventListener("pointercancel", ce), f.domElement.removeEventListener("wheel", he), f.domElement.removeEventListener("pointermove", ue), f.domElement.removeEventListener("pointerup", ce), null !== f._domElementKeyEvents && (f._domElementKeyEvents.removeEventListener("keydown", de), f._domElementKeyEvents = null)
                        };
                        var f = M(a),
                            p = {
                                NONE: -1,
                                ROTATE: 0,
                                DOLLY: 1,
                                PAN: 2,
                                TOUCH_ROTATE: 3,
                                TOUCH_PAN: 4,
                                TOUCH_DOLLY_PAN: 5,
                                TOUCH_DOLLY_ROTATE: 6
                            },
                            m = p.NONE,
                            v = 1e-6,
                            g = new eu,
                            _ = new eu,
                            y = 1,
                            x = new Xt,
                            S = new yt,
                            E = new yt,
                            T = new yt,
                            b = new yt,
                            A = new yt,
                            w = new yt,
                            R = new yt,
                            N = new yt,
                            O = new yt,
                            F = new Xt,
                            B = new yt,
                            z = !1,
                            H = [],
                            G = {};

                        function V() {
                            return Math.pow(.95, f.zoomSpeed)
                        }

                        function W(e) {
                            _.theta -= e
                        }

                        function j(e) {
                            _.phi -= e
                        }
                        var X, q = (X = new Xt, function (e, t) {
                                X.setFromMatrixColumn(t, 0), X.multiplyScalar(-e), x.add(X)
                            }),
                            Y = function () {
                                var e = new Xt;
                                return function (t, n) {
                                    !0 === f.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0), e.crossVectors(f.object.up, e)), e.multiplyScalar(t), x.add(e)
                                }
                            }(),
                            K = function () {
                                var e = new Xt;
                                return function (t, n) {
                                    var r = f.domElement;
                                    if (f.object.isPerspectiveCamera) {
                                        var i = f.object.position;
                                        e.copy(i).sub(f.target);
                                        var a = e.length();
                                        a *= Math.tan(f.object.fov / 2 * Math.PI / 180), q(2 * t * a / r.clientHeight, f.object.matrix), Y(2 * n * a / r.clientHeight, f.object.matrix)
                                    } else f.object.isOrthographicCamera ? (q(t * (f.object.right - f.object.left) / f.object.zoom / r.clientWidth, f.object.matrix), Y(n * (f.object.top - f.object.bottom) / f.object.zoom / r.clientHeight, f.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), f.enablePan = !1)
                                }
                            }();

                        function Z(e) {
                            f.object.isPerspectiveCamera || f.object.isOrthographicCamera ? y /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), f.enableZoom = !1)
                        }

                        function J(e) {
                            f.object.isPerspectiveCamera || f.object.isOrthographicCamera ? y *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), f.enableZoom = !1)
                        }

                        function Q(t) {
                            if (f.zoomToCursor) {
                                z = !0;
                                var n = f.domElement.getBoundingClientRect(),
                                    r = t.clientX - n.left,
                                    i = t.clientY - n.top,
                                    a = n.width,
                                    o = n.height;
                                B.x = r / a * 2 - 1, B.y = -i / o * 2 + 1, F.set(B.x, B.y, 1).unproject(e).sub(e.position).normalize()
                            }
                        }

                        function $(e) {
                            return Math.max(f.minDistance, Math.min(f.maxDistance, e))
                        }

                        function ee(e) {
                            S.set(e.clientX, e.clientY)
                        }

                        function te(e) {
                            b.set(e.clientX, e.clientY)
                        }

                        function ne() {
                            if (1 === H.length) S.set(H[0].pageX, H[0].pageY);
                            else {
                                var e = .5 * (H[0].pageX + H[1].pageX),
                                    t = .5 * (H[0].pageY + H[1].pageY);
                                S.set(e, t)
                            }
                        }

                        function re() {
                            if (1 === H.length) b.set(H[0].pageX, H[0].pageY);
                            else {
                                var e = .5 * (H[0].pageX + H[1].pageX),
                                    t = .5 * (H[0].pageY + H[1].pageY);
                                b.set(e, t)
                            }
                        }

                        function ie() {
                            var e = H[0].pageX - H[1].pageX,
                                t = H[0].pageY - H[1].pageY,
                                n = Math.sqrt(e * e + t * t);
                            R.set(0, n)
                        }

                        function ae(e) {
                            if (1 == H.length) E.set(e.pageX, e.pageY);
                            else {
                                var t = me(e),
                                    n = .5 * (e.pageX + t.x),
                                    r = .5 * (e.pageY + t.y);
                                E.set(n, r)
                            }
                            T.subVectors(E, S).multiplyScalar(f.rotateSpeed);
                            var i = f.domElement;
                            W(2 * Math.PI * T.x / i.clientHeight), j(2 * Math.PI * T.y / i.clientHeight), S.copy(E)
                        }

                        function oe(e) {
                            if (1 === H.length) A.set(e.pageX, e.pageY);
                            else {
                                var t = me(e),
                                    n = .5 * (e.pageX + t.x),
                                    r = .5 * (e.pageY + t.y);
                                A.set(n, r)
                            }
                            w.subVectors(A, b).multiplyScalar(f.panSpeed), K(w.x, w.y), b.copy(A)
                        }

                        function se(e) {
                            var t = me(e),
                                n = e.pageX - t.x,
                                r = e.pageY - t.y,
                                i = Math.sqrt(n * n + r * r);
                            N.set(0, i), O.set(0, Math.pow(N.y / R.y, f.zoomSpeed)), Z(O.y), R.copy(N)
                        }

                        function le(e) {
                            !1 !== f.enabled && (0 === H.length && (f.domElement.setPointerCapture(e.pointerId), f.domElement.addEventListener("pointermove", ue), f.domElement.addEventListener("pointerup", ce)), function (e) {
                                H.push(e)
                            }(e), "touch" === e.pointerType ? function (e) {
                                switch (pe(e), H.length) {
                                    case 1:
                                        switch (f.touches.ONE) {
                                            case k:
                                                if (!1 === f.enableRotate) return;
                                                ne(), m = p.TOUCH_ROTATE;
                                                break;
                                            case I:
                                                if (!1 === f.enablePan) return;
                                                re(), m = p.TOUCH_PAN;
                                                break;
                                            default:
                                                m = p.NONE
                                        }
                                        break;
                                    case 2:
                                        switch (f.touches.TWO) {
                                            case U:
                                                if (!1 === f.enableZoom && !1 === f.enablePan) return;
                                                f.enableZoom && ie(), f.enablePan && re(), m = p.TOUCH_DOLLY_PAN;
                                                break;
                                            case D:
                                                if (!1 === f.enableZoom && !1 === f.enableRotate) return;
                                                f.enableZoom && ie(), f.enableRotate && ne(), m = p.TOUCH_DOLLY_ROTATE;
                                                break;
                                            default:
                                                m = p.NONE
                                        }
                                        break;
                                    default:
                                        m = p.NONE
                                }
                                m !== p.NONE && f.dispatchEvent(au)
                            }(e) : function (e) {
                                var t;
                                switch (e.button) {
                                    case 0:
                                        t = f.mouseButtons.LEFT;
                                        break;
                                    case 1:
                                        t = f.mouseButtons.MIDDLE;
                                        break;
                                    case 2:
                                        t = f.mouseButtons.RIGHT;
                                        break;
                                    default:
                                        t = -1
                                }
                                switch (t) {
                                    case L:
                                        if (!1 === f.enableZoom) return;
                                        ! function (e) {
                                            Q(e), R.set(e.clientX, e.clientY)
                                        }(e), m = p.DOLLY;
                                        break;
                                    case C:
                                        if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                            if (!1 === f.enablePan) return;
                                            te(e), m = p.PAN
                                        } else {
                                            if (!1 === f.enableRotate) return;
                                            ee(e), m = p.ROTATE
                                        }
                                        break;
                                    case P:
                                        if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                            if (!1 === f.enableRotate) return;
                                            ee(e), m = p.ROTATE
                                        } else {
                                            if (!1 === f.enablePan) return;
                                            te(e), m = p.PAN
                                        }
                                        break;
                                    default:
                                        m = p.NONE
                                }
                                m !== p.NONE && f.dispatchEvent(au)
                            }(e))
                        }

                        function ue(e) {
                            !1 !== f.enabled && ("touch" === e.pointerType ? function (e) {
                                switch (pe(e), m) {
                                    case p.TOUCH_ROTATE:
                                        if (!1 === f.enableRotate) return;
                                        ae(e), f.update();
                                        break;
                                    case p.TOUCH_PAN:
                                        if (!1 === f.enablePan) return;
                                        oe(e), f.update();
                                        break;
                                    case p.TOUCH_DOLLY_PAN:
                                        if (!1 === f.enableZoom && !1 === f.enablePan) return;
                                        ! function (e) {
                                            f.enableZoom && se(e), f.enablePan && oe(e)
                                        }(e), f.update();
                                        break;
                                    case p.TOUCH_DOLLY_ROTATE:
                                        if (!1 === f.enableZoom && !1 === f.enableRotate) return;
                                        ! function (e) {
                                            f.enableZoom && se(e), f.enableRotate && ae(e)
                                        }(e), f.update();
                                        break;
                                    default:
                                        m = p.NONE
                                }
                            }(e) : function (e) {
                                switch (m) {
                                    case p.ROTATE:
                                        if (!1 === f.enableRotate) return;
                                        ! function (e) {
                                            E.set(e.clientX, e.clientY), T.subVectors(E, S).multiplyScalar(f.rotateSpeed);
                                            var t = f.domElement;
                                            W(2 * Math.PI * T.x / t.clientHeight), j(2 * Math.PI * T.y / t.clientHeight), S.copy(E), f.update()
                                        }(e);
                                        break;
                                    case p.DOLLY:
                                        if (!1 === f.enableZoom) return;
                                        ! function (e) {
                                            N.set(e.clientX, e.clientY), O.subVectors(N, R), O.y > 0 ? Z(V()) : O.y < 0 && J(V()), R.copy(N), f.update()
                                        }(e);
                                        break;
                                    case p.PAN:
                                        if (!1 === f.enablePan) return;
                                        ! function (e) {
                                            A.set(e.clientX, e.clientY), w.subVectors(A, b).multiplyScalar(f.panSpeed), K(w.x, w.y), b.copy(A), f.update()
                                        }(e)
                                }
                            }(e))
                        }

                        function ce(e) {
                            ! function (e) {
                                delete G[e.pointerId];
                                for (var t = 0; t < H.length; t++)
                                    if (H[t].pointerId == e.pointerId) return void H.splice(t, 1)
                            }(e), 0 === H.length && (f.domElement.releasePointerCapture(e.pointerId), f.domElement.removeEventListener("pointermove", ue), f.domElement.removeEventListener("pointerup", ce)), f.dispatchEvent(ou), m = p.NONE
                        }

                        function he(e) {
                            !1 !== f.enabled && !1 !== f.enableZoom && m === p.NONE && (e.preventDefault(), f.dispatchEvent(au), function (e) {
                                Q(e), e.deltaY < 0 ? J(V()) : e.deltaY > 0 && Z(V()), f.update()
                            }(e), f.dispatchEvent(ou))
                        }

                        function de(e) {
                            !1 !== f.enabled && !1 !== f.enablePan && function (e) {
                                var t = !1;
                                switch (e.code) {
                                    case f.keys.UP:
                                        e.ctrlKey || e.metaKey || e.shiftKey ? j(2 * Math.PI * f.rotateSpeed / f.domElement.clientHeight) : K(0, f.keyPanSpeed), t = !0;
                                        break;
                                    case f.keys.BOTTOM:
                                        e.ctrlKey || e.metaKey || e.shiftKey ? j(-2 * Math.PI * f.rotateSpeed / f.domElement.clientHeight) : K(0, -f.keyPanSpeed), t = !0;
                                        break;
                                    case f.keys.LEFT:
                                        e.ctrlKey || e.metaKey || e.shiftKey ? W(2 * Math.PI * f.rotateSpeed / f.domElement.clientHeight) : K(f.keyPanSpeed, 0), t = !0;
                                        break;
                                    case f.keys.RIGHT:
                                        e.ctrlKey || e.metaKey || e.shiftKey ? W(-2 * Math.PI * f.rotateSpeed / f.domElement.clientHeight) : K(-f.keyPanSpeed, 0), t = !0
                                }
                                t && (e.preventDefault(), f.update())
                            }(e)
                        }

                        function fe(e) {
                            !1 !== f.enabled && e.preventDefault()
                        }

                        function pe(e) {
                            var t = G[e.pointerId];
                            void 0 === t && (t = new yt, G[e.pointerId] = t), t.set(e.pageX, e.pageY)
                        }

                        function me(e) {
                            var t = e.pointerId === H[0].pointerId ? H[1] : H[0];
                            return G[t.pointerId]
                        }
                        return f.domElement.addEventListener("contextmenu", fe), f.domElement.addEventListener("pointerdown", le), f.domElement.addEventListener("pointercancel", ce), f.domElement.addEventListener("wheel", he, {
                            passive: !1
                        }), a.update(), a
                    }
                    return o(n)
                }(it),
                hu = n(444),
                du = Object.freeze({
                    Linear: Object.freeze({
                        None: function (e) {
                            return e
                        },
                        In: function (e) {
                            return this.None(e)
                        },
                        Out: function (e) {
                            return this.None(e)
                        },
                        InOut: function (e) {
                            return this.None(e)
                        }
                    }),
                    Quadratic: Object.freeze({
                        In: function (e) {
                            return e * e
                        },
                        Out: function (e) {
                            return e * (2 - e)
                        },
                        InOut: function (e) {
                            return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
                        }
                    }),
                    Cubic: Object.freeze({
                        In: function (e) {
                            return e * e * e
                        },
                        Out: function (e) {
                            return --e * e * e + 1
                        },
                        InOut: function (e) {
                            return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
                        }
                    }),
                    Quartic: Object.freeze({
                        In: function (e) {
                            return e * e * e * e
                        },
                        Out: function (e) {
                            return 1 - --e * e * e * e
                        },
                        InOut: function (e) {
                            return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
                        }
                    }),
                    Quintic: Object.freeze({
                        In: function (e) {
                            return e * e * e * e * e
                        },
                        Out: function (e) {
                            return --e * e * e * e * e + 1
                        },
                        InOut: function (e) {
                            return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
                        }
                    }),
                    Sinusoidal: Object.freeze({
                        In: function (e) {
                            return 1 - Math.sin((1 - e) * Math.PI / 2)
                        },
                        Out: function (e) {
                            return Math.sin(e * Math.PI / 2)
                        },
                        InOut: function (e) {
                            return .5 * (1 - Math.sin(Math.PI * (.5 - e)))
                        }
                    }),
                    Exponential: Object.freeze({
                        In: function (e) {
                            return 0 === e ? 0 : Math.pow(1024, e - 1)
                        },
                        Out: function (e) {
                            return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
                        },
                        InOut: function (e) {
                            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                        }
                    }),
                    Circular: Object.freeze({
                        In: function (e) {
                            return 1 - Math.sqrt(1 - e * e)
                        },
                        Out: function (e) {
                            return Math.sqrt(1 - --e * e)
                        },
                        InOut: function (e) {
                            return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                        }
                    }),
                    Elastic: Object.freeze({
                        In: function (e) {
                            return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
                        },
                        Out: function (e) {
                            return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
                        },
                        InOut: function (e) {
                            return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
                        }
                    }),
                    Back: Object.freeze({
                        In: function (e) {
                            var t = 1.70158;
                            return 1 === e ? 1 : e * e * ((t + 1) * e - t)
                        },
                        Out: function (e) {
                            var t = 1.70158;
                            return 0 === e ? 0 : --e * e * ((t + 1) * e + t) + 1
                        },
                        InOut: function (e) {
                            var t = 2.5949095;
                            return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
                        }
                    }),
                    Bounce: Object.freeze({
                        In: function (e) {
                            return 1 - du.Bounce.Out(1 - e)
                        },
                        Out: function (e) {
                            return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                        },
                        InOut: function (e) {
                            return e < .5 ? .5 * du.Bounce.In(2 * e) : .5 * du.Bounce.Out(2 * e - 1) + .5
                        }
                    }),
                    generatePow: function (e) {
                        return void 0 === e && (e = 4), e = (e = e < Number.EPSILON ? Number.EPSILON : e) > 1e4 ? 1e4 : e, {
                            In: function (t) {
                                return Math.pow(t, e)
                            },
                            Out: function (t) {
                                return 1 - Math.pow(1 - t, e)
                            },
                            InOut: function (t) {
                                return t < .5 ? Math.pow(2 * t, e) / 2 : (1 - Math.pow(2 - 2 * t, e)) / 2 + .5
                            }
                        }
                    }
                }),
                fu = function () {
                    return performance.now()
                },
                pu = function () {
                    function e() {
                        this._tweens = {}, this._tweensAddedDuringUpdate = {}
                    }
                    return e.prototype.getAll = function () {
                        var e = this;
                        return Object.keys(this._tweens).map((function (t) {
                            return e._tweens[t]
                        }))
                    }, e.prototype.removeAll = function () {
                        this._tweens = {}
                    }, e.prototype.add = function (e) {
                        this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
                    }, e.prototype.remove = function (e) {
                        delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
                    }, e.prototype.update = function (e, t) {
                        void 0 === e && (e = fu()), void 0 === t && (t = !1);
                        var n = Object.keys(this._tweens);
                        if (0 === n.length) return !1;
                        for (; n.length > 0;) {
                            this._tweensAddedDuringUpdate = {};
                            for (var r = 0; r < n.length; r++) {
                                var i = this._tweens[n[r]],
                                    a = !t;
                                i && !1 === i.update(e, a) && !t && delete this._tweens[n[r]]
                            }
                            n = Object.keys(this._tweensAddedDuringUpdate)
                        }
                        return !0
                    }, e
                }(),
                mu = {
                    Linear: function (e, t) {
                        var n = e.length - 1,
                            r = n * t,
                            i = Math.floor(r),
                            a = mu.Utils.Linear;
                        return t < 0 ? a(e[0], e[1], r) : t > 1 ? a(e[n], e[n - 1], n - r) : a(e[i], e[i + 1 > n ? n : i + 1], r - i)
                    },
                    Bezier: function (e, t) {
                        for (var n = 0, r = e.length - 1, i = Math.pow, a = mu.Utils.Bernstein, o = 0; o <= r; o++) n += i(1 - t, r - o) * i(t, o) * e[o] * a(r, o);
                        return n
                    },
                    CatmullRom: function (e, t) {
                        var n = e.length - 1,
                            r = n * t,
                            i = Math.floor(r),
                            a = mu.Utils.CatmullRom;
                        return e[0] === e[n] ? (t < 0 && (i = Math.floor(r = n * (1 + t))), a(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)) : t < 0 ? e[0] - (a(e[0], e[0], e[1], e[1], -r) - e[0]) : t > 1 ? e[n] - (a(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : a(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
                    },
                    Utils: {
                        Linear: function (e, t, n) {
                            return (t - e) * n + e
                        },
                        Bernstein: function (e, t) {
                            var n = mu.Utils.Factorial;
                            return n(e) / n(t) / n(e - t)
                        },
                        Factorial: (tu = [1], function (e) {
                            var t = 1;
                            if (tu[e]) return tu[e];
                            for (var n = e; n > 1; n--) t *= n;
                            return tu[e] = t, t
                        }),
                        CatmullRom: function (e, t, n, r, i) {
                            var a = .5 * (n - e),
                                o = .5 * (r - t),
                                s = i * i;
                            return (2 * t - 2 * n + a + o) * (i * s) + (-3 * t + 3 * n - 2 * a - o) * s + a * i + t
                        }
                    }
                },
                vu = function () {
                    function e() {}
                    return e.nextId = function () {
                        return e._nextId++
                    }, e._nextId = 0, e
                }(),
                gu = new pu,
                _u = function () {
                    function e(e, t) {
                        void 0 === t && (t = gu), this._object = e, this._group = t, this._isPaused = !1, this._pauseStart = 0, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._isDynamic = !1, this._initialRepeat = 0, this._repeat = 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = 0, this._easingFunction = du.Linear.None, this._interpolationFunction = mu.Linear, this._chainedTweens = [], this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._id = vu.nextId(), this._isChainStopped = !1, this._propertiesAreSetUp = !1, this._goToEnd = !1
                    }
                    return e.prototype.getId = function () {
                        return this._id
                    }, e.prototype.isPlaying = function () {
                        return this._isPlaying
                    }, e.prototype.isPaused = function () {
                        return this._isPaused
                    }, e.prototype.to = function (e, t) {
                        if (void 0 === t && (t = 1e3), this._isPlaying) throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
                        return this._valuesEnd = e, this._propertiesAreSetUp = !1, this._duration = t, this
                    }, e.prototype.duration = function (e) {
                        return void 0 === e && (e = 1e3), this._duration = e, this
                    }, e.prototype.dynamic = function (e) {
                        return void 0 === e && (e = !1), this._isDynamic = e, this
                    }, e.prototype.start = function (e, t) {
                        if (void 0 === e && (e = fu()), void 0 === t && (t = !1), this._isPlaying) return this;
                        if (this._group && this._group.add(this), this._repeat = this._initialRepeat, this._reversed)
                            for (var n in this._reversed = !1, this._valuesStartRepeat) this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
                        if (this._isPlaying = !0, this._isPaused = !1, this._onStartCallbackFired = !1, this._onEveryStartCallbackFired = !1, this._isChainStopped = !1, this._startTime = e, this._startTime += this._delayTime, !this._propertiesAreSetUp || t) {
                            if (this._propertiesAreSetUp = !0, !this._isDynamic) {
                                var r = {};
                                for (var i in this._valuesEnd) r[i] = this._valuesEnd[i];
                                this._valuesEnd = r
                            }
                            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, t)
                        }
                        return this
                    }, e.prototype.startFromCurrentValues = function (e) {
                        return this.start(e, !0)
                    }, e.prototype._setupProperties = function (e, t, n, r, i) {
                        for (var a in n) {
                            var o = e[a],
                                s = Array.isArray(o),
                                l = s ? "array" : hu(o),
                                u = !s && Array.isArray(n[a]);
                            if ("undefined" !== l && "function" !== l) {
                                if (u) {
                                    if (0 === (v = n[a]).length) continue;
                                    for (var c = [o], h = 0, d = v.length; h < d; h += 1) {
                                        var f = this._handleRelativeValue(o, v[h]);
                                        if (isNaN(f)) {
                                            u = !1, console.warn("Found invalid interpolation list. Skipping.");
                                            break
                                        }
                                        c.push(f)
                                    }
                                    u && (n[a] = c)
                                }
                                if ("object" !== l && !s || !o || u)(void 0 === t[a] || i) && (t[a] = o), s || (t[a] *= 1), r[a] = u ? n[a].slice().reverse() : t[a] || 0;
                                else {
                                    t[a] = s ? [] : {};
                                    var p = o;
                                    for (var m in p) t[a][m] = p[m];
                                    r[a] = s ? [] : {};
                                    var v = n[a];
                                    if (!this._isDynamic) {
                                        var g = {};
                                        for (var m in v) g[m] = v[m];
                                        n[a] = v = g
                                    }
                                    this._setupProperties(p, t[a], v, r[a], i)
                                }
                            }
                        }
                    }, e.prototype.stop = function () {
                        return this._isChainStopped || (this._isChainStopped = !0, this.stopChainedTweens()), this._isPlaying ? (this._group && this._group.remove(this), this._isPlaying = !1, this._isPaused = !1, this._onStopCallback && this._onStopCallback(this._object), this) : this
                    }, e.prototype.end = function () {
                        return this._goToEnd = !0, this.update(1 / 0), this
                    }, e.prototype.pause = function (e) {
                        return void 0 === e && (e = fu()), this._isPaused || !this._isPlaying || (this._isPaused = !0, this._pauseStart = e, this._group && this._group.remove(this)), this
                    }, e.prototype.resume = function (e) {
                        return void 0 === e && (e = fu()), this._isPaused && this._isPlaying ? (this._isPaused = !1, this._startTime += e - this._pauseStart, this._pauseStart = 0, this._group && this._group.add(this), this) : this
                    }, e.prototype.stopChainedTweens = function () {
                        for (var e = 0, t = this._chainedTweens.length; e < t; e++) this._chainedTweens[e].stop();
                        return this
                    }, e.prototype.group = function (e) {
                        return void 0 === e && (e = gu), this._group = e, this
                    }, e.prototype.delay = function (e) {
                        return void 0 === e && (e = 0), this._delayTime = e, this
                    }, e.prototype.repeat = function (e) {
                        return void 0 === e && (e = 0), this._initialRepeat = e, this._repeat = e, this
                    }, e.prototype.repeatDelay = function (e) {
                        return this._repeatDelayTime = e, this
                    }, e.prototype.yoyo = function (e) {
                        return void 0 === e && (e = !1), this._yoyo = e, this
                    }, e.prototype.easing = function (e) {
                        return void 0 === e && (e = du.Linear.None), this._easingFunction = e, this
                    }, e.prototype.interpolation = function (e) {
                        return void 0 === e && (e = mu.Linear), this._interpolationFunction = e, this
                    }, e.prototype.chain = function () {
                        for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
                        return this._chainedTweens = e, this
                    }, e.prototype.onStart = function (e) {
                        return this._onStartCallback = e, this
                    }, e.prototype.onEveryStart = function (e) {
                        return this._onEveryStartCallback = e, this
                    }, e.prototype.onUpdate = function (e) {
                        return this._onUpdateCallback = e, this
                    }, e.prototype.onRepeat = function (e) {
                        return this._onRepeatCallback = e, this
                    }, e.prototype.onComplete = function (e) {
                        return this._onCompleteCallback = e, this
                    }, e.prototype.onStop = function (e) {
                        return this._onStopCallback = e, this
                    }, e.prototype.update = function (e, t) {
                        if (void 0 === e && (e = fu()), void 0 === t && (t = !0), this._isPaused) return !0;
                        var n, r, i = this._startTime + this._duration;
                        if (!this._goToEnd && !this._isPlaying) {
                            if (e > i) return !1;
                            t && this.start(e, !0)
                        }
                        if (this._goToEnd = !1, e < this._startTime) return !0;
                        !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), !1 === this._onEveryStartCallbackFired && (this._onEveryStartCallback && this._onEveryStartCallback(this._object), this._onEveryStartCallbackFired = !0), r = (e - this._startTime) / this._duration, r = 0 === this._duration || r > 1 ? 1 : r;
                        var a = this._easingFunction(r);
                        if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, a), this._onUpdateCallback && this._onUpdateCallback(this._object, r), 1 === r) {
                            if (this._repeat > 0) {
                                for (n in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) this._yoyo || "string" != typeof this._valuesEnd[n] || (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])), this._yoyo && this._swapEndStartRepeatValues(n), this._valuesStart[n] = this._valuesStartRepeat[n];
                                return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, this._onRepeatCallback && this._onRepeatCallback(this._object), this._onEveryStartCallbackFired = !1, !0
                            }
                            this._onCompleteCallback && this._onCompleteCallback(this._object);
                            for (var o = 0, s = this._chainedTweens.length; o < s; o++) this._chainedTweens[o].start(this._startTime + this._duration, !1);
                            return this._isPlaying = !1, !1
                        }
                        return !0
                    }, e.prototype._updateProperties = function (e, t, n, r) {
                        for (var i in n)
                            if (void 0 !== t[i]) {
                                var a = t[i] || 0,
                                    o = n[i],
                                    s = Array.isArray(e[i]),
                                    l = Array.isArray(o);
                                !s && l ? e[i] = this._interpolationFunction(o, r) : "object" === hu(o) && o ? this._updateProperties(e[i], a, o, r) : "number" == typeof (o = this._handleRelativeValue(a, o)) && (e[i] = a + (o - a) * r)
                            }
                    }, e.prototype._handleRelativeValue = function (e, t) {
                        return "string" != typeof t ? t : "+" === t.charAt(0) || "-" === t.charAt(0) ? e + parseFloat(t) : parseFloat(t)
                    }, e.prototype._swapEndStartRepeatValues = function (e) {
                        var t = this._valuesStartRepeat[e],
                            n = this._valuesEnd[e];
                        this._valuesStartRepeat[e] = "string" == typeof n ? this._valuesStartRepeat[e] + parseFloat(n) : this._valuesEnd[e], this._valuesEnd[e] = t
                    }, e
                }(),
                yu = (vu.nextId, gu),
                xu = (yu.getAll.bind(yu), yu.removeAll.bind(yu), yu.add.bind(yu), yu.remove.bind(yu), yu.update.bind(yu)),
                Mu = new(function () {
                    function e() {
                        a()(this, e), u()(this, "callback", {}), u()(this, "task", new Map)
                    }
                    return s()(e, [{
                        key: "update",
                        value: function () {
                            this.task.size > 0 && d()(this.task.keys()).forEach((function (e) {
                                e()
                            }))
                        }
                    }, {
                        key: "add",
                        value: function (e, t) {
                            this.callback.cb = e, this.callback.duration = t || 1e3
                        }
                    }, {
                        key: "remove",
                        value: function (e) {
                            this.task.get(e) && (clearTimeout(this.task.get(e)), this.task.delete(e))
                        }
                    }, {
                        key: "start",
                        value: function () {
                            if (!this.task.get(this.callback.cb)) {
                                var e = this.timerControl();
                                this.task.set(this.callback.cb, e)
                            }
                        }
                    }, {
                        key: "timerControl",
                        value: function () {
                            var e = this;
                            return setTimeout((function () {
                                e.task.delete(e.callback.cb)
                            }), this.callback.duration)
                        }
                    }]), e
                }()),
                Su = new(function () {
                    function e() {
                        a()(this, e), u()(this, "scene", null), u()(this, "triggerClick", !1)
                    }
                    return s()(e, [{
                        key: "addScene",
                        value: function (e) {
                            this.scene = e
                        }
                    }, {
                        key: "setTriggerClickState",
                        value: function (e) {
                            this.triggerClick = e
                        }
                    }]), e
                }());
            nu || (nu = {}),
                function (e) {
                    e.plus = "plus", e.minus = "minus"
                }(ru || (ru = {}));
            var Eu = function (e, t, n, r, i, a) {
                    var o = t.position,
                        s = e.position,
                        l = o.clone().sub(s).normalize();
                    r === ru.minus && (l = l.negate());
                    var u = s.clone().add(l.multiplyScalar(n)),
                        c = s.distanceTo(o),
                        h = s.distanceTo(u),
                        d = u.clone();
                    r === ru.plus && h > c && (d = o);
                    var f = new _u(s);
                    return f.to(d, i || 1e3), f.start(), e instanceof bu && (Mu.add((function () {
                        e.lookAt(o)
                    }), 1.01 * (i || 1e3)), Mu.start()), f
                },
                Tu = function (e, t, n) {},
                bu = function (e) {
                    T()(n, e);
                    var t = A()(n);

                    function n(e, r, i, o) {
                        var s;
                        return a()(this, n), s = t.call(this, e, r, i, o), u()(S()(s), "demote", (function (e, t, n, r) {
                            return Eu(S()(s), e, t, ru.minus, n)
                        })), u()(S()(s), "surround", Tu), s
                    }
                    return s()(n, [{
                        key: "promote",
                        value: function (e, t, n, r) {
                            return Eu(this, e, t, ru.plus, n)
                        }
                    }]), n
                }(ni),
                Au = function () {
                    function e(t) {
                        a()(this, e), u()(this, "opts", {}), u()(this, "pointer", new yt), u()(this, "scene", null), u()(this, "raycaster", null), u()(this, "ambientLight", null), u()(this, "camera", null), u()(this, "renderer", null), u()(this, "controls", null), this.opts = null != t ? t : {}, this.scene = new Zo, this.raycaster = new Jl, Su.addScene(this.scene), this.defaultInit()
                    }
                    return s()(e, [{
                        key: "defaultInit",
                        value: function () {
                            var e = this.initDefaultPerspectiveCamera();
                            this.camera = e, this.scene.add(e);
                            var t = this.initRenderer();
                            if (this.renderer = t, this.opts.ambientLight) {
                                var n = this.initAmbientLight();
                                this.ambientLight = n, this.scene.add(n)
                            }
                        }
                    }, {
                        key: "resetScene",
                        value: function (e, t) {
                            e.aspect = window.innerWidth / window.innerHeight, e.updateProjectionMatrix(), t.setSize(window.innerWidth, window.innerHeight), t.setPixelRatio(window.devicePixelRatio)
                        }
                    }, {
                        key: "initRenderer",
                        value: function () {
                            var e, t, n = this.opts.rendererOps || {},
                                r = new Yo({
                                    antialias: null === (e = n.antialias) || void 0 === e || e,
                                    logarithmicDepthBuffer: null === (t = n.logarithmicDepthBuffer) || void 0 === t || t
                                });
                            return r.setSize(window.innerWidth, window.innerHeight), r.shadowMap.enabled = !0, r.toneMapping = 4, r.toneMappingExposure = .3, r.setPixelRatio(window.devicePixelRatio), r
                        }
                    }, {
                        key: "initDefaultPerspectiveCamera",
                        value: function () {
                            var e = this.opts.defCameraOps || {},
                                t = new bu(e.fov || 90, window.innerWidth / window.innerHeight, e.near || .1, e.far || 1e3),
                                n = e.position || new Xt(0, 10, 10);
                            return t.position.set(n.x, n.y, n.z), t
                        }
                    }, {
                        key: "initAmbientLight",
                        value: function () {
                            var e = this.opts.defAmbientLightOps || {},
                                t = e.position || new Xt(0, 3, 10),
                                n = new zl(e.color || 16777215, e.intensity || 1);
                            return n.position.set(t.x, t.y, t.z), n
                        }
                    }, {
                        key: "startFrameAnimate",
                        value: function (e) {
                            var t = this;
                            if (!this.renderer || !this.scene || !this.camera) throw new Error("scene or camera or renderer is not init");
                            e && e(this.renderer), Mu.update(), xu(), this.renderer.render(this.scene, this.camera), this.controls && this.controls.update(), requestAnimationFrame((function () {
                                return t.startFrameAnimate(e)
                            }))
                        }
                    }, {
                        key: "add",
                        value: function (e) {
                            this.scene.add(e)
                        }
                    }, {
                        key: "updateRaycaster",
                        value: function () {
                            this.raycaster.setFromCamera(this.pointer, this.camera), this.raycaster.intersectObjects(this.scene.children)
                        }
                    }, {
                        key: "getPointerPosition",
                        value: function (e) {
                            this.pointer.setX(e.clientX / window.innerWidth * 2 - 1), this.pointer.setY(-e.clientY / window.innerHeight * 2 + 1)
                        }
                    }, {
                        key: "onPointerPointerup",
                        value: function (e) {
                            Su.setTriggerClickState(!1), this.getPointerPosition(e), this.updateRaycaster()
                        }
                    }, {
                        key: "onPointerDown",
                        value: function (e) {
                            Su.setTriggerClickState(!0), this.getPointerPosition(e), this.updateRaycaster()
                        }
                    }, {
                        key: "onPointerMove",
                        value: function (e) {
                            this.getPointerPosition(e), this.updateRaycaster()
                        }
                    }, {
                        key: "onPointerLeave",
                        value: function (e) {
                            this.getPointerPosition(e), this.updateRaycaster()
                        }
                    }, {
                        key: "registerEvent",
                        value: function (e) {
                            var t = this;
                            e.addEventListener("pointerup", (function (e) {
                                return t.onPointerPointerup(e)
                            })), e.addEventListener("pointerdown", (function (e) {
                                return t.onPointerDown(e)
                            })), e.addEventListener("pointermove", (function (e) {
                                return t.onPointerMove(e)
                            })), e.addEventListener("pointerleave", (function (e) {
                                return t.onPointerLeave(e)
                            }))
                        }
                    }, {
                        key: "render",
                        value: function (e) {
                            var t = this;
                            this.opts.orbitControls && (this.controls = new cu(this.camera, this.renderer.domElement)), e.appendChild(this.renderer.domElement), this.registerEvent(this.renderer.domElement), e.addEventListener("resize", (function () {
                                return t.resetScene(t.camera, t.renderer)
                            }))
                        }
                    }, {
                        key: "destroy",
                        value: function () {
                            var e = this;
                            window.removeEventListener("resize", (function () {
                                return e.resetScene(e.camera, e.renderer)
                            }))
                        }
                    }]), e
                }(),
                wu = function (e) {
                    T()(n, e);
                    var t = A()(n);

                    function n(e, r) {
                        var i;
                        return a()(this, n), i = t.call(this, e, r), u()(S()(i), "natureEventMap", new Map), u()(S()(i), "entered", !1), i
                    }
                    return s()(n, [{
                        key: "addNatureEventListener",
                        value: function (e, t) {
                            this.natureEventMap.has(e) || this.natureEventMap.set(e, []), this.natureEventMap.get(e).push(t)
                        }
                    }, {
                        key: "removeNatureEventListener",
                        value: function (e, t) {
                            if (this.natureEventMap.has(e)) {
                                var n = this.natureEventMap.get(e),
                                    r = n.findIndex((function (e) {
                                        return e === t
                                    }));
                                r > -1 && n.splice(r, 1)
                            }
                        }
                    }, {
                        key: "removeAllNatureEventListener",
                        value: function () {
                            this.natureEventMap.clear()
                        }
                    }, {
                        key: "handleClick",
                        value: function (e) {
                            var t = this;
                            Su.triggerClick && e.forEach((function (e) {
                                e(t)
                            }))
                        }
                    }, {
                        key: "handlePointerMove",
                        value: function (e) {
                            var t = this;
                            e.forEach((function (e) {
                                e(t)
                            }))
                        }
                    }, {
                        key: "handlePointerleave",
                        value: function () {
                            var e = this,
                                t = this.natureEventMap.get("pointerleave");
                            t && t.length > 0 && t.forEach((function (t) {
                                t(e)
                            }))
                        }
                    }, {
                        key: "raycast",
                        value: function (e, t) {
                            if (0 !== this.natureEventMap.size) {
                                _()(x()(n.prototype), "raycast", this).call(this, e, t);
                                var r = this.natureEventMap.get("click"),
                                    i = this.natureEventMap.get("pointerup"),
                                    a = this.natureEventMap.get("pointerdown"),
                                    o = this.natureEventMap.get("pointermove"),
                                    s = t[0];
                                (s && s.object) === this ? (this.entered = !0, r && r.length > 0 && this.handleClick(r), i && i.length > 0 && this.handleClick(i), a && a.length > 0 && this.handleClick(a), o && o.length > 0 && this.handlePointerMove(o)) : this.entered && (this.handlePointerleave(), this.entered = !1)
                            }
                        }
                    }]), n
                }(qr),
                Ru = wu,
                Cu = new WeakMap,
                Lu = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e) {
                        var r;
                        return i(this, n), (r = t.call(this, e)).decoderPath = "", r.decoderConfig = {}, r.decoderBinary = null, r.decoderPending = null, r.workerLimit = 4, r.workerPool = [], r.workerNextTaskID = 1, r.workerSourceURL = "", r.defaultAttributeIDs = {
                            position: "POSITION",
                            normal: "NORMAL",
                            color: "COLOR",
                            uv: "TEX_COORD"
                        }, r.defaultAttributeTypes = {
                            position: "Float32Array",
                            normal: "Float32Array",
                            color: "Float32Array",
                            uv: "Float32Array"
                        }, r
                    }
                    return o(n, [{
                        key: "setDecoderPath",
                        value: function (e) {
                            return this.decoderPath = e, this
                        }
                    }, {
                        key: "setDecoderConfig",
                        value: function (e) {
                            return this.decoderConfig = e, this
                        }
                    }, {
                        key: "setWorkerLimit",
                        value: function (e) {
                            return this.workerLimit = e, this
                        }
                    }, {
                        key: "load",
                        value: function (e, t, n, r) {
                            var i = this,
                                a = new El(this.manager);
                            a.setPath(this.path), a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, (function (e) {
                                i.parse(e, t, r)
                            }), n, r)
                        }
                    }, {
                        key: "parse",
                        value: function (e, t, n) {
                            this.decodeDracoFile(e, t, null, null, Ke).catch(n)
                        }
                    }, {
                        key: "decodeDracoFile",
                        value: function (e, t, n, r) {
                            var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : Ze,
                                a = {
                                    attributeIDs: n || this.defaultAttributeIDs,
                                    attributeTypes: r || this.defaultAttributeTypes,
                                    useUniqueIDs: !!n,
                                    vertexColorSpace: i
                                };
                            return this.decodeGeometry(e, a).then(t)
                        }
                    }, {
                        key: "decodeGeometry",
                        value: function (e, t) {
                            var n, r = this,
                                i = JSON.stringify(t);
                            if (Cu.has(e)) {
                                var a = Cu.get(e);
                                if (a.key === i) return a.promise;
                                if (0 === e.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
                            }
                            var o = this.workerNextTaskID++,
                                s = e.byteLength,
                                l = this._getWorker(o, s).then((function (r) {
                                    return n = r, new Promise((function (r, i) {
                                        n._callbacks[o] = {
                                            resolve: r,
                                            reject: i
                                        }, n.postMessage({
                                            type: "decode",
                                            id: o,
                                            taskConfig: t,
                                            buffer: e
                                        }, [e])
                                    }))
                                })).then((function (e) {
                                    return r._createGeometry(e.geometry)
                                }));
                            return l.catch((function () {
                                return !0
                            })).then((function () {
                                n && o && r._releaseTask(n, o)
                            })), Cu.set(e, {
                                key: i,
                                promise: l
                            }), l
                        }
                    }, {
                        key: "_createGeometry",
                        value: function (e) {
                            var t = new Cr;
                            e.index && t.setIndex(new _r(e.index.array, 1));
                            for (var n = 0; n < e.attributes.length; n++) {
                                var r = e.attributes[n],
                                    i = r.name,
                                    a = r.array,
                                    o = r.itemSize,
                                    s = new _r(a, o);
                                "color" === i && (this._assignVertexColorSpace(s, r.vertexColorSpace), s.normalized = a instanceof Float32Array == !1), t.setAttribute(i, s)
                            }
                            return t
                        }
                    }, {
                        key: "_assignVertexColorSpace",
                        value: function (e, t) {
                            if (t === Ke)
                                for (var n = new fr, r = 0, i = e.count; r < i; r++) n.fromBufferAttribute(e, r).convertSRGBToLinear(), e.setXYZ(r, n.r, n.g, n.b)
                        }
                    }, {
                        key: "_loadLibrary",
                        value: function (e, t) {
                            var n = new El(this.manager);
                            return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((function (t, r) {
                                n.load(e, t, void 0, r)
                            }))
                        }
                    }, {
                        key: "preload",
                        value: function () {
                            return this._initDecoder(), this
                        }
                    }, {
                        key: "_initDecoder",
                        value: function () {
                            var e = this;
                            if (this.decoderPending) return this.decoderPending;
                            var t = "object" !== ("undefined" == typeof WebAssembly ? "undefined" : hu(WebAssembly)) || "js" === this.decoderConfig.type,
                                n = [];
                            return t ? n.push(this._loadLibrary("draco_decoder.js", "text")) : (n.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), n.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(n).then((function (n) {
                                var r = n[0];
                                t || (e.decoderConfig.wasmBinary = n[1]);
                                var i = Pu.toString(),
                                    a = ["/* draco decoder */", r, "", "/* worker */", i.substring(i.indexOf("{") + 1, i.lastIndexOf("}"))].join("\n");
                                e.workerSourceURL = URL.createObjectURL(new Blob([a]))
                            })), this.decoderPending
                        }
                    }, {
                        key: "_getWorker",
                        value: function (e, t) {
                            var n = this;
                            return this._initDecoder().then((function () {
                                if (n.workerPool.length < n.workerLimit) {
                                    var r = new Worker(n.workerSourceURL);
                                    r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({
                                        type: "init",
                                        decoderConfig: n.decoderConfig
                                    }), r.onmessage = function (e) {
                                        var t = e.data;
                                        switch (t.type) {
                                            case "decode":
                                                r._callbacks[t.id].resolve(t);
                                                break;
                                            case "error":
                                                r._callbacks[t.id].reject(t);
                                                break;
                                            default:
                                                console.error('THREE.DRACOLoader: Unexpected message, "' + t.type + '"')
                                        }
                                    }, n.workerPool.push(r)
                                } else n.workerPool.sort((function (e, t) {
                                    return e._taskLoad > t._taskLoad ? -1 : 1
                                }));
                                var i = n.workerPool[n.workerPool.length - 1];
                                return i._taskCosts[e] = t, i._taskLoad += t, i
                            }))
                        }
                    }, {
                        key: "_releaseTask",
                        value: function (e, t) {
                            e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
                        }
                    }, {
                        key: "debug",
                        value: function () {
                            console.log("Task load: ", this.workerPool.map((function (e) {
                                return e._taskLoad
                            })))
                        }
                    }, {
                        key: "dispose",
                        value: function () {
                            for (var e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
                            return this.workerPool.length = 0, "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL), this
                        }
                    }]), n
                }(xl);

            function Pu() {
                var e, t;

                function n(e, t, n, r, i, a) {
                    var o = a.num_components(),
                        s = n.num_points() * o,
                        l = s * i.BYTES_PER_ELEMENT,
                        u = function (e, t) {
                            switch (t) {
                                case Float32Array:
                                    return e.DT_FLOAT32;
                                case Int8Array:
                                    return e.DT_INT8;
                                case Int16Array:
                                    return e.DT_INT16;
                                case Int32Array:
                                    return e.DT_INT32;
                                case Uint8Array:
                                    return e.DT_UINT8;
                                case Uint16Array:
                                    return e.DT_UINT16;
                                case Uint32Array:
                                    return e.DT_UINT32
                            }
                        }(e, i),
                        c = e._malloc(l);
                    t.GetAttributeDataArrayForAllPoints(n, a, u, l, c);
                    var h = new i(e.HEAPF32.buffer, c, s).slice();
                    return e._free(c), {
                        name: r,
                        array: h,
                        itemSize: o
                    }
                }
                onmessage = function (r) {
                    var i = r.data;
                    switch (i.type) {
                        case "init":
                            e = i.decoderConfig, t = new Promise((function (t) {
                                e.onModuleLoaded = function (e) {
                                    t({
                                        draco: e
                                    })
                                }, DracoDecoderModule(e)
                            }));
                            break;
                        case "decode":
                            var a = i.buffer,
                                o = i.taskConfig;
                            t.then((function (e) {
                                var t = e.draco,
                                    r = new t.Decoder;
                                try {
                                    var s = function (e, t, r, i) {
                                            var a, o, s = i.attributeIDs,
                                                l = i.attributeTypes,
                                                u = t.GetEncodedGeometryType(r);
                                            if (u === e.TRIANGULAR_MESH) a = new e.Mesh, o = t.DecodeArrayToMesh(r, r.byteLength, a);
                                            else {
                                                if (u !== e.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
                                                a = new e.PointCloud, o = t.DecodeArrayToPointCloud(r, r.byteLength, a)
                                            }
                                            if (!o.ok() || 0 === a.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + o.error_msg());
                                            var c = {
                                                index: null,
                                                attributes: []
                                            };
                                            for (var h in s) {
                                                var d = self[l[h]],
                                                    f = void 0,
                                                    p = void 0;
                                                if (i.useUniqueIDs) p = s[h], f = t.GetAttributeByUniqueId(a, p);
                                                else {
                                                    if (-1 === (p = t.GetAttributeId(a, e[s[h]]))) continue;
                                                    f = t.GetAttribute(a, p)
                                                }
                                                var m = n(e, t, a, h, d, f);
                                                "color" === h && (m.vertexColorSpace = i.vertexColorSpace), c.attributes.push(m)
                                            }
                                            u === e.TRIANGULAR_MESH && (c.index = function (e, t, n) {
                                                var r = n.num_faces(),
                                                    i = 3 * r,
                                                    a = 4 * i,
                                                    o = e._malloc(a);
                                                t.GetTrianglesUInt32Array(n, a, o);
                                                var s = new Uint32Array(e.HEAPF32.buffer, o, i).slice();
                                                return e._free(o), {
                                                    array: s,
                                                    itemSize: 1
                                                }
                                            }(e, t, a));
                                            return e.destroy(a), c
                                        }(t, r, new Int8Array(a), o),
                                        l = s.attributes.map((function (e) {
                                            return e.array.buffer
                                        }));
                                    s.index && l.push(s.index.array.buffer), self.postMessage({
                                        type: "decode",
                                        id: i.id,
                                        geometry: s
                                    }, l)
                                } catch (e) {
                                    console.error(e), self.postMessage({
                                        type: "error",
                                        id: i.id,
                                        error: e.message
                                    })
                                } finally {
                                    t.destroy(r)
                                }
                            }))
                    }
                }
            }

            function ku(e, t) {
                if (0 === t) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), e;
                if (2 === t || 1 === t) {
                    var n = e.getIndex();
                    if (null === n) {
                        var r = [],
                            i = e.getAttribute("position");
                        if (void 0 === i) return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), e;
                        for (var a = 0; a < i.count; a++) r.push(a);
                        e.setIndex(r), n = e.getIndex()
                    }
                    var o = n.count - 2,
                        s = [];
                    if (2 === t)
                        for (var l = 1; l <= o; l++) s.push(n.getX(0)), s.push(n.getX(l)), s.push(n.getX(l + 1));
                    else
                        for (var u = 0; u < o; u++) u % 2 == 0 ? (s.push(n.getX(u)), s.push(n.getX(u + 1)), s.push(n.getX(u + 2))) : (s.push(n.getX(u + 2)), s.push(n.getX(u + 1)), s.push(n.getX(u)));
                    s.length / 3 !== o && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
                    var c = e.clone();
                    return c.setIndex(s), c.clearGroups(), c
                }
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", t), e
            }
            var Iu = function (e) {
                E(n, e);
                var t = b(n);

                function n(e) {
                    var r;
                    return i(this, n), (r = t.call(this, e)).dracoLoader = null, r.ktx2Loader = null, r.meshoptDecoder = null, r.pluginCallbacks = [], r.register((function (e) {
                        return new Bu(e)
                    })), r.register((function (e) {
                        return new qu(e)
                    })), r.register((function (e) {
                        return new Yu(e)
                    })), r.register((function (e) {
                        return new Ku(e)
                    })), r.register((function (e) {
                        return new Hu(e)
                    })), r.register((function (e) {
                        return new Gu(e)
                    })), r.register((function (e) {
                        return new Vu(e)
                    })), r.register((function (e) {
                        return new Wu(e)
                    })), r.register((function (e) {
                        return new Fu(e)
                    })), r.register((function (e) {
                        return new ju(e)
                    })), r.register((function (e) {
                        return new zu(e)
                    })), r.register((function (e) {
                        return new Xu(e)
                    })), r.register((function (e) {
                        return new Nu(e)
                    })), r.register((function (e) {
                        return new Zu(e)
                    })), r.register((function (e) {
                        return new Ju(e)
                    })), r
                }
                return o(n, [{
                    key: "load",
                    value: function (e, t, n, r) {
                        var i, a = this;
                        i = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : Hl.extractUrlBase(e), this.manager.itemStart(e);
                        var o = function (t) {
                                r ? r(t) : console.error(t), a.manager.itemError(e), a.manager.itemEnd(e)
                            },
                            s = new El(this.manager);
                        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, (function (n) {
                            try {
                                a.parse(n, i, (function (n) {
                                    t(n), a.manager.itemEnd(e)
                                }), o)
                            } catch (e) {
                                o(e)
                            }
                        }), n, o)
                    }
                }, {
                    key: "setDRACOLoader",
                    value: function (e) {
                        return this.dracoLoader = e, this
                    }
                }, {
                    key: "setDDSLoader",
                    value: function () {
                        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                    }
                }, {
                    key: "setKTX2Loader",
                    value: function (e) {
                        return this.ktx2Loader = e, this
                    }
                }, {
                    key: "setMeshoptDecoder",
                    value: function (e) {
                        return this.meshoptDecoder = e, this
                    }
                }, {
                    key: "register",
                    value: function (e) {
                        return -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e), this
                    }
                }, {
                    key: "unregister",
                    value: function (e) {
                        return -1 !== this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
                    }
                }, {
                    key: "parse",
                    value: function (e, t, n, r) {
                        var i, a = {},
                            o = {},
                            s = new TextDecoder;
                        if ("string" == typeof e) i = JSON.parse(e);
                        else if (e instanceof ArrayBuffer) {
                            if (s.decode(new Uint8Array(e, 0, 4)) === Qu) {
                                try {
                                    a[Du.KHR_BINARY_GLTF] = new tc(e)
                                } catch (e) {
                                    return void(r && r(e))
                                }
                                i = JSON.parse(a[Du.KHR_BINARY_GLTF].content)
                            } else i = JSON.parse(s.decode(e))
                        } else i = e;
                        if (void 0 === i.asset || i.asset.version[0] < 2) r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
                        else {
                            var l = new Ac(i, {
                                path: t || this.resourcePath || "",
                                crossOrigin: this.crossOrigin,
                                requestHeader: this.requestHeader,
                                manager: this.manager,
                                ktx2Loader: this.ktx2Loader,
                                meshoptDecoder: this.meshoptDecoder
                            });
                            l.fileLoader.setRequestHeader(this.requestHeader);
                            for (var u = 0; u < this.pluginCallbacks.length; u++) {
                                var c = this.pluginCallbacks[u](l);
                                o[c.name] = c, a[c.name] = !0
                            }
                            if (i.extensionsUsed)
                                for (var h = 0; h < i.extensionsUsed.length; ++h) {
                                    var d = i.extensionsUsed[h],
                                        f = i.extensionsRequired || [];
                                    switch (d) {
                                        case Du.KHR_MATERIALS_UNLIT:
                                            a[d] = new Ou;
                                            break;
                                        case Du.KHR_DRACO_MESH_COMPRESSION:
                                            a[d] = new nc(i, this.dracoLoader);
                                            break;
                                        case Du.KHR_TEXTURE_TRANSFORM:
                                            a[d] = new rc;
                                            break;
                                        case Du.KHR_MESH_QUANTIZATION:
                                            a[d] = new ic;
                                            break;
                                        default:
                                            f.indexOf(d) >= 0 && void 0 === o[d] && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
                                    }
                                }
                            l.setExtensions(a), l.setPlugins(o), l.parse(n, r)
                        }
                    }
                }, {
                    key: "parseAsync",
                    value: function (e, t) {
                        var n = this;
                        return new Promise((function (r, i) {
                            n.parse(e, t, r, i)
                        }))
                    }
                }]), n
            }(xl);

            function Uu() {
                var e = {};
                return {
                    get: function (t) {
                        return e[t]
                    },
                    add: function (t, n) {
                        e[t] = n
                    },
                    remove: function (t) {
                        delete e[t]
                    },
                    removeAll: function () {
                        e = {}
                    }
                }
            }
            var Du = {
                    KHR_BINARY_GLTF: "KHR_binary_glTF",
                    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
                    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
                    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
                    KHR_MATERIALS_IOR: "KHR_materials_ior",
                    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
                    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
                    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
                    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
                    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
                    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
                    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
                    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
                    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
                    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
                    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
                    EXT_TEXTURE_WEBP: "EXT_texture_webp",
                    EXT_TEXTURE_AVIF: "EXT_texture_avif",
                    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
                    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
                },
                Nu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_LIGHTS_PUNCTUAL, this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    return o(e, [{
                        key: "_markDefs",
                        value: function () {
                            for (var e = this.parser, t = this.parser.json.nodes || [], n = 0, r = t.length; n < r; n++) {
                                var i = t[n];
                                i.extensions && i.extensions[this.name] && void 0 !== i.extensions[this.name].light && e._addNodeRef(this.cache, i.extensions[this.name].light)
                            }
                        }
                    }, {
                        key: "_loadLight",
                        value: function (e) {
                            var t = this.parser,
                                n = "light:" + e,
                                r = t.cache.get(n);
                            if (r) return r;
                            var i, a = t.json,
                                o = ((a.extensions && a.extensions[this.name] || {}).lights || [])[e],
                                s = new fr(16777215);
                            void 0 !== o.color && s.fromArray(o.color);
                            var l = void 0 !== o.range ? o.range : 0;
                            switch (o.type) {
                                case "directional":
                                    (i = new Bl(s)).target.position.set(0, 0, -1), i.add(i.target);
                                    break;
                                case "point":
                                    (i = new Ol(s)).distance = l;
                                    break;
                                case "spot":
                                    (i = new kl(s)).distance = l, o.spot = o.spot || {}, o.spot.innerConeAngle = void 0 !== o.spot.innerConeAngle ? o.spot.innerConeAngle : 0, o.spot.outerConeAngle = void 0 !== o.spot.outerConeAngle ? o.spot.outerConeAngle : Math.PI / 4, i.angle = o.spot.outerConeAngle, i.penumbra = 1 - o.spot.innerConeAngle / o.spot.outerConeAngle, i.target.position.set(0, 0, -1), i.add(i.target);
                                    break;
                                default:
                                    throw new Error("THREE.GLTFLoader: Unexpected light type: " + o.type)
                            }
                            return i.position.set(0, 0, 0), i.decay = 2, xc(i, o), void 0 !== o.intensity && (i.intensity = o.intensity), i.name = t.createUniqueName(o.name || "light_" + e), r = Promise.resolve(i), t.cache.add(n, r), r
                        }
                    }, {
                        key: "getDependency",
                        value: function (e, t) {
                            if ("light" === e) return this._loadLight(t)
                        }
                    }, {
                        key: "createNodeAttachment",
                        value: function (e) {
                            var t = this,
                                n = this.parser,
                                r = n.json.nodes[e],
                                i = (r.extensions && r.extensions[this.name] || {}).light;
                            return void 0 === i ? null : this._loadLight(i).then((function (e) {
                                return n._getNodeRef(t.cache, i, e)
                            }))
                        }
                    }]), e
                }(),
                Ou = function () {
                    function e() {
                        i(this, e), this.name = Du.KHR_MATERIALS_UNLIT
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function () {
                            return mr
                        }
                    }, {
                        key: "extendParams",
                        value: function (e, t, n) {
                            var r = [];
                            e.color = new fr(1, 1, 1), e.opacity = 1;
                            var i = t.pbrMetallicRoughness;
                            if (i) {
                                if (Array.isArray(i.baseColorFactor)) {
                                    var a = i.baseColorFactor;
                                    e.color.fromArray(a), e.opacity = a[3]
                                }
                                void 0 !== i.baseColorTexture && r.push(n.assignTexture(e, "map", i.baseColorTexture, Ke))
                            }
                            return Promise.all(r)
                        }
                    }]), e
                }(),
                Fu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_EMISSIVE_STRENGTH
                    }
                    return o(e, [{
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                            var r = n.extensions[this.name].emissiveStrength;
                            return void 0 !== r && (t.emissiveIntensity = r), Promise.resolve()
                        }
                    }]), e
                }(),
                Bu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_CLEARCOAT
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            if (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor), void 0 !== a.clearcoatTexture && i.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), void 0 !== a.clearcoatRoughnessFactor && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), void 0 !== a.clearcoatRoughnessTexture && i.push(n.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), void 0 !== a.clearcoatNormalTexture && (i.push(n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), void 0 !== a.clearcoatNormalTexture.scale)) {
                                var o = a.clearcoatNormalTexture.scale;
                                t.clearcoatNormalScale = new yt(o, o)
                            }
                            return Promise.all(i)
                        }
                    }]), e
                }(),
                zu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_IRIDESCENCE
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            return void 0 !== a.iridescenceFactor && (t.iridescence = a.iridescenceFactor), void 0 !== a.iridescenceTexture && i.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), void 0 !== a.iridescenceIor && (t.iridescenceIOR = a.iridescenceIor), void 0 === t.iridescenceThicknessRange && (t.iridescenceThicknessRange = [100, 400]), void 0 !== a.iridescenceThicknessMinimum && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), void 0 !== a.iridescenceThicknessMaximum && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), void 0 !== a.iridescenceThicknessTexture && i.push(n.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                Hu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_SHEEN
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [];
                            t.sheenColor = new fr(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
                            var a = r.extensions[this.name];
                            return void 0 !== a.sheenColorFactor && t.sheenColor.fromArray(a.sheenColorFactor), void 0 !== a.sheenRoughnessFactor && (t.sheenRoughness = a.sheenRoughnessFactor), void 0 !== a.sheenColorTexture && i.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ke)), void 0 !== a.sheenRoughnessTexture && i.push(n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                Gu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_TRANSMISSION
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            return void 0 !== a.transmissionFactor && (t.transmission = a.transmissionFactor), void 0 !== a.transmissionTexture && i.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                Vu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_VOLUME
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0, void 0 !== a.thicknessTexture && i.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
                            var o = a.attenuationColor || [1, 1, 1];
                            return t.attenuationColor = new fr(o[0], o[1], o[2]), Promise.all(i)
                        }
                    }]), e
                }(),
                Wu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_IOR
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser.json.materials[e];
                            if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
                            var r = n.extensions[this.name];
                            return t.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
                        }
                    }]), e
                }(),
                ju = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_SPECULAR
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            t.specularIntensity = void 0 !== a.specularFactor ? a.specularFactor : 1, void 0 !== a.specularTexture && i.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
                            var o = a.specularColorFactor || [1, 1, 1];
                            return t.specularColor = new fr(o[0], o[1], o[2]), void 0 !== a.specularColorTexture && i.push(n.assignTexture(t, "specularColorMap", a.specularColorTexture, Ke)), Promise.all(i)
                        }
                    }]), e
                }(),
                Xu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_MATERIALS_ANISOTROPY
                    }
                    return o(e, [{
                        key: "getMaterialType",
                        value: function (e) {
                            var t = this.parser.json.materials[e];
                            return t.extensions && t.extensions[this.name] ? Zs : null
                        }
                    }, {
                        key: "extendMaterialParams",
                        value: function (e, t) {
                            var n = this.parser,
                                r = n.json.materials[e];
                            if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
                            var i = [],
                                a = r.extensions[this.name];
                            return void 0 !== a.anisotropyStrength && (t.anisotropy = a.anisotropyStrength), void 0 !== a.anisotropyRotation && (t.anisotropyRotation = a.anisotropyRotation), void 0 !== a.anisotropyTexture && i.push(n.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(i)
                        }
                    }]), e
                }(),
                qu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.KHR_TEXTURE_BASISU
                    }
                    return o(e, [{
                        key: "loadTexture",
                        value: function (e) {
                            var t = this.parser,
                                n = t.json,
                                r = n.textures[e];
                            if (!r.extensions || !r.extensions[this.name]) return null;
                            var i = r.extensions[this.name],
                                a = t.options.ktx2Loader;
                            if (!a) {
                                if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
                                return null
                            }
                            return t.loadTextureImage(e, i.source, a)
                        }
                    }]), e
                }(),
                Yu = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.EXT_TEXTURE_WEBP, this.isSupported = null
                    }
                    return o(e, [{
                        key: "loadTexture",
                        value: function (e) {
                            var t = this.name,
                                n = this.parser,
                                r = n.json,
                                i = r.textures[e];
                            if (!i.extensions || !i.extensions[t]) return null;
                            var a = i.extensions[t],
                                o = r.images[a.source],
                                s = n.textureLoader;
                            if (o.uri) {
                                var l = n.options.manager.getHandler(o.uri);
                                null !== l && (s = l)
                            }
                            return this.detectSupport().then((function (i) {
                                if (i) return n.loadTextureImage(e, a.source, s);
                                if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
                                return n.loadTexture(e)
                            }))
                        }
                    }, {
                        key: "detectSupport",
                        value: function () {
                            return this.isSupported || (this.isSupported = new Promise((function (e) {
                                var t = new Image;
                                t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function () {
                                    e(1 === t.height)
                                }
                            }))), this.isSupported
                        }
                    }]), e
                }(),
                Ku = function () {
                    function e(t) {
                        i(this, e), this.parser = t, this.name = Du.EXT_TEXTURE_AVIF, this.isSupported = null
                    }
                    return o(e, [{
                        key: "loadTexture",
                        value: function (e) {
                            var t = this.name,
                                n = this.parser,
                                r = n.json,
                                i = r.textures[e];
                            if (!i.extensions || !i.extensions[t]) return null;
                            var a = i.extensions[t],
                                o = r.images[a.source],
                                s = n.textureLoader;
                            if (o.uri) {
                                var l = n.options.manager.getHandler(o.uri);
                                null !== l && (s = l)
                            }
                            return this.detectSupport().then((function (i) {
                                if (i) return n.loadTextureImage(e, a.source, s);
                                if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
                                return n.loadTexture(e)
                            }))
                        }
                    }, {
                        key: "detectSupport",
                        value: function () {
                            return this.isSupported || (this.isSupported = new Promise((function (e) {
                                var t = new Image;
                                t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function () {
                                    e(1 === t.height)
                                }
                            }))), this.isSupported
                        }
                    }]), e
                }(),
                Zu = function () {
                    function e(t) {
                        i(this, e), this.name = Du.EXT_MESHOPT_COMPRESSION, this.parser = t
                    }
                    return o(e, [{
                        key: "loadBufferView",
                        value: function (e) {
                            var t = this.parser.json,
                                n = t.bufferViews[e];
                            if (n.extensions && n.extensions[this.name]) {
                                var r = n.extensions[this.name],
                                    i = this.parser.getDependency("buffer", r.buffer),
                                    a = this.parser.options.meshoptDecoder;
                                if (!a || !a.supported) {
                                    if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                                    return null
                                }
                                return i.then((function (e) {
                                    var t = r.byteOffset || 0,
                                        n = r.byteLength || 0,
                                        i = r.count,
                                        o = r.byteStride,
                                        s = new Uint8Array(e, t, n);
                                    return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(i, o, s, r.mode, r.filter).then((function (e) {
                                        return e.buffer
                                    })) : a.ready.then((function () {
                                        var e = new ArrayBuffer(i * o);
                                        return a.decodeGltfBuffer(new Uint8Array(e), i, o, s, r.mode, r.filter), e
                                    }))
                                }))
                            }
                            return null
                        }
                    }]), e
                }(),
                Ju = function () {
                    function e(t) {
                        i(this, e), this.name = Du.EXT_MESH_GPU_INSTANCING, this.parser = t
                    }
                    return o(e, [{
                        key: "createNodeMesh",
                        value: function (e) {
                            var t = this,
                                n = this.parser.json,
                                r = n.nodes[e];
                            if (!r.extensions || !r.extensions[this.name] || void 0 === r.mesh) return null;
                            var i, a = n.meshes[r.mesh],
                                o = p(a.primitives);
                            try {
                                for (o.s(); !(i = o.n()).done;) {
                                    var s = i.value;
                                    if (s.mode !== lc.TRIANGLES && s.mode !== lc.TRIANGLE_STRIP && s.mode !== lc.TRIANGLE_FAN && void 0 !== s.mode) return null
                                }
                            } catch (e) {
                                o.e(e)
                            } finally {
                                o.f()
                            }
                            var l = r.extensions[this.name].attributes,
                                u = [],
                                c = {},
                                h = function (e) {
                                    u.push(t.parser.getDependency("accessor", l[e]).then((function (t) {
                                        return c[e] = t, c[e]
                                    })))
                                };
                            for (var d in l) h(d);
                            return u.length < 1 ? null : (u.push(this.parser.createNodeMesh(e)), Promise.all(u).then((function (e) {
                                var n, r = e.pop(),
                                    i = r.isGroup ? r.children : [r],
                                    a = e[0].count,
                                    o = [],
                                    s = p(i);
                                try {
                                    for (s.s(); !(n = s.n()).done;) {
                                        for (var l = n.value, u = new En, h = new Xt, d = new jt, f = new Xt(1, 1, 1), m = new Es(l.geometry, l.material, a), v = 0; v < a; v++) c.TRANSLATION && h.fromBufferAttribute(c.TRANSLATION, v), c.ROTATION && d.fromBufferAttribute(c.ROTATION, v), c.SCALE && f.fromBufferAttribute(c.SCALE, v), m.setMatrixAt(v, u.compose(h, d, f));
                                        for (var g in c) "TRANSLATION" !== g && "ROTATION" !== g && "SCALE" !== g && l.geometry.setAttribute(g, c[g]);
                                        Yn.prototype.copy.call(m, l), t.parser.assignFinalMaterial(m), o.push(m)
                                    }
                                } catch (e) {
                                    s.e(e)
                                } finally {
                                    s.f()
                                }
                                return r.isGroup ? (r.clear(), r.add.apply(r, o), r) : o[0]
                            })))
                        }
                    }]), e
                }(),
                Qu = "glTF",
                $u = 1313821514,
                ec = 5130562,
                tc = o((function e(t) {
                    i(this, e), this.name = Du.KHR_BINARY_GLTF, this.content = null, this.body = null;
                    var n = new DataView(t, 0, 12),
                        r = new TextDecoder;
                    if (this.header = {
                            magic: r.decode(new Uint8Array(t.slice(0, 4))),
                            version: n.getUint32(4, !0),
                            length: n.getUint32(8, !0)
                        }, this.header.magic !== Qu) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
                    if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
                    for (var a = this.header.length - 12, o = new DataView(t, 12), s = 0; s < a;) {
                        var l = o.getUint32(s, !0);
                        s += 4;
                        var u = o.getUint32(s, !0);
                        if (s += 4, u === $u) {
                            var c = new Uint8Array(t, 12 + s, l);
                            this.content = r.decode(c)
                        } else if (u === ec) {
                            var h = 12 + s;
                            this.body = t.slice(h, h + l)
                        }
                        s += l
                    }
                    if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
                })),
                nc = function () {
                    function e(t, n) {
                        if (i(this, e), !n) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
                        this.name = Du.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = n, this.dracoLoader.preload()
                    }
                    return o(e, [{
                        key: "decodePrimitive",
                        value: function (e, t) {
                            var n = this.json,
                                r = this.dracoLoader,
                                i = e.extensions[this.name].bufferView,
                                a = e.extensions[this.name].attributes,
                                o = {},
                                s = {},
                                l = {};
                            for (var u in a) {
                                var c = fc[u] || u.toLowerCase();
                                o[c] = a[u]
                            }
                            for (var h in e.attributes) {
                                var d = fc[h] || h.toLowerCase();
                                if (void 0 !== a[h]) {
                                    var f = n.accessors[e.attributes[h]],
                                        p = uc[f.componentType];
                                    l[d] = p.name, s[d] = !0 === f.normalized
                                }
                            }
                            return t.getDependency("bufferView", i).then((function (e) {
                                return new Promise((function (t) {
                                    r.decodeDracoFile(e, (function (e) {
                                        for (var n in e.attributes) {
                                            var r = e.attributes[n],
                                                i = s[n];
                                            void 0 !== i && (r.normalized = i)
                                        }
                                        t(e)
                                    }), o, l)
                                }))
                            }))
                        }
                    }]), e
                }(),
                rc = function () {
                    function e() {
                        i(this, e), this.name = Du.KHR_TEXTURE_TRANSFORM
                    }
                    return o(e, [{
                        key: "extendTexture",
                        value: function (e, t) {
                            return void 0 !== t.texCoord && t.texCoord !== e.channel || void 0 !== t.offset || void 0 !== t.rotation || void 0 !== t.scale ? (e = e.clone(), void 0 !== t.texCoord && (e.channel = t.texCoord), void 0 !== t.offset && e.offset.fromArray(t.offset), void 0 !== t.rotation && (e.rotation = t.rotation), void 0 !== t.scale && e.repeat.fromArray(t.scale), e.needsUpdate = !0, e) : e
                        }
                    }]), e
                }(),
                ic = o((function e() {
                    i(this, e), this.name = Du.KHR_MESH_QUANTIZATION
                })),
                ac = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n(e, r, a, o) {
                        return i(this, n), t.call(this, e, r, a, o)
                    }
                    return o(n, [{
                        key: "copySampleValue_",
                        value: function (e) {
                            for (var t = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = e * r * 3 + r, a = 0; a !== r; a++) t[a] = n[i + a];
                            return t
                        }
                    }, {
                        key: "interpolate_",
                        value: function (e, t, n, r) {
                            for (var i = this.resultBuffer, a = this.sampleValues, o = this.valueSize, s = 2 * o, l = 3 * o, u = r - t, c = (n - t) / u, h = c * c, d = h * c, f = e * l, p = f - l, m = -2 * d + 3 * h, v = d - h, g = 1 - m, _ = v - h + c, y = 0; y !== o; y++) {
                                var x = a[p + y + o],
                                    M = a[p + y + s] * u,
                                    S = a[f + y + o],
                                    E = a[f + y] * u;
                                i[y] = g * x + _ * M + m * S + v * E
                            }
                            return i
                        }
                    }]), n
                }(rl),
                oc = new jt,
                sc = function (e) {
                    E(n, e);
                    var t = b(n);

                    function n() {
                        return i(this, n), t.apply(this, arguments)
                    }
                    return o(n, [{
                        key: "interpolate_",
                        value: function (e, t, r, i) {
                            var a = g(y(n.prototype), "interpolate_", this).call(this, e, t, r, i);
                            return oc.fromArray(a).normalize().toArray(a), a
                        }
                    }]), n
                }(ac),
                lc = {
                    FLOAT: 5126,
                    FLOAT_MAT3: 35675,
                    FLOAT_MAT4: 35676,
                    FLOAT_VEC2: 35664,
                    FLOAT_VEC3: 35665,
                    FLOAT_VEC4: 35666,
                    LINEAR: 9729,
                    REPEAT: 10497,
                    SAMPLER_2D: 35678,
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6,
                    UNSIGNED_BYTE: 5121,
                    UNSIGNED_SHORT: 5123
                },
                uc = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                },
                cc = {
                    9728: j,
                    9729: Y,
                    9984: X,
                    9985: K,
                    9986: q,
                    9987: Z
                },
                hc = {
                    33071: V,
                    33648: W,
                    10497: G
                },
                dc = {
                    SCALAR: 1,
                    VEC2: 2,
                    VEC3: 3,
                    VEC4: 4,
                    MAT2: 4,
                    MAT3: 9,
                    MAT4: 16
                },
                fc = {
                    POSITION: "position",
                    NORMAL: "normal",
                    TANGENT: "tangent",
                    TEXCOORD_0: "uv",
                    TEXCOORD_1: "uv1",
                    TEXCOORD_2: "uv2",
                    TEXCOORD_3: "uv3",
                    COLOR_0: "color",
                    WEIGHTS_0: "skinWeight",
                    JOINTS_0: "skinIndex"
                },
                pc = {
                    scale: "scale",
                    translation: "position",
                    rotation: "quaternion",
                    weights: "morphTargetInfluences"
                },
                mc = {
                    CUBICSPLINE: void 0,
                    LINEAR: He,
                    STEP: ze
                },
                vc = "OPAQUE",
                gc = "MASK",
                _c = "BLEND";

            function yc(e, t, n) {
                for (var r in n.extensions) void 0 === e[r] && (t.userData.gltfExtensions = t.userData.gltfExtensions || {}, t.userData.gltfExtensions[r] = n.extensions[r])
            }

            function xc(e, t) {
                void 0 !== t.extras && ("object" === hu(t.extras) ? Object.assign(e.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
            }

            function Mc(e, t) {
                if (e.updateMorphTargets(), void 0 !== t.weights)
                    for (var n = 0, r = t.weights.length; n < r; n++) e.morphTargetInfluences[n] = t.weights[n];
                if (t.extras && Array.isArray(t.extras.targetNames)) {
                    var i = t.extras.targetNames;
                    if (e.morphTargetInfluences.length === i.length) {
                        e.morphTargetDictionary = {};
                        for (var a = 0, o = i.length; a < o; a++) e.morphTargetDictionary[i[a]] = a
                    } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
                }
            }

            function Sc(e) {
                var t, n = e.extensions && e.extensions[Du.KHR_DRACO_MESH_COMPRESSION];
                if (t = n ? "draco:" + n.bufferView + ":" + n.indices + ":" + Ec(n.attributes) : e.indices + ":" + Ec(e.attributes) + ":" + e.mode, void 0 !== e.targets)
                    for (var r = 0, i = e.targets.length; r < i; r++) t += ":" + Ec(e.targets[r]);
                return t
            }

            function Ec(e) {
                for (var t = "", n = Object.keys(e).sort(), r = 0, i = n.length; r < i; r++) t += n[r] + ":" + e[n[r]] + ";";
                return t
            }

            function Tc(e) {
                switch (e) {
                    case Int8Array:
                        return 1 / 127;
                    case Uint8Array:
                        return 1 / 255;
                    case Int16Array:
                        return 1 / 32767;
                    case Uint16Array:
                        return 1 / 65535;
                    default:
                        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
                }
            }
            var bc = new En,
                Ac = function () {
                    function e() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                        i(this, e), this.json = t, this.extensions = {}, this.plugins = {}, this.options = n, this.cache = new Uu, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
                            refs: {},
                            uses: {}
                        }, this.cameraCache = {
                            refs: {},
                            uses: {}
                        }, this.lightCache = {
                            refs: {},
                            uses: {}
                        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
                        var r = !1,
                            a = !1,
                            o = -1;
                        "undefined" != typeof navigator && (r = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent), o = (a = navigator.userAgent.indexOf("Firefox") > -1) ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), "undefined" == typeof createImageBitmap || r || a && o < 98 ? this.textureLoader = new bl(this.options.manager) : this.textureLoader = new Gl(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new El(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
                    }
                    return o(e, [{
                        key: "setExtensions",
                        value: function (e) {
                            this.extensions = e
                        }
                    }, {
                        key: "setPlugins",
                        value: function (e) {
                            this.plugins = e
                        }
                    }, {
                        key: "parse",
                        value: function (e, t) {
                            var n = this,
                                r = this.json,
                                i = this.extensions;
                            this.cache.removeAll(), this.nodeCache = {}, this._invokeAll((function (e) {
                                return e._markDefs && e._markDefs()
                            })), Promise.all(this._invokeAll((function (e) {
                                return e.beforeRoot && e.beforeRoot()
                            }))).then((function () {
                                return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
                            })).then((function (t) {
                                var a = {
                                    scene: t[0][r.scene || 0],
                                    scenes: t[0],
                                    animations: t[1],
                                    cameras: t[2],
                                    asset: r.asset,
                                    parser: n,
                                    userData: {}
                                };
                                yc(i, a, r), xc(a, r), Promise.all(n._invokeAll((function (e) {
                                    return e.afterRoot && e.afterRoot(a)
                                }))).then((function () {
                                    e(a)
                                }))
                            })).catch(t)
                        }
                    }, {
                        key: "_markDefs",
                        value: function () {
                            for (var e = this.json.nodes || [], t = this.json.skins || [], n = this.json.meshes || [], r = 0, i = t.length; r < i; r++)
                                for (var a = t[r].joints, o = 0, s = a.length; o < s; o++) e[a[o]].isBone = !0;
                            for (var l = 0, u = e.length; l < u; l++) {
                                var c = e[l];
                                void 0 !== c.mesh && (this._addNodeRef(this.meshCache, c.mesh), void 0 !== c.skin && (n[c.mesh].isSkinnedMesh = !0)), void 0 !== c.camera && this._addNodeRef(this.cameraCache, c.camera)
                            }
                        }
                    }, {
                        key: "_addNodeRef",
                        value: function (e, t) {
                            void 0 !== t && (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
                        }
                    }, {
                        key: "_getNodeRef",
                        value: function (e, t, n) {
                            var r = this;
                            if (e.refs[t] <= 1) return n;
                            var i = n.clone();
                            return function e(t, n) {
                                var i = r.associations.get(t);
                                null != i && r.associations.set(n, i);
                                var a, o = p(t.children.entries());
                                try {
                                    for (o.s(); !(a = o.n()).done;) {
                                        var s = m(a.value, 2),
                                            l = s[0];
                                        e(s[1], n.children[l])
                                    }
                                } catch (e) {
                                    o.e(e)
                                } finally {
                                    o.f()
                                }
                            }(n, i), i.name += "_instance_" + e.uses[t]++, i
                        }
                    }, {
                        key: "_invokeOne",
                        value: function (e) {
                            var t = Object.values(this.plugins);
                            t.push(this);
                            for (var n = 0; n < t.length; n++) {
                                var r = e(t[n]);
                                if (r) return r
                            }
                            return null
                        }
                    }, {
                        key: "_invokeAll",
                        value: function (e) {
                            var t = Object.values(this.plugins);
                            t.unshift(this);
                            for (var n = [], r = 0; r < t.length; r++) {
                                var i = e(t[r]);
                                i && n.push(i)
                            }
                            return n
                        }
                    }, {
                        key: "getDependency",
                        value: function (e, t) {
                            var n = e + ":" + t,
                                r = this.cache.get(n);
                            if (!r) {
                                switch (e) {
                                    case "scene":
                                        r = this.loadScene(t);
                                        break;
                                    case "node":
                                        r = this._invokeOne((function (e) {
                                            return e.loadNode && e.loadNode(t)
                                        }));
                                        break;
                                    case "mesh":
                                        r = this._invokeOne((function (e) {
                                            return e.loadMesh && e.loadMesh(t)
                                        }));
                                        break;
                                    case "accessor":
                                        r = this.loadAccessor(t);
                                        break;
                                    case "bufferView":
                                        r = this._invokeOne((function (e) {
                                            return e.loadBufferView && e.loadBufferView(t)
                                        }));
                                        break;
                                    case "buffer":
                                        r = this.loadBuffer(t);
                                        break;
                                    case "material":
                                        r = this._invokeOne((function (e) {
                                            return e.loadMaterial && e.loadMaterial(t)
                                        }));
                                        break;
                                    case "texture":
                                        r = this._invokeOne((function (e) {
                                            return e.loadTexture && e.loadTexture(t)
                                        }));
                                        break;
                                    case "skin":
                                        r = this.loadSkin(t);
                                        break;
                                    case "animation":
                                        r = this._invokeOne((function (e) {
                                            return e.loadAnimation && e.loadAnimation(t)
                                        }));
                                        break;
                                    case "camera":
                                        r = this.loadCamera(t);
                                        break;
                                    default:
                                        if (!(r = this._invokeOne((function (n) {
                                                return n != this && n.getDependency && n.getDependency(e, t)
                                            })))) throw new Error("Unknown type: " + e)
                                }
                                this.cache.add(n, r)
                            }
                            return r
                        }
                    }, {
                        key: "getDependencies",
                        value: function (e) {
                            var t = this.cache.get(e);
                            if (!t) {
                                var n = this,
                                    r = this.json[e + ("mesh" === e ? "es" : "s")] || [];
                                t = Promise.all(r.map((function (t, r) {
                                    return n.getDependency(e, r)
                                }))), this.cache.add(e, t)
                            }
                            return t
                        }
                    }, {
                        key: "loadBuffer",
                        value: function (e) {
                            var t = this.json.buffers[e],
                                n = this.fileLoader;
                            if (t.type && "arraybuffer" !== t.type) throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
                            if (void 0 === t.uri && 0 === e) return Promise.resolve(this.extensions[Du.KHR_BINARY_GLTF].body);
                            var r = this.options;
                            return new Promise((function (e, i) {
                                n.load(Hl.resolveURL(t.uri, r.path), e, void 0, (function () {
                                    i(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
                                }))
                            }))
                        }
                    }, {
                        key: "loadBufferView",
                        value: function (e) {
                            var t = this.json.bufferViews[e];
                            return this.getDependency("buffer", t.buffer).then((function (e) {
                                var n = t.byteLength || 0,
                                    r = t.byteOffset || 0;
                                return e.slice(r, r + n)
                            }))
                        }
                    }, {
                        key: "loadAccessor",
                        value: function (e) {
                            var t = this,
                                n = this.json,
                                r = this.json.accessors[e];
                            if (void 0 === r.bufferView && void 0 === r.sparse) {
                                var i = dc[r.type],
                                    a = uc[r.componentType],
                                    o = !0 === r.normalized,
                                    s = new a(r.count * i);
                                return Promise.resolve(new _r(s, i, o))
                            }
                            var l = [];
                            return void 0 !== r.bufferView ? l.push(this.getDependency("bufferView", r.bufferView)) : l.push(null), void 0 !== r.sparse && (l.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), l.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(l).then((function (e) {
                                var i, a, o = e[0],
                                    s = dc[r.type],
                                    l = uc[r.componentType],
                                    u = l.BYTES_PER_ELEMENT,
                                    c = u * s,
                                    h = r.byteOffset || 0,
                                    d = void 0 !== r.bufferView ? n.bufferViews[r.bufferView].byteStride : void 0,
                                    f = !0 === r.normalized;
                                if (d && d !== c) {
                                    var p = Math.floor(h / d),
                                        m = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + p + ":" + r.count,
                                        v = t.cache.get(m);
                                    v || (i = new l(o, p * d, r.count * d / u), v = new Jo(i, d / u), t.cache.add(m, v)), a = new $o(v, s, h % d / u, f)
                                } else i = null === o ? new l(r.count * s) : new l(o, h, r.count * s), a = new _r(i, s, f);
                                if (void 0 !== r.sparse) {
                                    var g = dc.SCALAR,
                                        _ = uc[r.sparse.indices.componentType],
                                        y = r.sparse.indices.byteOffset || 0,
                                        x = r.sparse.values.byteOffset || 0,
                                        M = new _(e[1], y, r.sparse.count * g),
                                        S = new l(e[2], x, r.sparse.count * s);
                                    null !== o && (a = new _r(a.array.slice(), a.itemSize, a.normalized));
                                    for (var E = 0, T = M.length; E < T; E++) {
                                        var b = M[E];
                                        if (a.setX(b, S[E * s]), s >= 2 && a.setY(b, S[E * s + 1]), s >= 3 && a.setZ(b, S[E * s + 2]), s >= 4 && a.setW(b, S[E * s + 3]), s >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                                    }
                                }
                                return a
                            }))
                        }
                    }, {
                        key: "loadTexture",
                        value: function (e) {
                            var t = this.json,
                                n = this.options,
                                r = t.textures[e].source,
                                i = t.images[r],
                                a = this.textureLoader;
                            if (i.uri) {
                                var o = n.manager.getHandler(i.uri);
                                null !== o && (a = o)
                            }
                            return this.loadTextureImage(e, r, a)
                        }
                    }, {
                        key: "loadTextureImage",
                        value: function (e, t, n) {
                            var r = this,
                                i = this.json,
                                a = i.textures[e],
                                o = i.images[t],
                                s = (o.uri || o.bufferView) + ":" + a.sampler;
                            if (this.textureCache[s]) return this.textureCache[s];
                            var l = this.loadImageSource(t, n).then((function (t) {
                                t.flipY = !1, t.name = a.name || o.name || "", "" === t.name && "string" == typeof o.uri && !1 === o.uri.startsWith("data:image/") && (t.name = o.uri);
                                var n = (i.samplers || {})[a.sampler] || {};
                                return t.magFilter = cc[n.magFilter] || Y, t.minFilter = cc[n.minFilter] || Z, t.wrapS = hc[n.wrapS] || G, t.wrapT = hc[n.wrapT] || G, r.associations.set(t, {
                                    textures: e
                                }), t
                            })).catch((function () {
                                return null
                            }));
                            return this.textureCache[s] = l, l
                        }
                    }, {
                        key: "loadImageSource",
                        value: function (e, t) {
                            var n = this.json,
                                r = this.options;
                            if (void 0 !== this.sourceCache[e]) return this.sourceCache[e].then((function (e) {
                                return e.clone()
                            }));
                            var i = n.images[e],
                                a = self.URL || self.webkitURL,
                                o = i.uri || "",
                                s = !1;
                            if (void 0 !== i.bufferView) o = this.getDependency("bufferView", i.bufferView).then((function (e) {
                                s = !0;
                                var t = new Blob([e], {
                                    type: i.mimeType
                                });
                                return o = a.createObjectURL(t)
                            }));
                            else if (void 0 === i.uri) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
                            var l = Promise.resolve(o).then((function (e) {
                                return new Promise((function (n, i) {
                                    var a = n;
                                    !0 === t.isImageBitmapLoader && (a = function (e) {
                                        var t = new Bt(e);
                                        t.needsUpdate = !0, n(t)
                                    }), t.load(Hl.resolveURL(e, r.path), a, void 0, i)
                                }))
                            })).then((function (e) {
                                var t;
                                return !0 === s && a.revokeObjectURL(o), e.userData.mimeType = i.mimeType || ((t = i.uri).search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/) ? "image/jpeg" : t.search(/\.webp($|\?)/i) > 0 || 0 === t.search(/^data\:image\/webp/) ? "image/webp" : "image/png"), e
                            })).catch((function (e) {
                                throw console.error("THREE.GLTFLoader: Couldn't load texture", o), e
                            }));
                            return this.sourceCache[e] = l, l
                        }
                    }, {
                        key: "assignTexture",
                        value: function (e, t, n, r) {
                            var i = this;
                            return this.getDependency("texture", n.index).then((function (a) {
                                if (!a) return null;
                                if (void 0 !== n.texCoord && n.texCoord > 0 && ((a = a.clone()).channel = n.texCoord), i.extensions[Du.KHR_TEXTURE_TRANSFORM]) {
                                    var o = void 0 !== n.extensions ? n.extensions[Du.KHR_TEXTURE_TRANSFORM] : void 0;
                                    if (o) {
                                        var s = i.associations.get(a);
                                        a = i.extensions[Du.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), i.associations.set(a, s)
                                    }
                                }
                                return void 0 !== r && (a.colorSpace = r), e[t] = a, a
                            }))
                        }
                    }, {
                        key: "assignFinalMaterial",
                        value: function (e) {
                            var t = e.geometry,
                                n = e.material,
                                r = void 0 === t.attributes.tangent,
                                i = void 0 !== t.attributes.color,
                                a = void 0 === t.attributes.normal;
                            if (e.isPoints) {
                                var o = "PointsMaterial:" + n.uuid,
                                    s = this.cache.get(o);
                                s || (s = new Ds, lr.prototype.copy.call(s, n), s.color.copy(n.color), s.map = n.map, s.sizeAttenuation = !1, this.cache.add(o, s)), n = s
                            } else if (e.isLine) {
                                var l = "LineBasicMaterial:" + n.uuid,
                                    u = this.cache.get(l);
                                u || (u = new Ts, lr.prototype.copy.call(u, n), u.color.copy(n.color), u.map = n.map, this.cache.add(l, u)), n = u
                            }
                            if (r || i || a) {
                                var c = "ClonedMaterial:" + n.uuid + ":";
                                r && (c += "derivative-tangents:"), i && (c += "vertex-colors:"), a && (c += "flat-shading:");
                                var h = this.cache.get(c);
                                h || (h = n.clone(), i && (h.vertexColors = !0), a && (h.flatShading = !0), r && (h.normalScale && (h.normalScale.y *= -1), h.clearcoatNormalScale && (h.clearcoatNormalScale.y *= -1)), this.cache.add(c, h), this.associations.set(h, this.associations.get(n))), n = h
                            }
                            e.material = n
                        }
                    }, {
                        key: "getMaterialType",
                        value: function () {
                            return Ks
                        }
                    }, {
                        key: "loadMaterial",
                        value: function (e) {
                            var t, n = this,
                                r = this.json,
                                i = this.extensions,
                                a = r.materials[e],
                                o = {},
                                s = [];
                            if ((a.extensions || {})[Du.KHR_MATERIALS_UNLIT]) {
                                var l = i[Du.KHR_MATERIALS_UNLIT];
                                t = l.getMaterialType(), s.push(l.extendParams(o, a, n))
                            } else {
                                var u = a.pbrMetallicRoughness || {};
                                if (o.color = new fr(1, 1, 1), o.opacity = 1, Array.isArray(u.baseColorFactor)) {
                                    var c = u.baseColorFactor;
                                    o.color.fromArray(c), o.opacity = c[3]
                                }
                                void 0 !== u.baseColorTexture && s.push(n.assignTexture(o, "map", u.baseColorTexture, Ke)), o.metalness = void 0 !== u.metallicFactor ? u.metallicFactor : 1, o.roughness = void 0 !== u.roughnessFactor ? u.roughnessFactor : 1, void 0 !== u.metallicRoughnessTexture && (s.push(n.assignTexture(o, "metalnessMap", u.metallicRoughnessTexture)), s.push(n.assignTexture(o, "roughnessMap", u.metallicRoughnessTexture))), t = this._invokeOne((function (t) {
                                    return t.getMaterialType && t.getMaterialType(e)
                                })), s.push(Promise.all(this._invokeAll((function (t) {
                                    return t.extendMaterialParams && t.extendMaterialParams(e, o)
                                }))))
                            }!0 === a.doubleSided && (o.side = 2);
                            var h = a.alphaMode || vc;
                            if (h === _c ? (o.transparent = !0, o.depthWrite = !1) : (o.transparent = !1, h === gc && (o.alphaTest = void 0 !== a.alphaCutoff ? a.alphaCutoff : .5)), void 0 !== a.normalTexture && t !== mr && (s.push(n.assignTexture(o, "normalMap", a.normalTexture)), o.normalScale = new yt(1, 1), void 0 !== a.normalTexture.scale)) {
                                var d = a.normalTexture.scale;
                                o.normalScale.set(d, d)
                            }
                            return void 0 !== a.occlusionTexture && t !== mr && (s.push(n.assignTexture(o, "aoMap", a.occlusionTexture)), void 0 !== a.occlusionTexture.strength && (o.aoMapIntensity = a.occlusionTexture.strength)), void 0 !== a.emissiveFactor && t !== mr && (o.emissive = (new fr).fromArray(a.emissiveFactor)), void 0 !== a.emissiveTexture && t !== mr && s.push(n.assignTexture(o, "emissiveMap", a.emissiveTexture, Ke)), Promise.all(s).then((function () {
                                var r = new t(o);
                                return a.name && (r.name = a.name), xc(r, a), n.associations.set(r, {
                                    materials: e
                                }), a.extensions && yc(i, r, a), r
                            }))
                        }
                    }, {
                        key: "createUniqueName",
                        value: function (e) {
                            var t = Zl.sanitizeNodeName(e || "");
                            return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
                        }
                    }, {
                        key: "loadGeometries",
                        value: function (e) {
                            var t = this,
                                n = this.extensions,
                                r = this.primitiveCache;

                            function i(e) {
                                return n[Du.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(e, t).then((function (n) {
                                    return wc(n, e, t)
                                }))
                            }
                            for (var a = [], o = 0, s = e.length; o < s; o++) {
                                var l = e[o],
                                    u = Sc(l),
                                    c = r[u];
                                if (c) a.push(c.promise);
                                else {
                                    var h = void 0;
                                    h = l.extensions && l.extensions[Du.KHR_DRACO_MESH_COMPRESSION] ? i(l) : wc(new Cr, l, t), r[u] = {
                                        primitive: l,
                                        promise: h
                                    }, a.push(h)
                                }
                            }
                            return Promise.all(a)
                        }
                    }, {
                        key: "loadMesh",
                        value: function (e) {
                            for (var t, n = this, r = this.json, i = this.extensions, a = r.meshes[e], o = a.primitives, s = [], l = 0, u = o.length; l < u; l++) {
                                var c = void 0 === o[l].material ? (void 0 === (t = this.cache).DefaultMaterial && (t.DefaultMaterial = new Ks({
                                    color: 16777215,
                                    emissive: 0,
                                    metalness: 1,
                                    roughness: 1,
                                    transparent: !1,
                                    depthTest: !0,
                                    side: 0
                                })), t.DefaultMaterial) : this.getDependency("material", o[l].material);
                                s.push(c)
                            }
                            return s.push(n.loadGeometries(o)), Promise.all(s).then((function (t) {
                                for (var r = t.slice(0, t.length - 1), s = t[t.length - 1], l = [], u = 0, c = s.length; u < c; u++) {
                                    var h = s[u],
                                        d = o[u],
                                        f = void 0,
                                        p = r[u];
                                    if (d.mode === lc.TRIANGLES || d.mode === lc.TRIANGLE_STRIP || d.mode === lc.TRIANGLE_FAN || void 0 === d.mode) !0 === (f = !0 === a.isSkinnedMesh ? new us(h, p) : new qr(h, p)).isSkinnedMesh && f.normalizeSkinWeights(), d.mode === lc.TRIANGLE_STRIP ? f.geometry = ku(f.geometry, 1) : d.mode === lc.TRIANGLE_FAN && (f.geometry = ku(f.geometry, 2));
                                    else if (d.mode === lc.LINES) f = new Is(h, p);
                                    else if (d.mode === lc.LINE_STRIP) f = new Ls(h, p);
                                    else if (d.mode === lc.LINE_LOOP) f = new Us(h, p);
                                    else {
                                        if (d.mode !== lc.POINTS) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + d.mode);
                                        f = new zs(h, p)
                                    }
                                    Object.keys(f.geometry.morphAttributes).length > 0 && Mc(f, a), f.name = n.createUniqueName(a.name || "mesh_" + e), xc(f, a), d.extensions && yc(i, f, d), n.assignFinalMaterial(f), l.push(f)
                                }
                                for (var m = 0, v = l.length; m < v; m++) n.associations.set(l[m], {
                                    meshes: e,
                                    primitives: m
                                });
                                if (1 === l.length) return a.extensions && yc(i, l[0], a), l[0];
                                var g = new zo;
                                a.extensions && yc(i, g, a), n.associations.set(g, {
                                    meshes: e
                                });
                                for (var _ = 0, y = l.length; _ < y; _++) g.add(l[_]);
                                return g
                            }))
                        }
                    }, {
                        key: "loadCamera",
                        value: function (e) {
                            var t, n = this.json.cameras[e],
                                r = n[n.type];
                            if (r) return "perspective" === n.type ? t = new ni(_t.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : "orthographic" === n.type && (t = new wi(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), n.name && (t.name = this.createUniqueName(n.name)), xc(t, n), Promise.resolve(t);
                            console.warn("THREE.GLTFLoader: Missing camera parameters.")
                        }
                    }, {
                        key: "loadSkin",
                        value: function (e) {
                            for (var t = this.json.skins[e], n = [], r = 0, i = t.joints.length; r < i; r++) n.push(this._loadNodeShallow(t.joints[r]));
                            return void 0 !== t.inverseBindMatrices ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then((function (e) {
                                for (var n = e.pop(), r = e, i = [], a = [], o = 0, s = r.length; o < s; o++) {
                                    var l = r[o];
                                    if (l) {
                                        i.push(l);
                                        var u = new En;
                                        null !== n && u.fromArray(n.array, 16 * o), a.push(u)
                                    } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[o])
                                }
                                return new ps(i, a)
                            }))
                        }
                    }, {
                        key: "loadAnimation",
                        value: function (e) {
                            for (var t = this.json, n = this, r = t.animations[e], i = r.name ? r.name : "animation_" + e, a = [], o = [], s = [], l = [], u = [], c = 0, h = r.channels.length; c < h; c++) {
                                var d = r.channels[c],
                                    f = r.samplers[d.sampler],
                                    p = d.target,
                                    m = p.node,
                                    v = void 0 !== r.parameters ? r.parameters[f.input] : f.input,
                                    g = void 0 !== r.parameters ? r.parameters[f.output] : f.output;
                                void 0 !== p.node && (a.push(this.getDependency("node", m)), o.push(this.getDependency("accessor", v)), s.push(this.getDependency("accessor", g)), l.push(f), u.push(p))
                            }
                            return Promise.all([Promise.all(a), Promise.all(o), Promise.all(s), Promise.all(l), Promise.all(u)]).then((function (e) {
                                for (var t = e[0], r = e[1], a = e[2], o = e[3], s = e[4], l = [], u = 0, c = t.length; u < c; u++) {
                                    var h = t[u],
                                        d = r[u],
                                        f = a[u],
                                        p = o[u],
                                        m = s[u];
                                    if (void 0 !== h) {
                                        h.updateMatrix && h.updateMatrix();
                                        var v = n._createAnimationTracks(h, d, f, p, m);
                                        if (v)
                                            for (var g = 0; g < v.length; g++) l.push(v[g])
                                    }
                                }
                                return new ml(i, void 0, l)
                            }))
                        }
                    }, {
                        key: "createNodeMesh",
                        value: function (e) {
                            var t = this.json,
                                n = this,
                                r = t.nodes[e];
                            return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function (e) {
                                var t = n._getNodeRef(n.meshCache, r.mesh, e);
                                return void 0 !== r.weights && t.traverse((function (e) {
                                    if (e.isMesh)
                                        for (var t = 0, n = r.weights.length; t < n; t++) e.morphTargetInfluences[t] = r.weights[t]
                                })), t
                            }))
                        }
                    }, {
                        key: "loadNode",
                        value: function (e) {
                            for (var t = this, n = this.json.nodes[e], r = t._loadNodeShallow(e), i = [], a = n.children || [], o = 0, s = a.length; o < s; o++) i.push(t.getDependency("node", a[o]));
                            var l = void 0 === n.skin ? Promise.resolve(null) : t.getDependency("skin", n.skin);
                            return Promise.all([r, Promise.all(i), l]).then((function (e) {
                                var t = e[0],
                                    n = e[1],
                                    r = e[2];
                                null !== r && t.traverse((function (e) {
                                    e.isSkinnedMesh && e.bind(r, bc)
                                }));
                                for (var i = 0, a = n.length; i < a; i++) t.add(n[i]);
                                return t
                            }))
                        }
                    }, {
                        key: "_loadNodeShallow",
                        value: function (e) {
                            var t = this.json,
                                n = this.extensions,
                                r = this;
                            if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
                            var i = t.nodes[e],
                                a = i.name ? r.createUniqueName(i.name) : "",
                                o = [],
                                s = r._invokeOne((function (t) {
                                    return t.createNodeMesh && t.createNodeMesh(e)
                                }));
                            return s && o.push(s), void 0 !== i.camera && o.push(r.getDependency("camera", i.camera).then((function (e) {
                                return r._getNodeRef(r.cameraCache, i.camera, e)
                            }))), r._invokeAll((function (t) {
                                return t.createNodeAttachment && t.createNodeAttachment(e)
                            })).forEach((function (e) {
                                o.push(e)
                            })), this.nodeCache[e] = Promise.all(o).then((function (t) {
                                var o;
                                if ((o = !0 === i.isBone ? new cs : t.length > 1 ? new zo : 1 === t.length ? t[0] : new Yn) !== t[0])
                                    for (var s = 0, l = t.length; s < l; s++) o.add(t[s]);
                                if (i.name && (o.userData.name = i.name, o.name = a), xc(o, i), i.extensions && yc(n, o, i), void 0 !== i.matrix) {
                                    var u = new En;
                                    u.fromArray(i.matrix), o.applyMatrix4(u)
                                } else void 0 !== i.translation && o.position.fromArray(i.translation), void 0 !== i.rotation && o.quaternion.fromArray(i.rotation), void 0 !== i.scale && o.scale.fromArray(i.scale);
                                return r.associations.has(o) || r.associations.set(o, {}), r.associations.get(o).nodes = e, o
                            })), this.nodeCache[e]
                        }
                    }, {
                        key: "loadScene",
                        value: function (e) {
                            var t = this.extensions,
                                n = this.json.scenes[e],
                                r = this,
                                i = new zo;
                            n.name && (i.name = r.createUniqueName(n.name)), xc(i, n), n.extensions && yc(t, i, n);
                            for (var a = n.nodes || [], o = [], s = 0, l = a.length; s < l; s++) o.push(r.getDependency("node", a[s]));
                            return Promise.all(o).then((function (e) {
                                for (var t = 0, n = e.length; t < n; t++) i.add(e[t]);
                                return r.associations = function (e) {
                                    var t, n = new Map,
                                        i = p(r.associations);
                                    try {
                                        for (i.s(); !(t = i.n()).done;) {
                                            var a = m(t.value, 2),
                                                o = a[0],
                                                s = a[1];
                                            (o instanceof lr || o instanceof Bt) && n.set(o, s)
                                        }
                                    } catch (e) {
                                        i.e(e)
                                    } finally {
                                        i.f()
                                    }
                                    return e.traverse((function (e) {
                                        var t = r.associations.get(e);
                                        null != t && n.set(e, t)
                                    })), n
                                }(i), i
                            }))
                        }
                    }, {
                        key: "_createAnimationTracks",
                        value: function (e, t, n, r, i) {
                            var a, o = [],
                                s = e.name ? e.name : e.uuid,
                                l = [];
                            switch (pc[i.path] === pc.weights ? e.traverse((function (e) {
                                e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid)
                            })) : l.push(s), pc[i.path]) {
                                case pc.weights:
                                    a = cl;
                                    break;
                                case pc.rotation:
                                    a = dl;
                                    break;
                                case pc.position:
                                case pc.scale:
                                    a = pl;
                                    break;
                                default:
                                    if (1 === n.itemSize) a = cl;
                                    else a = pl
                            }
                            for (var u = void 0 !== r.interpolation ? mc[r.interpolation] : He, c = this._getArrayFromAccessor(n), h = 0, d = l.length; h < d; h++) {
                                var f = new a(l[h] + "." + pc[i.path], t.array, c, u);
                                "CUBICSPLINE" === r.interpolation && this._createCubicSplineTrackInterpolant(f), o.push(f)
                            }
                            return o
                        }
                    }, {
                        key: "_getArrayFromAccessor",
                        value: function (e) {
                            var t = e.array;
                            if (e.normalized) {
                                for (var n = Tc(t.constructor), r = new Float32Array(t.length), i = 0, a = t.length; i < a; i++) r[i] = t[i] * n;
                                t = r
                            }
                            return t
                        }
                    }, {
                        key: "_createCubicSplineTrackInterpolant",
                        value: function (e) {
                            e.createInterpolant = function (e) {
                                return new(this instanceof dl ? sc : ac)(this.times, this.values, this.getValueSize() / 3, e)
                            }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                        }
                    }]), e
                }();

            function wc(e, t, n) {
                var r = t.attributes,
                    i = [];

                function a(t, r) {
                    return n.getDependency("accessor", t).then((function (t) {
                        e.setAttribute(r, t)
                    }))
                }
                for (var o in r) {
                    var s = fc[o] || o.toLowerCase();
                    s in e.attributes || i.push(a(r[o], s))
                }
                if (void 0 !== t.indices && !e.index) {
                    var l = n.getDependency("accessor", t.indices).then((function (t) {
                        e.setIndex(t)
                    }));
                    i.push(l)
                }
                return xc(e, t),
                    function (e, t, n) {
                        var r = t.attributes,
                            i = new Kt;
                        if (void 0 !== r.POSITION) {
                            var a = n.json.accessors[r.POSITION],
                                o = a.min,
                                s = a.max;
                            if (void 0 !== o && void 0 !== s) {
                                if (i.set(new Xt(o[0], o[1], o[2]), new Xt(s[0], s[1], s[2])), a.normalized) {
                                    var l = Tc(uc[a.componentType]);
                                    i.min.multiplyScalar(l), i.max.multiplyScalar(l)
                                }
                                var u = t.targets;
                                if (void 0 !== u) {
                                    for (var c = new Xt, h = new Xt, d = 0, f = u.length; d < f; d++) {
                                        var p = u[d];
                                        if (void 0 !== p.POSITION) {
                                            var m = n.json.accessors[p.POSITION],
                                                v = m.min,
                                                g = m.max;
                                            if (void 0 !== v && void 0 !== g) {
                                                if (h.setX(Math.max(Math.abs(v[0]), Math.abs(g[0]))), h.setY(Math.max(Math.abs(v[1]), Math.abs(g[1]))), h.setZ(Math.max(Math.abs(v[2]), Math.abs(g[2]))), m.normalized) {
                                                    var _ = Tc(uc[m.componentType]);
                                                    h.multiplyScalar(_)
                                                }
                                                c.max(h)
                                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                                        }
                                    }
                                    i.expandByVector(c)
                                }
                                e.boundingBox = i;
                                var y = new pn;
                                i.getCenter(y.center), y.radius = i.min.distanceTo(i.max) / 2, e.boundingSphere = y
                            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
                        }
                    }(e, t, n), Promise.all(i).then((function () {
                        return void 0 !== t.targets ? function (e, t, n) {
                            for (var r = !1, i = !1, a = !1, o = 0, s = t.length; o < s; o++) {
                                var l = t[o];
                                if (void 0 !== l.POSITION && (r = !0), void 0 !== l.NORMAL && (i = !0), void 0 !== l.COLOR_0 && (a = !0), r && i && a) break
                            }
                            if (!r && !i && !a) return Promise.resolve(e);
                            for (var u = [], c = [], h = [], d = 0, f = t.length; d < f; d++) {
                                var p = t[d];
                                if (r) {
                                    var m = void 0 !== p.POSITION ? n.getDependency("accessor", p.POSITION) : e.attributes.position;
                                    u.push(m)
                                }
                                if (i) {
                                    var v = void 0 !== p.NORMAL ? n.getDependency("accessor", p.NORMAL) : e.attributes.normal;
                                    c.push(v)
                                }
                                if (a) {
                                    var g = void 0 !== p.COLOR_0 ? n.getDependency("accessor", p.COLOR_0) : e.attributes.color;
                                    h.push(g)
                                }
                            }
                            return Promise.all([Promise.all(u), Promise.all(c), Promise.all(h)]).then((function (t) {
                                var n = t[0],
                                    o = t[1],
                                    s = t[2];
                                return r && (e.morphAttributes.position = n), i && (e.morphAttributes.normal = o), a && (e.morphAttributes.color = s), e.morphTargetsRelative = !0, e
                            }))
                        }(e, t.targets, n) : e
                    }))
            }
            var Rc, Cc = function () {
                function e() {
                    a()(this, e)
                }
                return s()(e, [{
                    key: "loadGLTF",
                    value: function (e, t, n, r) {
                        var i = new Iu,
                            a = new Lu;
                        return a.setDecoderPath("./draco/"), a.setDecoderConfig({
                            type: "js"
                        }), a.preload(), i.setDRACOLoader(a), new Promise((function (a, o) {
                            i.load(e, (function (e) {
                                a(t ? t(e) : e)
                            }), (function (e) {
                                n && n(e)
                            }), (function (e) {
                                r && r(e), o(e)
                            }))
                        }))
                    }
                }, {
                    key: "loadFbx",
                    value: function (e, t, n, r) {}
                }]), e
            }();
            ! function (e) {
                e.GLTF = "gltf", e.GLB = "glb", e.FBX = "fbx"
            }(Rc || (Rc = {}));
            var Lc = {
                moveTo: Eu,
                moveLine: function (e, t) {
                    var n = function (e) {
                            var t = new Ys(d()(e)),
                                n = t.getPoints(50),
                                r = (new Cr).setFromPoints(n),
                                i = new Ts({
                                    opacity: 1
                                });
                            return [new Ls(r, i), t]
                        }([e.position, t.position]),
                        r = v()(n, 2),
                        i = r[0];
                    r[1];
                    Su.scene.add(i)
                },
                moveWithRound: function (e) {
                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .1,
                        n = arguments.length > 2 ? arguments[2] : void 0,
                        r = 0,
                        i = 0,
                        a = 0,
                        o = function () {
                            r += t, i = 4 * Math.sin(r), a = 4 * Math.cos(r), e.position.set(i, 0, a)
                        };
                    Mu.add(o, n), Mu.start()
                }
            }
        }(), r
    }()
}));